local Patrols = {}

function FindCommand (_group, _command)
    if table.getn (Patrols) == 0 then return 0 end
    for a = 1, table.getn (Patrols), 1 do
        if Patrols[a].group == _group and Patrols[a].command == _command then
           return a
        end
    end
    return 0
end

function AddToCommand (_group, _command, _member, _npc)
    --find command
    local index = this.FindCommand (_group, _command)
--    printf ("Index = %d", index)
    --if command present - add the new member
    if index ~= 0 then
--       printf ("Find command %s_%d", _group, _command)
       local t = {npc = _npc, member = _member, variables = {}}
       table.insert (Patrols[index].members, t)
--       printf ("New member successfully added")
       return
    end

    --create new command
    local temp = {
                 group = _group,
                 command = _command,
                 members = {}
                 }
    local t =
             {
             npc = _npc,
             member = _member,
             variables = {}
             }
    table.insert (temp.members, t)
    table.insert (Patrols, temp)
--    printf ("New command successfully added")
end

function RemoveFromCommand (_group, _command, _member)

    if table.getn (Patrols) == 0 then
       printf ("ERROR !!! Requested remove patrol member %s_%d_%d. Patrols table is empty !!!", _group, _command, _member)
       return
    end

    for a = 1, table.getn (Patrols), 1 do
        if Patrols[a].group == _group and Patrols[a].command == _command then
--           printf ("Find in %s_%d", _group, _command)
--           printf ("Size of table Patrols[a].members is %d units", table.getn (Patrols[a].members))
           for b = 1, table.getn (Patrols[a].members), 1 do
--               printf ("Member %d", Patrols[a].members[b].member)
              if Patrols[a].members[b].member == _member then
                 table.remove (Patrols[a].members, b)
                 printf ("Remove member %s_%d_%d", _group, _command, _member)
                 if table.getn (Patrols[a].members) == 0 then
                    table.remove (Patrols, a)
                    printf ("Patrol group %s_%d is empty. Removed", _group, _command)
                 end
                 return
              end
           end
        end
    end
    printf ("ERROR !!! Requested remove patrol member %s_%d_%d. Member not found !!!", _group, _command, _member)
end


function PrintTable ()

    printf ("----------------------Start table---------------------------------")
    if table.getn (Patrols) == 0 then printf ("Table is empty") end
    for a = 1, table.getn (Patrols), 1 do
        printf ("Patrol Unit %d", a)
        printf ("Patrol group : %s, patrol command : %d", Patrols[a].group, Patrols[a].command)
        if table.getn (Patrols[a].members) == 0 then
           printf ("Member table is empty")
        else
           for b = 1, table.getn (Patrols[a].members), 1 do
               printf ("NPC : %s, member %d", Patrols[a].members[b].npc:name (), Patrols[a].members[b].member)
           end
        end
    end
    printf ("----------------------End table-----------------------------------")
end




----------------------------------------------------------------------------------------------------------------------
--Evaluator const
----------------------------------------------------------------------------------------------------------------------
class "evaluator_const"		(property_evaluator)
----------------------------------------------------------------------------------------------------------------------
function evaluator_const:__init(value) super()
	self.value = value
end
----------------------------------------------------------------------------------------------------------------------
function evaluator_const:evaluate()
	return self.value
end
----------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------
-- Action path
----------------------------------------------------------------------------------------------------------------------
class "action_path" (action_base)

function action_path:__init (path,name) super (nil,name)
    self.path = path
end

function action_path:initialize ()
	action_base.initialize (self)
	self.object:set_node_evaluator		()
	self.object:set_path_evaluator		()
	self.object:set_desired_position	()
	self.object:set_desired_direction	()    
	
	self.object:play_sound				(2, 60000, 10000)
	self.object:set_sight				(look.path_dir,nil,0)
	self.object:set_item				(object.idle)
	self.object:set_path_type			(game_object.patrol_path)
	self.object:set_patrol_path			(self.path, patrol.start, patrol.continue, true)
	self.object:set_detail_path_type	(move.line)
	self.object:set_body_state			(move.standing)
	self.object:set_movement_type		(move.walk)
	self.object:set_mental_state		(anim.free)
	
end

function action_path:execute ()
	action_base.execute					(self)
end

function action_path:finalize ()
	action_base.finalize (self)
end

----------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------
--Patrol binder
----------------------------------------------------------------------------------------------------------------------
class "patrol_binder" (object_binder)
----------------------------------------------------------------------------------------------------------------------
function patrol_binder:__init (obj) super(obj)
    self.npc = obj
end
----------------------------------------------------------------------------------------------------------------------
function patrol_binder:reinit ()
	object_binder.reinit	(self)
end
----------------------------------------------------------------------------------------------------------------------
function patrol_binder:reload (section)
	object_binder.reload	(self, section)
	local					actions = {}
	local					properties = {}
	local					manager	= self.object:motivation_action_manager ()
	local					goal = world_state ()

	properties["path_end"]	= stalker_ids.property_script + 1
	actions["move"]		    = stalker_ids.action_script   + 1
	
	goal:clear ()
	-- // evaluators
	manager:add_evaluator	(properties["path_end"],	this.evaluator_const	(false))

--	action = this.action_path (globals.GetPatrolPath (self.npc:name ()),"action_path")
	action = this.action_path ("patrol_way","action_path")
	action:add_precondition	(world_property(stalker_ids.property_alive,	true))
	action:add_precondition	(world_property(stalker_ids.property_items,	false))
	action:add_precondition	(world_property(stalker_ids.property_enemy,	false))
--	action:add_effect		(world_property(properties["path_end"],	    true))
	manager:add_action		(actions["move"],			                action)
	
	action                  = manager:action (stalker_ids.action_free_no_alife)
	action:add_precondition (world_property(properties["path_end"],	    true))
end
----------------------------------------------------------------------------------------------------------------------
function patrol_binder:net_spawn	(server_object)
    printf ("NetSpawn called")
	if (object_binder.net_spawn(self,server_object) == false) then
	   return false
	end
	local name, group, command, member = str_split (self.npc:name ())
    this.AddToCommand (group, command, member, self.npc)
    this.PrintTable ()
	return true
end
----------------------------------------------------------------------------------------------------------------------
function patrol_binder:net_destroy	()
    printf ("NetDestroy called")
	local name, group, command, member = str_split (self.npc:name ())
    this.RemoveFromCommand (group, command, member)
	object_binder.net_destroy	(self)
end
----------------------------------------------------------------------------------------------------------------------

function AddToPatrol (npc, group, command, member)
	npc:bind_object	(this.patrol_binder (npc))
end

