--[[------------------------------------------------------------------------------------------------
Helicopter movement
Чугай Саша

Сделать:
	- летать зацикленно
	- смотреть в точку
	- скоростные параметры в именах вершин
--------------------------------------------------------------------------------------------------]]

local default_wait_time = 5000

local dummy_vector = vector()

local state_move = 0
local state_look = 1

----------------------------------------------------------------------------------------------------
class "heli_move"

function heli_move:__init( obj, storage )
	self.object     = obj
	self.heliObject = obj:get_helicopter()
	self.a          = storage

	self.default_velocity = utils.cfg_get_number( bind_heli.get_heli_ltx(), "helicopter", "velocity", self.object, true )
end

function heli_move:reset_scheme()
	printf("heli_move: reset_scheme: %s", self.object:name())

	self.heliObject:TurnEngineSound( self.a.engine_sound )

	self.patrol_move = patrol(self.a.path_move)
	if not self.patrol_move then
		utils.abort("object '%s': unable to find path_move '%s' on the map",
			self.object:name(), self.a.path_move)
	end

	if self.a.path_look then
		self.patrol_look = patrol(self.a.path_look)
		if not self.patrol_look then
			utils.abort("object '%s': unable to find path_look '%s' on the map",
				self.object:name(), self.a.path_look)
		end
	else
		self.patrol_look = nil
	end

	if self.a.path_move_info == nil then
		self.a.path_move_info = utils.path_parse_waypoints(self.a.path_move)
		self.path_move_info = self.a.path_move_info
	end

	if self.a.path_look_info == nil then
		self.a.path_look_info = utils.path_parse_waypoints(self.a.path_look)
		self.path_look_info = self.a.path_look_info
	end

	self.last_index       = nil
	self.last_look_index  = nil
	self.look_finish_time = nil
	self.was_callback     = false

	self:update_movement_state()
--	self.heliObject:GoByRoundPath( self.patrol_look:point( 0 ), 50, true )
end

function heli_move:update( delta )
	--printf("__hd: mob_walker update: %d", device():time_global())

	if xr_logic.try_switch_to_another_section( self.object, self.a, db.actor ) then
		return
	end

	if self.was_callback then
		if self.look_index then
			self:update_look_state()
		else
			self:update_movement_state()
		end

		self.was_callback = false
	end

	if self.state == state_look then
		if self.look_finish_time < device():time_global() then
			self:update_movement_state()
		end
	end
end

function heli_move:waypoint_callback( obj, action_type, index )
	if index == self.last_index then
		return
	end

	printf("heli_move:waypoint_callback(): name=%s, index=%d", self.object:name(), index)

	if index ~= -1 then
		self.last_index = index
	else
		self.last_index = self.next_index
	end

	self.was_callback = true
end

-- поиск точки для смотрения по флажкам
function heli_move:search_look_waypoint( index )
	if not self.patrol_look then
		return nil
	end

	local search_for = self.path_move_info[index].flags
	if search_for:get() == 0 then
		return nil
	end

	local pt_chosen_idx = move_mgr.choose_look_point( self.patrol_look, self.path_look_info, search_for ) -- индекс выбранной точки

	if pt_chosen_idx then
		return pt_chosen_idx
	else
		utils.abort("object '%s': path_move '%s', index %d: cannot find corresponding point(s) on path_look '%s'",
			self.object:name(), self.path_walk, index, self.path_look)
	end
end

function heli_move:waypoint_param( path_info, idx, field, default )
	local v
	local wpnt = path_info[idx]

	if wpnt then
		v = wpnt[field]
	end

	return ( v and tonumber( v ) ) or default
end

-- просмотреть флажки следующующей точки пути и продолжить движение соответствующим образом
function heli_move:update_movement_state()
	self.state = state_moving

	if not self.last_index then
		self.next_index = 0
	else
		self.next_index = self.last_index + 1

		if self.next_index >= self.patrol_move:count() then
			self.next_index = 0
		end
	end

	self.look_index = self:search_look_waypoint( self.next_index )

	if self.look_index then
		self:prepare_look()
	else
		self:prepare_move()
	end
end

-- подготовить обычный полёт к следующей точке
function heli_move:prepare_move()
	if self.heliObject:GetState() ~= CHelicopter.eMovPatrolPath or self.next_index == 0 then
		printf( "heli_move: starting patrol '%s' from point %d", self.a.path_move, self.next_index )
--		self.object:info_clear()
--		self.object:info_add( tostring( "next point: " .. self.next_index ) )

		self.heliObject:SetMaxVelocity     ( self:waypoint_param( self.path_move_info, self.last_index, "v",  self.default_velocity ) )
		self.heliObject:SetSpeedInDestPoint( self:waypoint_param( self.path_move_info, self.next_index, "dv", self.default_velocity ) )

		self.heliObject:GoPatrolByPatrolPath( self.a.path_move, self.next_index )
	end

	-- смотреть вперёд
	self.heliObject:LookAtPoint( dummy_vector, false )
end

-- подготовить полёт к следующей точке с учётом того, что в ней мы будем смотреть в точку из path_look
function heli_move:prepare_look()
	printf( "heli_move: going to look in the next point %d", self.next_index )

	self.look_duration = self:waypoint_param( self.path_look_info, self.look_index, "t" )

	-- если нужно задержаться в следующей точке, то отправить в точку (destspeed=0), иначе отправить по пути (destspeed="dv")
	if self.look_duration then
		printf( "heli_move: sent to position" )

		self.heliObject:SetSpeedInDestPoint( 0 )
		self.heliObject:SetDestPosition( self.patrol_move:point( self.next_index ) )
	else
		printf( "heli_move: sent to patrol path" )

		self.heliObject:SetSpeedInDestPoint( self:waypoint_param( self.path_move_info, self.next_index, "dv", self.default_velocity ) )
		self.heliObject:GoPatrolByPatrolPath( self.a.path_move, self.next_index )
	end

	self.heliObject:LookAtPoint( self.patrol_look:point( self.look_index ), true )

	-- атаковать выбранную точку уже на подлёте, если задано "att" в следующей точке path_move
	self:process_attack_param( self.path_move_info, self.next_index )

	printf( "heli_move: dest speed = %d", self.heliObject:GetSpeedInDestPoint( 0 ) )
end

--[[function heli_move:prepare_look()
	printf( "heli_move: going to look in the next point %d", self.next_index )

	self.look_duration = nil

	-- если не задан облёт вокруг следующей точки, то будем поворачиваться заранее
--	self.round_look_direction = self:waypoint_param( self.path_look_info, self.look_index, "c" )

--	if self.round_look_direction == nil then
		self.look_duration = self:waypoint_param( self.path_look_info, self.look_index, "t" )

		-- если хотим задержаться, то подлететь к следующей точке с 0 скоростью, иначе с заданной (или по-умолчанию)
		if self.look_duration then
			printf( "0" )
			self.heliObject:SetSpeedInDestPoint( 0 )
		else
			self.heliObject:SetSpeedInDestPoint( self:waypoint_param( self.path_move_info, self.next_index, "dv", self.default_velocity ) )
		end

		self.heliObject:LookAtPoint( self.patrol_look:point( self.look_index ), true )

		printf( "heli_move: dest speed = %d", self.heliObject:GetSpeedInDestPoint( 0 ) )
--	else
--		self.round_look_direction = self.round_look_direction ~= "ccw"
--	end

	-- если нужно задержаться в следующей точке, то отправить в точку, иначе по пути
	if self.look_duration then
		printf( "heli_move: sent to position" )
		self.heliObject:SetDestPosition( self.patrol_move:point( self.next_index ) )
	else
		printf( "heli_move: sent to patrol path" )
		self.heliObject:GoPatrolByPatrolPath( self.a.path_move, self.next_index )
	end
end]]

-- мы на точке, в которой прописано смотрение в другую точку
function heli_move:update_look_state()
	printf( "heli_move: start looking" )

	self.state = state_look

	-- если хотели задержаться, то посчитать время окончания задержки, иначе оно уже наступило
	if self.look_duration then
		self.look_finish_time = self.look_duration + device():time_global()

		self:process_attack_param( self.path_look_info, self.look_index )
	else
		self.look_finish_time = 0
	end

--	self.heliObject:SetMaxVelocity( 0 )
--	self.heliObject:SetEnemy( db.actor )

--[[	if self.round_look_direction == nil then
		self.heliObject:SetCurrVelocity( 0 )
	else
		self.heliObject:GoByRoundPath( self.patrol_look:point( self.look_index ), 50, self.round_look_direction )
		printf( "round look" )
	end]]
end

function heli_move:process_attack_param( path_info, index )
	local attack_type = self:waypoint_param( path_info, index, "att" )

	if attack_type then
		printf( "heli_move: attack!" )
		self.heliObject:SetEnemy( self.patrol_look:point( self.look_index ) )
	else
--		self.heliObject:SetEnemy( nil )
	end
end

---------------------------------------------------------------------------------------------------------------------

function add_to_binder( npc, ini, scheme, section, storage )
	printf( "DEBUG: add_to_binder: npc:name()='%s', scheme='%s', section='%s'", npc:name(), scheme, section )

	local new_action = heli_move( npc, storage )

	-- Зарегистрировать все actions, в которых должен быть вызван метод reset_scheme при изменении настроек схемы:
	xr_logic.subscribe_action_for_events( npc, storage, new_action )
end

function set_scheme( npc, ini, scheme, section )
	local a = xr_logic.assign_storage_and_bind( npc, ini, scheme, section )

	a.logic = xr_logic.cfg_get_switch_conditions( ini, section, npc )

	a.path_move       = utils.cfg_get_string( ini, section, "path_move",    npc, true,  ""   )
	a.path_look       = utils.cfg_get_string( ini, section, "path_look",    npc, false, ""   )
	a.engine_sound    = utils.cfg_get_bool  ( ini, section, "engine_sound", npc, false, true )

	a.path_move_info = nil -- Будут инициализированы в reset(), сейчас пути могут быть еще
	a.path_look_info = nil -- не загружены.
end
