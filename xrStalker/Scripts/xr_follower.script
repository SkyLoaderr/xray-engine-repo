local animations = {
                   {anim = "stoya_ruje_ 0",       flag = true},
                   {anim = "vishka_3",            flag = false},
                   {anim = "norm_torso_2_idle_1", flag = false},
                   {anim = "norm_torso_2_idle_2", flag = true},
                   {anim = "norm_torso_2_idle_3", flag = false},
                   {anim = "norm_torso_2_idle_4", flag = true},
                   {anim = "norm_torso_2_idle_5", flag = false},
                   {anim = "norm_torso_2_idle_6", flag = false}
                   }


local anim_pris = {
                  {anim = "prisluh_0", flag = false},
                  {anim = "prisluh_1", flag = false},
                  {anim = "prisluh_2", flag = false}
                  }
                  
local anim_raid = {
                  {anim = "spetsnaz_0", flag = false},
                  {anim = "spetsnaz_1", flag = false},
                  {anim = "spetsnaz_2", flag = false},
                  {anim = "spetsnaz_3", flag = false},
                  {anim = "spetsnaz_4", flag = false},
                  {anim = "spetsnaz_5", flag = false},
                  {anim = "spetsnaz_6", flag = false},
                  {anim = "spetsnaz_7", flag = false}
                  }
                                     

local commander_snd                     = xr_sounds_id.sound_patrol_base
local soldiers_idle_snd                 = commander_snd + 1
local soldiers_hear_snd                 = commander_snd + 2
local soldiers_idle2_snd                = commander_snd + 3
local soldiers_replics_snd              = commander_snd + 4

local leader_no_command					= 0
local leader_move                       = 1
local leader_stop                       = 2
local leader_speak						= 3
local leader_speak_enable				= 4
local leader_return                     = 5  

local num_phrases = 10

----------------------------------------------------------------------------------------------------------------------
-- Evaluators
----------------------------------------------------------------------------------------------------------------------
-- Есть лидер
class "evaluator_leader_present" (property_evaluator)
function evaluator_leader_present:__init (name, storage) super ()
	self.a = storage
end
--------------
function evaluator_leader_present:evaluate ()
    if self.a.leader == nil then
       if self.a.leader_name == nil then return false end 
       self.a.leader = level.object (self.a.leader_name)
       if self.a.leader == nil then 
          return false 
       else
          table.insert (xr_motivator.storage[self.a.leader:id()].followers, self.a)
       end   
    end
    return true
end

----------------------------------------------------------------------------------------------------------------------
-- Окончание следования
class "evaluator_follow" (property_evaluator)
function evaluator_follow:__init (name, storage) super ()
	self.a = storage
end
--------------
function evaluator_follow:evaluate ()
    return not (self.a.enabled == true)
end


----------------------------------------------------------------------------------------------------------------------
-- Окончание рейда
class "evaluator_raid" (property_evaluator)
function evaluator_raid:__init (name, storage) super ()
	self.a = storage
end
--------------
function evaluator_raid:evaluate ()
    return not (self.a.raid_enabled == true)
end

----------------------------------------------------------------------------------------------------------------------
-- Actions
----------------------------------------------------------------------------------------------------------------------
-- Если нет лидера - стоим ждем
class "action_leader_wait" (action_base)
--------------
function action_leader_wait:__init (name, storage) super (nil, name)
	self.a = storage
    self.current_animation = 0
end
--------------
function action_leader_wait:initialize ()
    action_base.initialize (self)
    self.object:set_node_evaluator        ()
    self.object:set_path_evaluator        ()
    self.object:set_desired_position      ()
    self.object:set_item                  (object.idle, self.object:best_weapon ())
    self.object:set_detail_path_type      (move.line)
    self.object:set_body_state            (move.standing)
    self.object:set_movement_type         (move.stand)
    self.object:set_path_type             (game_object.level_path)
    self.object:set_mental_state          (anim.free)
    self.object:set_sight                 (look.path_dir, nil, 0)
end
--------------
function action_leader_wait:execute ()
    action_base.execute                 (self)
    self.object:set_item                (object.idle, self.object:best_weapon ())
    if self.object:animation_count () < 2 then
       self:set_animation ()
    end    
end
--------------
function action_leader_wait:finalize ()
    action_base.finalize (self)
    self.object:clear_animations ()
end
--------------
function action_leader_wait:set_animation ()

    self.current_animation = self.current_animation + 1
    if self.current_animation > table.getn (animations) then
       self.current_animation = 1
    end

    self.object:add_animation (animations[self.current_animation].anim, animations[self.current_animation].flag)
end


----------------------------------------------------------------------------------------------------------------------
-- Следуем за лидером
class "action_follow" (action_base)
function action_follow:__init (name, storage) super (nil, name)
	self.a = storage
    self.current_vertex_id = -1
    self.stage = 0
    self.leader_v_id = -1
    self.last_time = 0
    self.current_animation = math.random (1, table.getn (animations))
    self.current_phrase = math.random (0, num_phrases)
    self.mental_state = anim.free
    self.time = 0
end
--------------
function action_follow:initialize ()
    action_base.initialize (self)

    self.object:set_callback (self, "move_callback", game_object.movement)
    
    self.object:set_node_evaluator        ()
    self.object:set_path_evaluator        ()
    self.object:set_desired_position      ()
    self.object:set_item                  (object.activate, self.object:best_weapon ())
    self.object:set_detail_path_type      (move.line)
    self.object:set_body_state            (move.standing)
    self.object:set_movement_type         (move.stand)
    self.object:set_path_type             (game_object.level_path)
    self.object:set_mental_state          (self.a.mental_state)
    self.object:set_sight                 (look.path_dir, nil, 0)
    

    
    if self.stage ~= 3 then 
       self.stage = 0 
       self:check_path ()    
       self.object:set_dest_level_vertex_id  (self.current_vertex_id)
       self.object:set_movement_type         (move.walk)
    else
       if self.a.escape_path == nil then 
          self.a.enabled = false
          self.stage = 0
          return true
       end         
       self.object:set_path_type (game_object.patrol_path)
       self.object:set_patrol_path (self.a.escape_path, patrol.nearest, patrol.stop, false)
       self.object:set_mental_state (anim.danger)
       self.object:set_movement_type (move.run)
    end   
    
    self.last_time = 0
end
--------------
function action_follow:execute ()
    action_base.execute                 (self)
    
    if self.object:active_item () ~= nil then
       self.object:set_item                  (object.idle, self.object:best_weapon ())
    else
       self.object:set_item                  (object.activate, self.object:best_weapon ())     
    end   
            
    if self.stage == 0 then 
       if self:check_path () == false then
          self:update_stage_0 ()
       end   
    elseif self.stage == 1 then        
       self:check_path                     ()
       self:update_stage_1 ()
    elseif self.stage == 2 then
       self:update_stage_2 ()
    elseif self.stage == 3 then
       --
    elseif self.stage == 4 then
       self:update_stage_4 ()         
    end       
    --printf ("CURRENT STAGE = %d", self.stage)
end    
--------------
function action_follow:finalize ()
    action_base.finalize (self)
    self.object:clear_animations ()
    self.object:clear_callback (game_object.movement)
end
--------------
function action_follow:move_callback (obj, action_type, index)
    if index == -1 then return end
    if patrol (self.object:patrol ()):flag (index, 6) == true then
       self.a.stage = 0 
       self.a.enabled = false
    end   
end
--------------
function action_follow:check_path ()

    if self.a.leader:alive () == false or self.a.leader_command == leader_return then 
       if self.a.escape_path == nil then 
          self.a.enabled = false
          return false
       end         
       self.object:set_path_type (game_object.patrol_path)
       self.object:set_patrol_path (self.a.escape_path, patrol.nearest, patrol.stop, false)
       self.object:set_mental_state (anim.danger)
       self.object:set_movement_type (move.run)
       self.stage = 3 
       return false
    end   
    
    self.object:set_mental_state (self.a.mental_state)
    --self.last_time = self.last_time - device ():time_global ()
    if self.last_time - device ():time_global () > 0 then 
       return false 
    end
    self.last_time = 500 + device ():time_global ()

    --if self.object:level_vertex_id () ~= self.current_vertex_id and self.current_vertex_id ~= -1 then 
--       return false 
--    end
    
    if self.a.leader_command == leader_stop then
       self.object:set_movement_type (move.stand)
       if self.a.look_dir.x == 0 and self.a.look_dir.y == 0 and self.a.look_dir.z == 0 then 
          self.stage = 2  
          return false
       end
       self.object:set_sight (look.direction, self.a.look_dir, 0)
       self.stage = 4
       self.time = device ():time_global ()        
       return true
    end   
    
    local cv_id = level.vertex_in_direction (self.a.leader:level_vertex_id (), self.a.direction, self.a.distance)
    if cv_id == self.current_vertex_id then return false end
    self.current_vertex_id = cv_id
    self.object:set_desired_direction (self.a.leader:direction ())
    self.object:set_dest_level_vertex_id  (self.current_vertex_id)   
    self.object:set_sight (look.path_dir, nil, 0)
    return false
end
--------------
function action_follow:recalculate_position ()
    local cv_id = level.vertex_in_direction (self.a.leader:level_vertex_id (), self.a.direction, self.a.distance)
    if cv_id == self.current_vertex_id then return end
    self.current_vertex_id = cv_id
    self.object:set_desired_direction (self.a.leader:direction ())
    self.object:set_dest_level_vertex_id  (self.current_vertex_id)   
    self.object:set_sight (look.path_dir, nil, 0)
end
--------------
function action_follow:update_stage_0 ()

	if self.a.leader_command == leader_speak then
       self.object:set_sound_mask (2147483647)
       self.object:set_sound_mask (0)
       self.a.leader_command = 0
    end   
    
	if self.a.leader_command == leader_speak_enable then
	   self.current_phrase = self.current_phrase + 1 
	   if self.current_phrase >= num_phrases then self.current_phrase = 0 end
       self.object:set_sound_mask (2147483647)
       self.object:set_sound_mask (0)
       self.object:play_sound (soldiers_idle_snd, 1, 0, 1, 0, self.current_phrase)
       self.a.leader_command = 0
    end   
	   

    if self.object:position ():distance_to (level.vertex_position (self.a.leader:level_vertex_id ())) < (self.a.distance * 3) then
       self.object:set_movement_type         (move.walk)
       self.object:set_mental_state          (self.a.mental_state)
       self.object:set_sight                 (look.path_dir, nil, 0)
       self.object:set_desired_direction     (self.a.leader:direction ())
       return
    end
    self.stage = 1
    self:update_stage_1 ()   
end
--------------
function action_follow:update_stage_1 ()
    if self.object:position ():distance_to (level.vertex_position (self.a.leader:level_vertex_id ())) < (self.a.distance + self.a.distance * 0.5) then
       self.stage = 0
       self:update_stage_0 ()
       return 
    end
    self.last_time = -1
    self.current_vertex_id = -1
    self:check_path ()
    self.object:set_movement_type         (move.run)
    self.object:set_mental_state          (anim.danger)
    self.object:set_sight                 (look.path_dir, nil, 0)
    self.object:set_desired_direction     (self.a.leader:direction ())
        
end
----------------------------------------------------------------------------------------------------------------------
function action_follow:update_stage_2 ()
    if self.a.leader_command == leader_move then
       self.stage = 0
       self.object:clear_animations ()
       return
    end 
    if self.object:animation_count () <= 1 then
       self:set_animation ()
    end    
    self.object:set_movement_type (move.stand)
end
----------------------------------------------------------------------------------------------------------------------
function action_follow:update_stage_4 ()
    if device ():time_global () - self.time > 1500 then
       self.stage = 2
       return
    end    
end
----------------------------------------------------------------------------------------------------------------------
function action_follow:set_animation ()

    self.current_animation = self.current_animation + 1
    if self.current_animation > table.getn (animations) then
       self.current_animation = 1
    end

    self.object:add_animation (animations[self.current_animation].anim, animations[self.current_animation].flag)
end




-- рейд
class "action_raid" (action_base)
--------------
function action_raid:__init (name, storage) super (nil, name)
	self.a = storage
    self.current_animation = 0
    self.move_type = move.walk
    self.body_state = move.standing
    self.mental_state = anim.free
    self.stage = 0
end
--------------
function action_raid:initialize ()
    action_base.initialize (self)
    
    self.object:set_callback (self, "move_callback", game_object.movement)
    
    self.object:set_node_evaluator        ()
    self.object:set_path_evaluator        ()
    self.object:set_desired_position      ()
    self.object:set_desired_direction     ()
    self.object:set_item                  (object.idle, self.object:best_weapon ())
    self.object:set_detail_path_type      (move.line)
    self.object:set_body_state            (self.body_state)
    self.object:set_movement_type         (self.move_type)
    self.object:set_path_type             (game_object.patrol_path)
    self.object:set_patrol_path           (self.a.raid_path, patrol.nearest, patrol.continue, true)
    self.object:set_mental_state          (self.mental_state)
    self.object:set_sight                 (look.path_dir, nil, 0)
end
--------------
function action_raid:execute ()
    action_base.execute                 (self)
    if self.stage == 1 then
       if self.object:animation_count () == 0 then
          self.object:set_body_state            (self.body_state)
          self.object:set_movement_type         (self.move_type)
          self.object:set_mental_state          (self.mental_state)
          self.stage = 0
       end
    end      
           
end
--------------
function action_raid:finalize ()
    action_base.finalize (self)
    self.object:clear_animations ()
    self.object:clear_callback (game_object.movement)
end
--------------
function action_raid:set_animation ()

    self.current_animation = self.current_animation + 1
    if self.current_animation > table.getn (animations) then
       self.current_animation = 1
    end

    self.object:add_animation (animations[self.current_animation].anim, animations[self.current_animation].flag)
end
----------------------------------------------------------------------------------------------------------------------
function action_raid:move_callback (obj, action_type, index)
    if index == -1 then return end
    
    local ptr = patrol (self.object:patrol ())
    if ptr:flag (index, 4) == true then
       self.a.raid_enabled = false
       return
    end   
    
    if ptr:flag (index, 8) == true then
       self.object:set_movement_type (move.stand)
       self.move_type = move.walk
       self.body_state = move.standing
       self.mental_state = anim.free
       self.object:set_body_state            (move.standing)
       self.object:set_movement_type         (move.walk)
       self.object:set_mental_state          (anim.free)
       return
    end

    if ptr:flag (index, 9) == true then
       self.object:set_movement_type (move.stand)
       self.body_state = move.standing
       self.move_type = move.run
       self.mental_state = anim.danger
       self.object:set_body_state            (move.standing)
       self.object:set_movement_type         (move.run)
       self.object:set_mental_state          (anim.danger)
       return
    end
    
    if ptr:flag (index, 10) == true then
       self.object:set_movement_type (move.stand)
       self.move_type = move.run
       self.body_state = move.crouch
       self.mental_state = anim.danger
       self.object:set_body_state            (move.crouch)
       self.object:set_movement_type         (move.run)
       self.object:set_mental_state          (anim.danger)
       return
    end
        
    if ptr:flag (index, 11) == true then
       self.object:set_movement_type (move.stand)
       self.object:set_mental_state (anim.free)
       local num
       if self.body_state == move.crouch then     
          num = math.random (1, 4)  
       else
          num = math.random (5, 8)
       end
       self.object:add_animation (anim_raid[num].anim, anim_raid[num].flag)
       self.stage = 1
    end          
end

----------------------------------------------------------------------------------------------------------------------
function  add_to_binder(obj)

	local operators		= {}
	local properties	= {}
	
    printf ("FOLLOWER_EVA_BASE = %d", xr_evaluators_id.sidor_follower_base)
    obj:add_sound ("Scripts\\Patrol\\Commander1_", 20, snd_type.talk, 2, 1, commander_snd)
    obj:add_sound ("Scripts\\Patrol\\soldier_idle_", 20, snd_type.talk, 2, 1, soldiers_idle_snd)
    obj:add_sound ("script_replics\\soldier_1\\idle\\soldier_idle_", 20, snd_type.talk, 2, 1, soldiers_idle2_snd)
    obj:add_sound ("script_replics\\soldier_1\\replics\\soldier_replic_", 20, snd_type.talk, 2, 1, soldiers_replics_snd)
    obj:add_sound ("script_replics\\soldier_1\\hear_something\\soldier_hear_", 20, snd_type.talk, 2, 1, soldiers_hear_snd)

	local manager = obj:motivation_action_manager ()

	properties["leader_present"]        = xr_evaluators_id.sidor_follower_base + 0
	properties["follow"]                = xr_evaluators_id.sidor_follower_base + 1
	properties["raid"]                  = xr_evaluators_id.sidor_follower_base + 2

	operators["leader_wait"]            = xr_actions_id.sidor_act_follower_base + 0
	operators["follow"]                 = xr_actions_id.sidor_act_follower_base + 1
	operators["raid"]                   = xr_actions_id.sidor_act_follower_base + 2
   
    manager:add_evaluator (properties["leader_present"], this.evaluator_leader_present 	("evaluator_leader_alive", xr_motivator.storage[obj:id()].follower))
    manager:add_evaluator (properties["follow"], this.evaluator_follow	("evaluator_follow", xr_motivator.storage[obj:id()].follower))
    manager:add_evaluator (properties["raid"], this.evaluator_raid ("evaluator_raid", xr_motivator.storage[obj:id()].follower))
        
    local action = this.action_leader_wait ("action_leader_wait",	xr_motivator.storage[obj:id()].follower)
    action:add_precondition     (world_property (stalker_ids.property_alive,    true))
    action:add_precondition     (world_property (stalker_ids.property_enemy,    false))
    action:add_precondition     (world_property (properties["leader_present"],  false))
    action:add_effect           (world_property (properties["leader_present"],  true))
    manager:add_action (operators["leader_wait"], action)
    
    action = this.action_follow ("action_follow",			xr_motivator.storage[obj:id()].follower)
    action:add_precondition     (world_property (stalker_ids.property_alive,    true))
    action:add_precondition     (world_property (stalker_ids.property_enemy,    false))
    action:add_precondition     (world_property (properties["leader_present"],  true))
    action:add_precondition     (world_property (properties["raid"],            true))
    action:add_precondition     (world_property (properties["follow"],          false))
    action:add_effect           (world_property (properties["follow"],          true))
    manager:add_action (operators["follow"], action)
    
    action = this.action_raid ("action_raid", xr_motivator.storage[obj:id()].follower)
    action:add_precondition     (world_property (stalker_ids.property_alive,    true))
    action:add_precondition     (world_property (stalker_ids.property_enemy,    false))
    action:add_precondition     (world_property (properties["raid"],            false))
    action:add_effect           (world_property (properties["raid"],            true))
    manager:add_action          (operators["raid"], action)
    
    
    action = manager:action     (stalker_ids.action_free_no_alife)
    action:add_precondition     (world_property (properties["follow"],  true))

    --xr_report.AddScheme (obj)
    
end