
-- Каждая функция в этом файле используется как условие xr_logic: {=функция !функция}
-- Формат: function f(actor, npc)
-- Детали реализации нужно помещать в файл xr_conditions_impl.script, а не в этот файл.

-- DELME: для тестов: {=test_condition_actor_near}
function test_condition_actor_near(actor, npc)
	if distance_between(actor, npc) <= 3 then
		return true
	end
	return false
end

function talking(actor, npc)
	return actor:is_talking()
end

function talking_or_tutor(actor, npc)
	return actor:is_talking() or actor:has_info("esc_trader_experienced") or actor:has_info("esc_trader_newbie")
end

function actor_enemy(actor, npc)
	local t = db.storage[npc:id()].death
	return npc:relation(actor) == game_object.enemy or (t ~= nil and t.killer == actor:id())
end

function gar_dm_nearest_bandit(actor, npc)
	--printf("_bp: xr_conditions: nearest [%s]? %s", npc:name(),
	--		if_then_else(xr_conditions_impl.gar_dm_nearest_bandit(actor, npc, 1), "true", "false"))
	return xr_conditions_impl.gar_dm_nearest_bandit(actor, npc, 1)
end

function gar_dm_2nd_nearest_bandit(actor, npc)
	--printf("_bp: xr_conditions: 2nd nearest [%s]? %s", npc:name(),
	--		if_then_else(xr_conditions_impl.gar_dm_nearest_bandit(actor, npc, 2), "true", "false"))
	return xr_conditions_impl.gar_dm_nearest_bandit(actor, npc, 2)
end

function trade_exchanged(actor, npc)
	return db.storage[npc:id()].trade.exchanged
end

function trading(actor, npc)
	return db.storage[npc:id()].trade.trading
end

function hit_by_actor(actor, npc)
	local t = db.storage[npc:id()].hit
	local hit_by_actor = t ~= nil and t.who == actor:id()
	printf("_bp: hit_by_actor: %s", if_then_else(hit_by_actor, "true", "false"))
	return hit_by_actor
end

function killed_by_actor(actor, npc)
	local t = db.storage[npc:id()].death
	local killed_by_actor = t ~= nil and t.killer == actor:id()
	printf("_bp: killed_by_actor: %s", if_then_else(killed_by_actor, "true", "false"))
	return killed_by_actor
end

function actor_has_weapon (actor, npc)
    local obj = actor:active_item ()
    if obj == nil or isWeapon (obj) == false then return false end
    return true
end

function is_day (actor, npc)
    return utils.is_day ()
end    

function mob_has_enemy (actor, npc)
    if npc == nil then return false end
    --if npc:get_enemy () then printf ("ENEMY PRESENT") else printf ("ENEMY NOT PRESENT") end
    return npc:get_enemy () ~= nil
end    

function mob_actor_nearest (actor, npc)
    return false
    --if npc == nil then return false end
    --printf ("Distance to actor : %d", distance_between (actor, npc))
    --return distance_between (actor, npc) < 20
end    

function fighting_actor(actor, npc)
	return db.storage[npc:id()].enemy:id() == actor:id()
end

function val_fighting_captive(actor, npc)
	-- FIXME: use SID!!!
	return db.storage[npc:id()].enemy:name() == "val_escort_captive"
end    

function val_fighting_sacrifice_victim(actor, npc)
	-- FIXME: use SID!!!
	return db.storage[npc:id()].enemy:name() == "val_sacrifice_victim"
end    

function val_fighting_prisoner(actor, npc)
	-- FIXME: use SID!!!
	return db.storage[npc:id()].enemy:name() == "val_prisoner_captive"
end    

function actor_wears_bandit_outfit(actor, npc)
	--[[
	local cur_eq = actor:get_current_equipment()
	local wears = cur_eq and cur_eq:name() == "bandit_outfit"
	printf("_bp: actor_wears_bandits_outfit: %s", utils.to_str(wears))
	return wears
	--]]
	return xr_conditions_impl.actor_has_object(actor, "bandit_outfit")
end


------------------------------------------------------------------------------------
-- Special functions for LabX18
------------------------------------------------------------------------------------
function dar_actor_has_a_key1(actor,npc)
	return xr_conditions_impl.actor_has_object(actor,"ugrum_flash")
end

function dar_actor_has_a_key2(actor,npc)
	return xr_conditions_impl.actor_has_object(actor,"krot_flash")
end
------------------------------------------------------------------------------------


