
-- Разговор. Разработчик: Andrey Fidrya (Zmey) af@svitonline.com

-- Настройка:

-- Последний раз, когда игрока предупреждали убрать оружие (чтобы часто не повторяться):
warn_rem_weapon_time = nil

local state_none = 0
local state_moving = 1
local state_looking = 2
local state_asking_to_remove_weapon = 3
local state_waiting = 4

local bodyguards = {
}

function stop_talking(id)
	local dis_until = device():time_global() + aftertalk_disable_time
	bodyguards[id].state = state_none
	bodyguards[id].disabled_until = dis_until
	bodyguards[bodyguards[id].whom:id()].state = state_none
	bodyguards[bodyguards[id].whom:id()].disabled_until = dis_until
end


---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
-- Константа
class "evaluator_need_bodyguard" (property_evaluator)

function evaluator_need_bodyguard:__init(storage) super ()
	self.stor = storage

	self.state_none = 0
	self.state_standing = 1
	self.state_moving = 2
	self.state_killing = 3
end

function evaluator_need_bodyguard:evaluate ()
	if not self.stor.enabled then
		return false
	end

	return true
end

---------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
-- Обычное поведение
class "action_bodyguard_activity" (action_base)
function action_bodyguard_activity:__init (npc_name, action_name, storage) super (nil, action_name)
	self.stor = storage
end

function action_bodyguard_activity:initialize()
	--printf("_bp: action_bodyguard_activity: initialize")
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()

	self.object:clear_animations()

	self.object:set_mental_state(anim.free)
	self.object:set_sight(look.search, nil, 0)
	--self.object:set_sight(look.path_dir, nil, 0)
	--self.object:set_sight(look.danger, nil, 0)

	xr_reactions.add_rule(self.object, "ignore")

	self.object:set_callback(self, "waypoint_callback", game_object.movement)
	self:reset_scheme()
end

function action_bodyguard_activity:reset_scheme()
	-- TODO: выбирать активный путь в зависимости от погоды (сделать выбор функцией)
	self.path_main = self.stor.path_main
	if self.stor.path_side then
		self.path_side = self.stor.path_side
	else
		self.path_side = self.path_main
	end
	self.path_active =  self.path_main

	self.path_guard_ptr = patrol(self.stor.path_guard)
	self.path_guard_radius = self.stor.path_guard_radius
	
	-- Точка, в которую смотрели в прошлый раз. Ее запоминаем для того, чтобы не делать паузу между анимациями,
	-- если собираемся смотреть в ту же самую точку, не поворачиваясь никуда...

	self.object:set_item(object.idle, self.object:best_weapon())
	self.object:set_detail_path_type(move.line)
	self.object:set_body_state(move.standing)
	--self.object:set_mental_state(anim.free) -- was
	self.object:set_mental_state(anim.free)
	self.object:set_movement_type(move.walk)
	self.object:set_path_type(game_object.patrol_path)
	self.object:set_patrol_path(self.path_active, patrol.start, patrol.continue, true)
	--self.object:set_mental_state(anim.free)
	self.object:set_sight(look.search, nil, 0)
	--self.object:set_sight(look.danger, nil, 0)

	self.state = self.state_moving

	self.last_index = -1

	local pos = self.object:position()
	local ptr = patrol(self.path_active)
        local num_points = ptr:count()
	local distance = pos:distance_to(ptr:point(0))
	if distance <= 1 then
		printf("simulating callback")
		self:waypoint_callback(self.object, self.last_action_type, self.last_index)
	end
end	

function action_bodyguard_activity:waypoint_callback(obj, action_type, index)
    -- Будет использоваться позже для вызова этой функции с целью иммитации коллбека (для путей, состоящих из одной точки):
    self.last_action_type = action_type
    self.last_index = index

    if index == -1 then
        return
    end

    local ptr = patrol(self.path_active)
    self.object:set_movement_type(move.stand)

    self.object:clear_animations () -- не играть анимацию во время поворота!
    self.expiration_time = device():time_global() + 1500; -- дать 100 мс на поворот
    self:look_at_waypoint(1) -- поворачиваемся
    self.state = self.state_standing
    self.object:set_movement_type(move.stand)
end

-- Посмотреть в направлении указанной точки текущего маршрута
function action_bodyguard_activity:look_at_waypoint(pt)
    local way = patrol (self.object:patrol ())
    local look_pt = xr_guard.vector_copy_by_val(way:point(pt)):sub (self.object:position ())
    self.object:set_sight(look.direction, look_pt, 0)
    self.last_look_index = pt
end

function action_bodyguard_activity:execute()
	self.object:set_item(object.idle, self.object:best_weapon())

	if self.state == self.state_standing then
		local actor = level.actor()
		local dist = 0
		if actor then
			dist = self.object:position():distance_to(actor:position())
		end

		if actor then
			local active_item = actor:active_item()
		        if active_item and isWeapon(active_item) then
				if dist <= 5 and
				   (not this.warn_rem_weapon_time or device():time_global() > this.warn_rem_weapon_time + 60000) then
					self.object:play_sound(xr_sounds_id.zmey_bodyguard_base, 1, 0, 1, 0, 1)
					this.warn_rem_weapon_time = device():time_global()
				elseif dist > 10 and this.warn_rem_weapon_time then
					this.warn_rem_weapon_time = nil
				end

				if self.path_guard_ptr:point(0):distance_to(actor:position()) < self.path_guard_radius then
					if self.object:relation(actor) ~= game_object.enemy then
						self.object:set_relation(game_object.enemy, actor)
					end
					--self.state = self.state_killing
				elseif self.path_active ~= self.path_main then
					self.object:play_sound(xr_sounds_id.zmey_bodyguard_base, 1, 0, 1, 0, 1)
					this.warn_rem_weapon_time = device():time_global()

					self.path_active = self.path_main
					self.object:set_movement_type(move.walk)
					self.object:set_path_type(game_object.patrol_path)
					self.object:set_patrol_path(self.path_active, patrol.start, patrol.continue, true)
					self.state = self.state_moving
				end
			else
				if self.path_active ~= self.path_side then
					self.path_active = self.path_side
					self.object:set_movement_type(move.walk)
					self.object:set_path_type(game_object.patrol_path)
					self.object:set_patrol_path(self.path_active, patrol.start, patrol.continue, true)
					self.state = self.state_moving
				end
			end
		end

		if actor and dist <= 10 and dist >= 2 then
			local pos = actor:position()
			local look_pt = this.vector_copy_by_val(pos):sub(self.object:position())
			self.object:set_sight(look.direction, look_pt, 0)
		else
			self:look_at_waypoint(1) -- поворачиваемся
		end
	end
end

function action_bodyguard_activity:finalize()
	self.last_look_index = nil -- воможно уходим с точки, последнее неправление взгляда уже не актуально
	--printf("_bp: FINALIZE")
	self.object:clear_callback(game_object.movement)
	self.object:clear_animations()

	action_base.finalize(self)
end

----------------------------------------------------------------------------------------------------------------------
--Guard binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, char_ini)
	printf("_bp: add_to_binder (bodyguard)")
	local operators    = {}
	local properties  = {}

	-- FIXME: тут будет bodyguard
	--npc:add_sound([[script_replics\bandit_1\replics\bandit_ambush_]],
	--		20, snd_type.talk, 2, 1, xr_sounds_id.zmey_bodyguard_base)
	npc:add_sound ("Scripts\\trader\\pryach_orujie",           20, snd_type.talk, 2, 1, xr_sounds_id.zmey_bodyguard_base)

	local manager = npc:motivation_action_manager()

	properties["need_bodyguard"]   = xr_evaluators_id.zmey_bodyguard_base + 1
	operators["action_bodyguard"]   = xr_actions_id.zmey_bodyguard_base + 1

	-- // evaluators
	manager:add_evaluator (properties["need_bodyguard"],   this.evaluator_need_bodyguard  (xr_motivator.storage[npc:id()].bodyguard))

	local new_action = this.action_bodyguard_activity(npc, "action_bodyguard_activity", xr_motivator.storage[npc:id()].bodyguard)
	new_action:add_precondition    (world_property(stalker_ids.property_alive,   true))
	new_action:add_precondition    (world_property(stalker_ids.property_enemy,   false))
	new_action:add_precondition    (world_property(properties["need_bodyguard"],   true))
	new_action:add_effect(world_property(properties["need_bodyguard"], false))
	manager:add_action(operators["action_bodyguard"], new_action)

	new_action = manager:action(stalker_ids.action_puzzle_solver)
	new_action:add_precondition(world_property(properties["need_bodyguard"], false))

	if char_ini ~= nil then xr_bodyguard.set_bodyguard(npc) end
end

-- функции
function vector_copy_by_val(vec)
	local newvec = vector()
	newvec.x = vec.x
	newvec.y = vec.y
	newvec.z = vec.z
	return newvec
end

function set_bodyguard(object, enable, path_main, path_side, path_guard, path_guard_radius)
	-- enable - будет ли работать схема в принципе
	-- path_main - где телохранитель обычно стоит
	-- path_side - куда телохранитель отходит
	printf("_bp: set_bodyguard called")
	local char_ini = object:spawn_ini()
	local st = xr_motivator.storage[object:id()].bodyguard
	if enable == nil then
	    	if char_ini:section_exist ("bodyguard") == true then
        		if char_ini:line_exist("bodyguard", "enabled") == true then
                		st.enabled = char_ini:r_bool("bodyguard", "enabled")
			else
				printf("ERROR: set_bodyguard: enabled not specified")
				st.enabled = false
		        end
		else
			st.enabled = false
		end
	else
		st.enabled = enable		
	end	
	if st.enabled == true then
		if path_main == nil then
		    	if char_ini:section_exist ("bodyguard") == true then
	        		if char_ini:line_exist("bodyguard", "path_main") == true then
		        	        st.path_main = char_ini:r_string("bodyguard", "path_main")
	        		else
					printf("ERROR: set_bodyguard: path_main not specified")
		        	    	st.enabled = false
			        end
			else
				st.enabled = false
			end
		else
			st.path_main = path_main
		end
	end
	if st.enabled == true then
		if path_side == nil then
		    	if char_ini:section_exist ("bodyguard") == true then
	        		if char_ini:line_exist("bodyguard", "path_side") == true then
		        	        st.path_side = char_ini:r_string("bodyguard", "path_side")
	        		else
					printf("ERROR: set_bodyguard: path_side not specified")
		        	    	st.path_side = st.path_main
			        end
			else
				st.path_side = st.path_main
			end
		else
			st.path_side = path_side
		end
	end
	if st.enabled == true then
		if path_guard == nil then
		    	if char_ini:section_exist ("bodyguard") == true then
	        		if char_ini:line_exist("bodyguard", "path_guard") == true then
		        	        st.path_guard = char_ini:r_string("bodyguard", "path_guard")
	        		else
					printf("ERROR: set_bodyguard: path_guard not specified")
		        	    	st.path_guard = st.path_main
			        end
			else
				st.enabled = false
			end
		else
			st.path_guard = path_guard
		end
	end
	if st.enabled == true then
		if path_guard_radius == nil then
		    	if char_ini:section_exist ("bodyguard") == true then
	        		if char_ini:line_exist("bodyguard", "path_guard_radius") == true then
		        	        st.path_guard_radius = char_ini:r_u32("bodyguard", "path_guard_radius")
	        		else
					printf("ERROR: set_bodyguard: path_guard_radius not specified")
		        	    	st.path_guard_radius = st.path_main
			        end
			else
				st.enabled = false
			end
		else
			st.path_guard_radius = path_guard_radius
		end
	end
	if st.action ~= nil then
		st.action.reset_scheme(st.action)
	end
	xr_motivator.checkStorage(object)
end

