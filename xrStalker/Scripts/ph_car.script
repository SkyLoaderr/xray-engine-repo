----------------------------------------------------------------------------------------------------
-- Physic door control
----------------------------------------------------------------------------------------------------
-- Исходный скрипт: Evgeniy Negrobov (Jon) jon@gsc-game.kiev.ua
-- Перевод на xr_logic: Andrey Fidrya (Zmey) af@svitonline.com
-- Доработка для БТР: Oleg Kreptul (Haron) haronk@ukr.net
----------------------------------------------------------------------------------------------------

--[[
C++ class CCar : CGameObject,holder {
    const  = 2262;
    const  = 2263;
    const  = 2266;
    const  = 2264;
    const  = 2265;
    const  = 2267;
    
    CCar ();
    
    function _construct();
    function CurrentVel();
    function getVisible() const;
    function net_Spawn(cse_abstract*);
    function setVisible(number);
    function SetParam(number, vector);
    function net_Export(net_packet&);
    function Visual();
    function IsObjectVisible(game_object*);
    function net_Import(net_packet&);
    function HasWeapon();
    function engaged();
    function FireDirDiff();
    function CanHit();
    function getEnabled() const;
    function Action(number, number);
    function setEnabled(number);
    function use(CGameObject*);
};
--]]

local default_min_delta_per_sec = 0.2
local default_min_car_explode_time = 1000
local default_moving_speed = 10
--local default_arriving_factor = 0.4
local default_min_fire_time = 0
local default_update_time = 1.6

local state_none = 0

local state_moving_fwd = 1
local state_moving_rot_left = 2
local state_moving_rot_right = 3
local state_moving_stop = 4
local state_moving_end = 5

local state_cannon_rotate = 1
local state_cannon_delay = 2
local state_cannon_stop = 3

local state_shooting_on = 1

local state_firetarget_points = 1
local state_firetarget_actor = 2
local state_firetarget_enemy = 3

-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class "action_car"

function action_car:__init(obj, storage)
	self.object = obj
	self.st = storage
	self.car = self.object:get_car()
	if self.car:HasWeapon() then
	    self.car:Action(CCar.eWpnActivate,1)
	    self.hasWeapon = true
	else
	    self.hasWeapon = false
	end
end

function action_car:reset_scheme(loading)
--	printf("_bp: action_car:reset_scheme: self.object:name()='%s'", self.object:name())

	self.object:set_nonscript_usable(self.st.nonscript_usable)

	if self.st.invulnerable then
	    self.def_health = self.object.health
	end

	if loading then
		self.speed = xr_logic.pstor_retrieve(self.object, "speed")
		self.loop = xr_logic.pstor_retrieve(self.object, "loop")
		self.min_delta_per_sec = xr_logic.pstor_retrieve(self.object, "min_delta_per_sec")
		self.min_car_explode_time = xr_logic.pstor_retrieve(self.object, "min_car_explode_time")
		self.fire = xr_logic.pstor_retrieve(self.object, "fire")
	else
		self.speed = default_moving_speed
		self.loop = false
		self.min_delta_per_sec = default_min_delta_per_sec
		self.min_car_explode_time = default_min_car_explode_time
		self.fire = false
	end

	xr_logic.mob_capture(self.object, true)
	self.st.signals = {}

	-- path_walk
	if self.st.path_walk then
	    self.path_walk = patrol(self.st.path_walk)
	    if not self.path_walk then
		    utils.abort("object '%s': unable to find path_walk '%s' on the map", self.object:name(), self.st.path_walk)
	    end

	    self.path_walk_count = self.path_walk:count()

	    if not self.path_walk_info then
		    self.path_walk_info = utils.path_parse_waypoints(self.st.path_walk)
	        if not self.path_walk_info then
		        utils.abort("object '%s': path_walk ('%s'): unable to obtain path_walk_info from path",
			        self.object:name(), self.st.path_walk)
	        end
	    end

	    self.last_pos = nil
	    self.last_pos_time = 0

	    self.state_moving = state_none

	    self.arrival_signalled = false

	    if loading then
		    self.target_walk_pt = xr_logic.pstor_retrieve(self.object, "target_walk_pt")
	    else
		    self.target_walk_pt = self:get_nearest_walkpoint()
	    end
	    if self:at_target_walkpoint() then
		    self:walk_arrival_callback(self.target_walk_pt)
	    end
    	
	    self:go_to_walkpoint(self.target_walk_pt)
	else
	    self.state_moving = state_moving_stop
	end
	
	self.state_cannon = state_none
	self.state_shooting = state_none
	
	if self.hasWeapon then
	    if self.st.fire_target == "points" then
	        self.state_firetarget = state_firetarget_points
	    elseif self.st.fire_target == "actor" then
	        self.state_firetarget = state_firetarget_actor
	    --elseif self.st.fire_target == "enemy" then
	    --    self.state_firetarget = state_firetarget_actor
	    end
    	
	    self.path_fire = nil
	    self.path_fire_info = nil
	    self.fire_pt_count = 0
	    -- path_fire
	    if self.state_firetarget == state_firetarget_points and self.st.path_fire then
		    self.path_fire = patrol(self.st.path_fire)
		    if not self.path_fire then
			    utils.abort("object '%s': unable to find path_fire '%s' on the map",
				    self.object:name(), self.st.path_fire)
		    end

	        if not self.path_fire_info then
		        self.path_fire_info = utils.path_parse_waypoints(self.st.path_fire)
	            if not self.path_fire_info then
		            utils.abort("object '%s': path_fire ('%s'): unable to obtain path_fire_info from path",
			            self.object:name(), self.st.path_fire)
	            end
	        end
    	    
	        -- точки прострела для первой точки движения
	        self:change_fire_pts()
        	
	        if self.auto_fire then
	            self.car:Action(CCar.eWpnAutoFire, 1)
	        else
	            self.car:Action(CCar.eWpnAutoFire, 0)
	        end
    	    
	        self:fire_arrival_callback(self.target_fire_pt_idx)
    	    
	        --self:rot_to_firepoint(self.target_fire_pt, self.state_shooting)
	    elseif self.state_firetarget == state_firetarget_actor then
	        self.state_cannon = state_cannon_rotate
	        local p = db.actor:position()
		    self:rot_to_firepoint(p, 0)
	    else
	        self.state_firetarget = state_none
	        self.state_cannon = state_none
	    end
	end
	
	self.object:set_fastcall(self.fastcall, self)
end

function action_car:save()
	xr_logic.pstor_store(self.object, "speed", self.speed)
	xr_logic.pstor_store(self.object, "loop", self.loop)
	xr_logic.pstor_store(self.object, "min_delta_per_sec", self.min_delta_per_sec)
	xr_logic.pstor_store(self.object, "min_car_explode_time", self.min_car_explode_time)
	xr_logic.pstor_store(self.object, "fire", self.fire)
	xr_logic.pstor_store(self.object, "target_walk_pt", self.target_walk_pt)
end

function action_car:change_fire_pts()
	self.state_cannon = state_none
	self.state_shooting = state_none
	
	self.fire_pt_arr = {}
	self.fire_pt_count = 0
	self.target_fire_pt_idx = 0
	self.target_fire_pt = nil
	self.fire_rot_dir = 1
	self.fire_start_time = 0

    if not self.path_fire or not self.target_walk_pt then return end
    
	-- Значение флагов огневых точек, котые будем искать:
	local fire_flags = self.path_walk_info[self.target_walk_pt].flags
	
	if fire_flags:get() == 0 then
		return
	end

    local this_val
	for fire_idx = 0, self.path_fire:count() - 1 do
		this_val = self.path_fire_info[fire_idx].flags
		if this_val:equal(fire_flags) then
			table.insert(self.fire_pt_arr, fire_idx)
			self.fire_pt_count = self.fire_pt_count + 1
		end
	end
	
	if self.fire_pt_count == 0 then
	    self.state_cannon = state_cannon_stop
	end
	
	printf("_bp: action_car:change_fire_pts()")
	print_table(self.fire_pt_arr)

	--if self.fire_pt_count > 0 then
	--    self.target_fire_pt_idx = 0
	--    self.target_fire_pt = self.path_fire:point(self.fire_pt_arr[0])
	--end
end

function action_car:get_nearest_walkpoint()
	return utils.get_nearest_waypoint(self.object, self.st.path_walk,
		 self.path_walk, self.path_walk_count)
end

function action_car:get_next_walkpoint()
	if self.target_walk_pt < self.path_walk_count - 1 then
		return self.target_walk_pt + 1
	elseif self.loop then
		return 0
	end
	return nil
end

function action_car:get_next_firepoint()
    if self.fire_pt_count < 1 then return nil end

    local pt_idx
    if self.target_fire_pt_idx > 0 then -- not first time
        if self.fire_pt_count > 1 then -- we have at least 2 point to switch
            pt_idx = self.target_fire_pt_idx + self.fire_rot_dir
            if (pt_idx < 1 or pt_idx > self.fire_pt_count) then
                self.fire_rot_dir = -self.fire_rot_dir -- change rotate direction [-1,1]
                --printf("changing direction")
                if self.fire_rep > 0 then
                    pt_idx = self.target_fire_pt_idx + self.fire_rot_dir
                    self.fire_rep = self.fire_rep - 1
                else
                    pt_idx = 0
                end
            end
        elseif self.fire_rep > 0 then -- left same point if loop defined
            pt_idx = 1
        end
    else
        pt_idx = 1
    end
    --self.target_fire_pt_idx = pt_idx
    
    --printf("_bp: pt_idx = %d", pt_idx)

	if pt_idx > 0 then
	    return pt_idx, self.path_fire:point(self.fire_pt_arr[pt_idx])
	end

	return pt_idx, nil
end

function action_car:at_target_walkpoint()
    --printf("_bp: action_car:at_target_walkpoint(%s)", utils.to_str(self.target_walk_pt))
    local curVel = self.car:CurrentVel()
	local dist = self.object:position():distance_to(self.path_walk:point(self.target_walk_pt))
	--local arrived = dist < default_update_time * curVel.x --default_update_time > 2 * dist / (curVel.x + self.speed)
	local arrived = 2 * dist < default_update_time * (curVel.x + self.speed) --default_update_time > 2 * dist / (curVel.x + self.speed)
	--local arrived = dist < curVel.x * default_arriving_factor --8
	--printf("_bp: action_car:at_target_walkpoint(self.target_walk_pt=%d) = %d (arrived = %s)",		self.target_walk_pt, dist, utils.to_str(arrived))
    if arrived then
        printf("_bp: arrived = %f < %f, dist(%f), curSpd(%f), spd(%f)",
               default_update_time,
               2 * dist / (curVel.x + self.speed),
               dist, curVel.x, self.speed)
        --printf("_bp: arrived = %f < (%f,%f,%f) * %f, spd(%f)", dist, curVel.x, curVel.y, curVel.z, default_arriving_factor, self.speed)
    end
	return arrived
end

function action_car:set_signal(sig)
	local stor = db.storage[self.object:id()]
	stor[stor.active_scheme].signals[sig] = true
end

function action_car:walk_arrival_callback(index)
	--printf("_bp: action_car:walk_arrival_callback(%d)", index)

	local suggested_explode = self.path_walk_info[index]["explode"]
	if suggested_explode == "true" then
--		printf("action_car:walk_arrival_callback(): EXPLODE")
		self.object:car_explode()
		self.car:Action(CCar.eWpnActivate, 0)
	end

	local suggested_spd = self.path_walk_info[index]["spd"]
	if suggested_spd then
		self.speed = tonumber(suggested_spd)
	else
		self.speed = default_moving_speed
	end

	local suggested_loop = self.path_walk_info[index]["loop"]
	if suggested_loop == "true" then
		self.loop = true
	else
		self.loop = false
	end

	local suggested_dps = self.path_walk_info[index]["dps"]
	if suggested_dps then
		self.min_delta_per_sec = tonumber(suggested_dps)
	else
		self.min_delta_per_sec = default_min_delta_per_sec
	end

	local suggested_exptm = self.path_walk_info[index]["exptm"]
	if suggested_exptm then
		self.min_car_explode_time = tonumber(suggested_exptm)
	else
		self.min_car_explode_time = default_min_car_explode_time
	end

	local sig = self.path_walk_info[index]["sig"]
	if sig then
		self.st.signals[sig] = true
	end

    if self.hasWeapon and self.state_firetarget ~= state_none then
        local next_idx = self:get_next_walkpoint()
        if next_idx then
	        local fw = self.path_walk_info[next_idx]["fw"]
	        if fw then
		        self.fire_wait = if_then_else(fw == "true", true, false)
	        else
	            self.fire_wait = false
	        end

	        local fr = self.path_walk_info[next_idx]["fr"]
	        if fr then
	            local c = tonumber(fr)
		        self.fire_rep = if_then_else(c > 0, c, 0)
	        else
	            self.fire_rep = 0
	        end
	    else
	        self.fire_wait = false
	        self.fire_rep = 0
	    end
        printf("_bp: fire_wait = %s", if_then_else(self.fire_wait, "true", "false"))
        printf("_bp: fire_rep = %d", self.fire_rep)
    end

	-- Выбрать следующую точку езды:
	self.target_walk_pt = self:get_next_walkpoint()
	printf("_bp: target_walk_pt = %s.", utils.to_str(self.target_walk_pt))
	if not self.target_walk_pt then
	    printf("_bp: stop moving.")
	    self:stop_car()
		-- Остановить машину
	    --if self.state_cannon == state_cannon_stop then
		--    xr_logic.mob_capture(self.object, true)
		--end
		--action(self.object, move(move.off, 0), cond(cond.time_end, 1000))
		--self.state_moving = state_moving_end
		return
	end

	-- Если эта точка рядом и уже приехали - не ждать апдейта, чтобы вызвать callback
	if self:at_target_walkpoint() then
		self:walk_arrival_callback(self.target_walk_pt)
	end
	
	self:go_to_walkpoint(self.target_walk_pt)
end

function action_car:fire_arrival_callback(cur_index)
    if self.fire_pt_count < 1 or self.state_cannon == state_cannon_stop then return end
    
    --printf("_bp: action_car:fire_arrival_callback(%s)", utils.to_str(cur_index))
    if self.state_cannon == state_cannon_delay then
        --printf("_bp: 1.delay mode off.")
	    -- Выбрать следующую точку езды:
	    self.target_fire_pt_idx, self.target_fire_pt = self:get_next_firepoint()

	    if self.target_fire_pt then
            --printf("_bp: 1.rotate mode on.")
	        self.state_cannon = state_cannon_rotate
		    if self.fire_rot_dir == 1  and self.fire_forward or
		       self.fire_rot_dir == -1 and self.fire_backward then
		        --printf("_bp: 1.shooting on.")
		        self.state_shooting = state_shooting_on
	        else
		        --printf("_bp: 1.shooting off.")
		        self.state_shooting = state_none
	        end
	        self:rot_to_firepoint(self.target_fire_pt, self.state_shooting)
	    else
            --printf("_bp: 1.cannon stopped.")
	        self.state_cannon = state_cannon_stop
            self:rot_to_firepoint(nil, 0)
            self:set_signal("shooting_end")
	    end
	    return
    end

	--printf("_bp: action_car: fire_arrival_callback(%s)", utils.to_str(cur_index))
    if cur_index > 0 then
        local idx = self.fire_pt_arr[cur_index]

	    local ff = self.path_fire_info[idx]["ff"]
	    if ff then
		    self.fire_forward = if_then_else(ff == "true", true, false)
		else
		    self.fire_forward = false
	    end

	    local fb = self.path_fire_info[idx]["fb"]
	    if fb then
		    self.fire_backward = if_then_else(fb == "true", true, false)
		else
		    self.fire_backward = false
	    end

	    local f = self.path_fire_info[idx]["f"]
	    if f then
		    self.state_shooting = if_then_else(f == "true", state_shooting_on, state_none)
	    else
		    self.state_shooting = if_then_else(self.st.auto_fire, state_shooting_on, state_none)
	    end

	    local ft = self.path_fire_info[idx]["ft"]
	    if ft then
		    self.fire_time = tonumber(ft)
	    else
		    self.fire_time = default_min_fire_time
	    end
	else
		    self.fire_forward = false
		    self.fire_backward = false
		    self.state_shooting = if_then_else(self.st.auto_fire, state_shooting_on, state_none)
		    self.fire_time = default_min_fire_time
	end
    --printf("_bp: state_shooting = %s", if_then_else(self.state_shooting ~= 0, "true", "false"))
    --printf("_bp: auto_fire = %s", if_then_else(self.st.auto_fire, "true", "false"))
    --printf("_bp: fire_time = %f", self.fire_time)

	if self.fire_time > 0 then
        --printf("_bp: 2.delay mode on.")
	    self.state_cannon = state_cannon_delay
        self.fire_start_time = time_global()
        --printf("_bp: state_shooting = %s", if_then_else(self.state_shooting ~= 0, "true", "false"))
        self:rot_to_firepoint(nil, self.state_shooting)
    else
	    -- Выбрать следующую точку езды:
	    self.target_fire_pt_idx, self.target_fire_pt = self:get_next_firepoint()

	    -- Если мы уже целимся в эту точку - не ждать апдейта, чтобы вызвать callback
	    if self.target_fire_pt then
            --printf("_bp: 2.rotate mode on.")
		    self.state_cannon = state_cannon_rotate
		    if self.fire_rot_dir == 1  and self.fire_forward or
		       self.fire_rot_dir == -1 and self.fire_backward then
		        self.state_shooting = state_shooting_on
		        --printf("_bp: 2.shooting on.")
	        else
		        self.state_shooting = state_none
		        --printf("_bp: 2.shooting off.")
	        end
	        self:rot_to_firepoint(self.target_fire_pt, self.state_shooting)
	    else
            --printf("_bp: 2.cannon stopped.")
	        self.state_cannon = state_cannon_stop
            self:rot_to_firepoint(nil, 0)
            self:set_signal("shooting_end")
	    end
	end
end

function action_car:rot_to_firepoint(pt, shooting)
    if pt then
        self.car:SetParam(CCar.eWpnDesiredPos, pt)
    end
    --printf("_bp: action_car:rot_to_firepoint(%d)", shooting)
    self.car:Action(CCar.eWpnFire, shooting)
end

function action_car:go_to_walkpoint()
	--action(self.object, object("left_light", object.activate), cond(cond.time_end, 1000))
	--action(self.object, object("right_light", object.activate), cond(cond.time_end, 1000))
	printf("_bp: action_car:go_to_walkpoint(%s)", utils.to_str(self.target_walk_pt))
	if utils.no_need_to_rotate_xz(self.object, self.path_walk:point(self.target_walk_pt)) then
--		printf("_bp: no_need_to_rotate")
		if self.state_moving ~= state_moving_fwd then
	   		xr_logic.mob_capture(self.object, true)
			action(self.object,
				move(move.on + move.fwd, self.speed),
				object("right_light", object.activate),
				object("left_light", object.activate),
				cond(cond.time_end, time_infinite))
			self.state_moving = state_moving_fwd
		end
	else
		-- Поворачиваться нужно, но в какую сторону?
		local rotate_left = utils.angle_left_xz(self.object:direction(), 
		                                    utils.vector_copy_by_val(self.path_walk:point(self.target_walk_pt)):sub(
		                                                                     self.object:position()))
--		printf("_bp: must rotate: left? %s", utils.to_str(rotate_left))
		if rotate_left then
			if self.state_moving ~= state_moving_rot_left then 
				xr_logic.mob_capture(self.object, true)
				action(self.object,
					move(move.on + move.fwd + move.left, self.speed),
					object("right_light", object.activate),
					object("left_light", object.activate),
					cond(cond.time_end, time_infinite))
				self.state_moving = state_moving_rot_left
			end
		else
			if self.state_moving ~= state_moving_rot_right then
				xr_logic.mob_capture(self.object, true)
				action(self.object,
					move(move.on + move.fwd + move.right, self.speed),
					object("right_light", object.activate),
					object("left_light", object.activate),
					cond(cond.time_end, time_infinite))
				self.state_moving = state_moving_rot_right
			end
		end
	end
end

function action_car:fastcall()
	if db.storage[self.object:id()].active_scheme ~= "ph_car" then
		-- Если активная схема - не машина, снять быстрый апдейт
		return true
	end
	return self:fast_update()
end

function action_car:update(delta)
	if xr_logic.try_switch_to_another_section(self.object, self.st, db.actor) then
		return
	end
	
	if self.st.invulnerable then
	    self.object.health = self.def_health
	end
end

function action_car:stop_car()
    printf("_bp: car stopping.")
	xr_logic.mob_capture(self.object, true)
	action(self.object, move(move.off, 0), cond(cond.time_end, 10)) --cond(cond.move_end))
	self.speed = 0
end

-- Вернуть true, если апдейты больше не нужны
function action_car:fast_update()
--	printf("_bp: action_car:update(): state=%d", self.state_moving)

	--if not self.object:action() then
	--	printf("_bp: CAR EXPLODE")
	--	self.object:explode(0)
	--	self.object:Explode()
	--end
	
	--local pos_ = db.actor:position()
	--self.car:SetParam(CCar.eWpnDesiredPos,pos_)
	--self.car:Action(CCar.eWpnAutoFire,1)

	if self.state_moving == state_moving_end and self.state_cannon == state_cannon_stop then
		if xr_logic.mob_captured(self.object) and not self.object:action() then
			xr_logic.mob_release(self.object)
			return true -- апдейты больше не нужны
		end
		return false
	end

	if (self.state_moving ~= state_moving_end and self.state_moving ~= state_moving_stop or
	   self.state_cannon ~= state_cannon_stop) and 
	   time_global() >= self.last_pos_time + self.min_car_explode_time then
		if not self.last_pos then
			self.last_pos = self.object:position()
			self.last_pos_time = time_global()
		else
			local cur_pos = self.object:position()
			local diff = self.last_pos:distance_to(cur_pos)
			if diff < self.min_delta_per_sec then
                printf("_bp: car got stuck: explode")
                self:stop_car()
				--xr_logic.mob_capture(self.object, true)
				--action(self.object, move(move.off, 0), cond(cond.time_end, 1000))
				--self:car_explode()
				self.state_moving = state_moving_end
				
                printf("_bp: 3.cannon stopped.")
	            self.state_cannon = state_cannon_stop
                self:rot_to_firepoint(nil, 0)
                self:set_signal("shooting_end")
				return false
			end
			self.last_pos = cur_pos
			self.last_pos_time = time_global()
		end
	end
	
	if self.state_moving ~= state_moving_end and self.state_moving ~= state_none then
	    if self.target_walk_pt then
	        if self:at_target_walkpoint() then
	            -- если нет флага ожидания стрельбы или мы уже отстрелялись или пошли в цикле обратно
	            if not self.fire_wait or self.state_cannon == state_cannon_stop then --self.fire_rot_dir == -1 then
	                    printf("_bp: car go to the new point.")
		                -- Прибыли, выбрать новую точку
		                printf("_bp: target_test2 = %s", utils.to_str(self.target_walk_pt))
		                self:walk_arrival_callback(self.target_walk_pt)
		                -- меняем точки отстрела
		                self:change_fire_pts()
	            elseif self.state_moving ~= state_moving_stop then
	                printf("_bp: 1.car stopped.")
	                self:stop_car()
	                --xr_logic.mob_capture(self.object, true)
		            --action(self.object, move(move.off, 0), cond(cond.time_end, 1000)) --cond(cond.move_end))
		            --action(self.object, move(move.off + move.back, 0), cond(cond.time_end, 1000)) --cond(cond.move_end))
		            --action(self.object, move(move.on, 0.0), cond(cond.time_end, 10)) --cond(cond.move_end))
	                self.state_moving = state_moving_stop
	            end
	        else
	            --printf("_bp: car keep going.")
		        -- Продолжать ехать, или поворачиваться
		        self:go_to_walkpoint(self.target_walk_pt)
	        end
	    elseif self.state_cannon == state_cannon_stop then
	        printf("_bp: 2.car stopped.")
	        self:stop_car()
	        --xr_logic.mob_capture(self.object, true)
		    --action(self.object, move(move.off, 0), cond(cond.time_end, 1000))
	        self.state_moving = state_moving_end
	    end
	end
	
	if self.hasWeapon then
	    if self.state_firetarget == state_firetarget_points then
	        if self.fire_pt_count > 0 and self.state_cannon ~= state_cannon_stop then
	            if self.state_cannon == state_cannon_delay then
	                if self.fire_start_time + self.fire_time < time_global() then
	                    --printf("_bp: stop delaying(%.2f + %.2f < %.2f)", self.fire_start_time, self.fire_time, time_global())
		                --printf("_bp: 1.new fire point.")
	                    self:fire_arrival_callback(self.target_fire_pt_idx)
	                else
	                    --printf("_bp: delaying(%.2f + %.2f < %.2f)", self.fire_start_time, self.fire_time, time_global())
	                end
	            else
	                if self.car:CanHit() then
		                --printf("_bp: 2.new fire point.")
		                -- Прибыли, выбрать новую точку
		                self:fire_arrival_callback(self.target_fire_pt_idx)
		            end
	            end
	        end
	    elseif self.state_firetarget == state_firetarget_actor then
	        if self.car:IsObjectVisible(db.actor) then
	            printf("_bp: actor is visible.")
	            if self.car:CanHit() then
	                if self.state_shooting == state_none then
	                    printf("_bp: fighting actor.")
		                self.state_shooting = state_shooting_on
		            end
		        else
	                printf("_bp: searching actor.")
		            self.state_shooting = state_none
		            self:set_signal("shooting_end")
		        end
		        local p = db.actor:position()
		        self:rot_to_firepoint(p, self.state_shooting)
		    else
	            printf("_bp: actor isn't visible.")
		        self.state_shooting = state_none
		        self:rot_to_firepoint(nil, self.state_shooting)
		        self:set_signal("shooting_end")
		    end
	    end
	end
	
	return false
end

function action_car:car_explode()
	self.object:explode(time_global())
end

---------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
--	printf("DEBUG: add_to_binder: scheme='%s', section='%s'", scheme, section)

	local new_action = action_car(npc, storage)

	-- Зарегистрировать все actions, в которых должен быть вызван метод reset_scheme при изменении настроек схемы:
	xr_logic.subscribe_action_for_events(npc, storage, new_action)
end

function set_scheme(npc, ini, scheme, section, gulag_name)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)

	st.logic     = xr_logic.cfg_get_switch_conditions(ini, section, npc)

	st.path_walk = utils.cfg_get_string(ini, section, "path_walk", npc, false, gulag_name)
	st.path_fire = utils.cfg_get_string(ini, section, "path_fire", npc, false, gulag_name, nil)
	st.auto_fire = utils.cfg_get_bool(ini, section, "auto_fire", npc, false, false)
	st.fire_target = utils.cfg_get_string(ini, section, "target", npc, false, gulag_name, "points")
	st.nonscript_usable = utils.cfg_get_bool(ini, section, "nonscript_usable", npc, false)
	st.invulnerable = utils.cfg_get_bool(ini, section, "invulnerable", npc, false, false)

	st.path_walk_info = nil -- Будут инициализированы в reset(), сейчас пути могут быть еще не загружены.
	st.path_fire_info = nil
end

