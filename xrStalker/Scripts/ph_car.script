----------------------------------------------------------------------------------------------------
-- Physic door control
----------------------------------------------------------------------------------------------------
-- Исходный скрипт: Evgeniy Negrobov (Jon) jon@gsc-game.kiev.ua
-- Перевод на xr_logic: Andrey Fidrya (Zmey) af@svitonline.com
-- Доработка для БТР: Oleg Kreptul (Haron) haronk@ukr.net
----------------------------------------------------------------------------------------------------

--[[
C++ class CCar : CGameObject,holder {
    const eWpnActivate = 3;
    const eWpnAutoFire = 5;
    const eWpnFire = 4;
    const eWpnDesiredDir = 1;
    const eWpnDesiredPos = 2;
    const eWpnToDefaultDir = 6;
    
    CCar ();
    
    function _construct();
    function GetfHealth() const;
    function CurrentVel();
    function getVisible() const;
    function net_Spawn(cse_abstract*);
    function setVisible(number);
    function SetParam(number, vector);
    function net_Export(net_packet&);
    function Visual();
    function IsObjectVisible(game_object*);
    function net_Import(net_packet&);
    function HasWeapon();
    function SetfHealth(number);
    function engaged();
    function FireDirDiff();
    function CanHit();
    function getEnabled() const;
    function Action(number, number);
    function setEnabled(number);
    function use(CGameObject*);
};
--]]

local pi_2 = math.pi / 3 -- 60 degree

local def_min_delta_per_sec = 0.2
local def_min_car_explode_time = 1000
local def_moving_speed = 10
--local def_arriving_factor = 0.4
local def_arriving_dist = 1.0
local def_min_fire_time = 0
local def_update_time = 1.6

local def_max_fc_upd_num = 1000 -- default maximum fastcall updates num
local def_arriving_koef = 3 --70

local state_none = 0

local state_moving_fwd = 1
local state_moving_rot_left = 2
local state_moving_rot_right = 3
local state_moving_stop = 4
local state_moving_end = 5

local state_cannon_rotate = 1
local state_cannon_follow = 2
local state_cannon_delay = 3
local state_cannon_stop = 4

local state_shooting_on = 1

local state_firetarget_points = 1
local state_firetarget_actor = 2
local state_firetarget_enemy = 3

-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class "action_car"

function action_car:__init(obj, storage)
    printf("car <state>: init.")
	self.object = obj
	self.st = storage
end

function action_car:reset_scheme(loading)
    printf("car <state>: action_car:reset_scheme: self.object:name()='%s'", self.object:name())

	self.object:set_nonscript_usable(self.st.nonscript_usable)

	if self.st.invulnerable then
	    self.def_health = self.object.health
	end

	self.car = self.object:get_car()
	if self.car:HasWeapon() then
	  printf("car <fire>: car has weapon.")
	  self.car:Action(CCar.eWpnActivate,1)
	  self.hasWeapon = true
	else
	    printf("car <fire>: car hasn't weapon.")
	    self.hasWeapon = false
	end

	if loading then
		self.speed = xr_logic.pstor_retrieve(self.object, "speed")
		self.loop = xr_logic.pstor_retrieve(self.object, "loop")
		self.min_delta_per_sec = xr_logic.pstor_retrieve(self.object, "min_delta_per_sec")
		self.min_car_explode_time = xr_logic.pstor_retrieve(self.object, "min_car_explode_time")
		self.state_moving = xr_logic.pstor_retrieve(self.object, "state_moving")
	else
		self.speed = def_moving_speed
		self.loop = false
		self.min_delta_per_sec = def_min_delta_per_sec
		self.min_car_explode_time = def_min_car_explode_time
		self.state_moving = state_none
	end

	--xr_logic.mob_capture(self.object, true)
	self.st.signals = {}

	self.fc_upd_num = 0 -- fastcall updates num
	self.fc_upd_avg = 150 -- average time of the fastcall updates (in millisecond)
	self.fc_last_upd_tm = -1 -- fastcall last update time

	self.last_pos = nil
	self.last_pos_time = 0

	--self.state_moving = state_none

    self.target_walk_pt = -1
	-- path_walk
	if self.st.path_walk then
	    self.path_walk = patrol(self.st.path_walk)
	    if not self.path_walk then
		    abort("object '%s': unable to find path_walk '%s' on the map", self.object:name(), self.st.path_walk)
	    end

        self:start_car()
	    self.path_walk_count = self.path_walk:count()

	    if not self.path_walk_info then
		    self.path_walk_info = utils.path_parse_waypoints(self.st.path_walk)
	        if not self.path_walk_info then
		        abort("object '%s': path_walk ('%s'): unable to obtain path_walk_info from path",
			        self.object:name(), self.st.path_walk)
	        end
	    end

	    self.arrival_signalled = false
	    self.target_dist = -1

	    if loading then
		    self.target_walk_pt = xr_logic.pstor_retrieve(self.object, "target_walk_pt")
	    else
		    self.target_walk_pt = self:get_nearest_walkpoint()
	    end
	    if self:at_target_walkpoint() then
		    self:walk_arrival_callback(self.target_walk_pt)
	    end
    	
	    self:go_to_walkpoint(self.target_walk_pt)
	else
	    self.state_moving = state_moving_stop
	end
	
	if self.st.headlights == "on" then
	    printf("car <state>: headlights on")
		action(self.object,
			object("right_light", object.activate),
			object("left_light", object.activate),
			cond(cond.time_end, time_infinite))
	else
	    printf("car <state>: headlights off")
		action(self.object,
			object("right_light", object.deactivate),
			object("left_light", object.deactivate),
			cond(cond.time_end, time_infinite))
	end
	
	self.state_firetarget = state_none
	self.state_cannon = state_none
	self.state_shooting = state_none
	
	self.target_fire_pt = nil
	self.target_fire_pt_idx = 0

	if self.hasWeapon then
	    --if loading then
		--    self.state_cannon = xr_logic.pstor_retrieve(self.object, "state_cannon")
		--    self.state_shooting = xr_logic.pstor_retrieve(self.object, "state_shooting")
	    --end

	    --printf("car <fire>: target = %s", self.st.fire_target)
	    if self.st.fire_target == "points" then
	        self.state_firetarget = state_firetarget_points
	    elseif self.st.fire_target == "actor" then
	        self.state_firetarget = state_firetarget_actor
	    --elseif self.st.fire_target == "enemy" then
	    --    self.state_firetarget = state_firetarget_actor
	    end
    	
	    self.path_fire = nil
	    self.path_fire_info = nil
	    self.fire_pt_count = 0
	    
	    -- path_fire
	    if self.state_firetarget == state_firetarget_points and self.st.path_fire then
	        printf("car <state>: firetarget = points")
		    self.path_fire = patrol(self.st.path_fire)
		    if not self.path_fire then
			    abort("object '%s': unable to find path_fire '%s' on the map",
				    self.object:name(), self.st.path_fire)
		    end

	        if not self.path_fire_info then
		        self.path_fire_info = utils.path_parse_waypoints(self.st.path_fire)
	            if not self.path_fire_info then
		            abort("object '%s': path_fire ('%s'): unable to obtain path_fire_info from path",
			            self.object:name(), self.st.path_fire)
	            end
	        end
    	    
	        -- точки прострела для первой точки движения
	        self:change_fire_pts()
        	
	        if self.auto_fire then
	            self.car:Action(CCar.eWpnAutoFire, 1)
	        else
	            self.car:Action(CCar.eWpnAutoFire, 0)
	        end
    	    
	        self:fire_arrival_callback(self.target_fire_pt_idx)
    	    
	        --self:rot_to_firepoint(self.target_fire_pt)
	        --self:set_shooting(self.state_shooting)
	    elseif self.state_firetarget == state_firetarget_actor then
	        printf("car <state>: firetarget = actor")
	        self.state_shooting = state_none
	        self.state_cannon = state_cannon_follow
	        --self.target_fire_pt = db.actor:position()
		    --self:rot_to_firepoint(self.target_fire_pt)
		    --self:set_shooting(self.state_shooting)
	    else
	        printf("car <state>: firetarget = none")
	        self.state_firetarget = state_none
	        self.state_cannon = state_none
	        self.state_shooting = state_none
	    end
	end
	
	self.object:set_fastcall(self.fastcall, self)
end

function action_car:save()
	xr_logic.pstor_store(self.object, "speed", self.speed)
	xr_logic.pstor_store(self.object, "loop", self.loop)
	xr_logic.pstor_store(self.object, "min_delta_per_sec", self.min_delta_per_sec)
	xr_logic.pstor_store(self.object, "min_car_explode_time", self.min_car_explode_time)
	xr_logic.pstor_store(self.object, "state_moving", self.state_moving)
	xr_logic.pstor_store(self.object, "target_walk_pt", self.target_walk_pt) -- or false)
end

--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--
--++++++++++++++++++++-- MOVE SECTION --++++++++++++++++++++--
--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--

function action_car:get_nearest_walkpoint()
	return utils.get_nearest_waypoint(self.object, self.st.path_walk,
		 self.path_walk, self.path_walk_count)
end

function action_car:get_next_walkpoint()
	if self.target_walk_pt < self.path_walk_count - 1 then
		return self.target_walk_pt + 1
	elseif self.loop then
		return 0
	end
	return nil
end

function action_car:at_target_walkpoint()
    --printf("car <move>: action_car:at_target_walkpoint(%s)", utils.to_str(self.target_walk_pt))
    local curVel = self.car:CurrentVel():magnitude()
	local dist = self.object:position():distance_to(self.path_walk:point(self.target_walk_pt))

	--local arrived = 2 * dist < def_update_time * (curVel.x + self.speed) --def_update_time > 2 * dist / (curVel.x + self.speed)
	--local arrived = dist < curVel.x * def_arriving_factor --8

    -- def_arriving_koef * self.fc_upd_avg / 1000 > 2 * dist / (curVel.x + self.speed)
	local arrived = false --2000 * dist < def_arriving_koef * self.fc_upd_avg * (curVel + self.speed)
	
	if self.fc_upd_avg < 100 then
		arrived = 2000 * dist < def_arriving_koef * self.fc_upd_avg * (curVel + self.speed)
	    if arrived then
	        printf("car <move>: at target pt by formula: %f < %f", 2000 * dist, def_arriving_koef * self.fc_upd_avg * (curVel + self.speed))
	    end
	end
	
	if not arrived then
	    local diff_angle = angle_xz(self.object, self.path_walk:point(self.target_walk_pt))
	    arrived = dist < 2 and diff_angle >= pi_2
	    if arrived then
	        printf("car <move>: at target pt by dist(%f) and angle(%f).", dist, diff_angle)
	    end
	end
	
	local diff = dist - self.target_dist
	printf("car <move>: dist = %f, target = %f, diff = %f", dist, self.target_dist, diff)
	if self.target_dist ~= -1 and not arrived then
	    if diff > 0 then
	        if diff > def_arriving_dist then
	            arrived = true
	            printf("car <move>: at target pt by diff(%f).", diff)
	        end
	    else
	        self.target_dist = dist
	    end
	else
        self.target_dist = dist
	end
--[[
	--printf("car <move>: action_car:at_target_walkpoint(self.target_walk_pt=%d) = %d (arrived = %s)",		self.target_walk_pt, dist, utils.to_str(arrived))
    --if arrived then
        printf("car <move>: arrived = %f > %f, dist(%f), diff(%f), curSpd(%f), spd(%f)",
               --def_arriving_koef * self.fc_upd_avg / 1000,
               --2 * dist / (curVel.x + self.speed),
               def_arriving_koef * self.fc_upd_avg * (curVel + self.speed),
               2000 * dist,
               dist, diff, curVel, self.speed)
        --printf("car <move>: arrived = %f < (%f,%f,%f) * %f, spd(%f)", dist, curVel.x, curVel.y, curVel.z, def_arriving_factor, self.speed)
    --end
--]]
    if arrived then
	    self.target_dist = -1
    end
	return arrived
end

function action_car:go_to_walkpoint(pt)
	--action(self.object, object("left_light", object.activate), cond(cond.time_end, 1000))
	--action(self.object, object("right_light", object.activate), cond(cond.time_end, 1000))
	--printf("car <move>: action_car:go_to_walkpoint(%s)", utils.to_str(pt))
	if pt == nil or pt < 0 then
	    self:stop_car()
		self.state_moving = state_moving_stop
		return
	end

    local diff_angle = angle_xz(self.object, self.path_walk:point(pt))
    --printf("car <move>: diff_angle = %f, katet = %f", diff_angle, get_katet(self.object, self.path_walk:point(pt)))
	--if utils.no_need_to_rotate_xz(self.object, self.path_walk:point(pt)) then
	if diff_angle < 0.3 then
		printf("car <move>: no_need_to_rotate. speed = %f, time = %f", self.speed, self.fc_upd_avg)
		if self.state_moving ~= state_moving_fwd then
	   		xr_logic.mob_capture(self.object, true)
			action(self.object,
				move(move.fwd, self.speed), --move.on + 
				--object("right_light", object.deactivate),
				--object("left_light", object.deactivate),
				cond(cond.time_end, time_infinite)) --self.fc_upd_avg))
			self.state_moving = state_moving_fwd
		end
	else
		-- Поворачиваться нужно, но в какую сторону?
		local rotate_left = utils.angle_left_xz(self.object:direction(), 
		                                        utils.vector_copy_by_val(self.path_walk:point(pt)
		                                                                ):sub(self.object:position()))
		printf("car <move>: must rotate: left? %s. speed = %f, time = %f", utils.to_str(rotate_left), self.speed, self.fc_upd_avg)
		if rotate_left then
			if self.state_moving ~= state_moving_rot_left then 
				xr_logic.mob_capture(self.object, true)
				action(self.object,
					move(move.fwd + move.left, self.speed), --move.on + 
					--object("right_light", object.deactivate),
					--object("left_light", object.activate),
					cond(cond.time_end, time_infinite)) --self.fc_upd_avg))
				self.state_moving = state_moving_rot_left
			end
		else
			if self.state_moving ~= state_moving_rot_right then
				xr_logic.mob_capture(self.object, true)
				action(self.object,
					move(move.fwd + move.right, self.speed), --move.on + 
					--object("right_light", object.activate),
					--object("left_light", object.deactivate),
					cond(cond.time_end, time_infinite)) --self.fc_upd_avg))
				self.state_moving = state_moving_rot_right
			end
		end
	end
end

function action_car:start_car()
    printf("car <move>: car started.")
	xr_logic.mob_capture(self.object, true)
	action(self.object, move(move.on + move.fwd, 100), cond(cond.time_end, 5000))
	--self.speed = 0
end

function action_car:stop_car()
    printf("car <move>: car stopping.")
	xr_logic.mob_capture(self.object, true)
	action(self.object, move(move.off + move.handbrake, 0), cond(cond.time_end, 3000)) --cond(cond.move_end))
	self.speed = 0
end

function action_car:walk_arrival_callback(index)
	--printf("car <move>: action_car:walk_arrival_callback(%d)", index)

	local suggested_explode = self.path_walk_info[index]["explode"]
	if suggested_explode == "true" then
--		printf("action_car:walk_arrival_callback(): EXPLODE")
		self.object:car_explode()
		self.car:Action(CCar.eWpnActivate, 0)
	end

	local suggested_spd = self.path_walk_info[index]["spd"]
	if suggested_spd then
		self.speed = tonumber(suggested_spd)
	else
		self.speed = def_moving_speed
	end
	--printf("car <move>: new spd = %f", self.speed)

	local suggested_loop = self.path_walk_info[index]["loop"]
	if suggested_loop == "true" then
		self.loop = true
	else
		self.loop = false
	end

	local suggested_dps = self.path_walk_info[index]["dps"]
	if suggested_dps then
		self.min_delta_per_sec = tonumber(suggested_dps)
	else
		self.min_delta_per_sec = def_min_delta_per_sec
	end

	local suggested_exptm = self.path_walk_info[index]["exptm"]
	if suggested_exptm then
		self.min_car_explode_time = tonumber(suggested_exptm)
	else
		self.min_car_explode_time = def_min_car_explode_time
	end

	local sig = self.path_walk_info[index]["sig"]
	if sig then
		self.st.signals[sig] = true
	end

    if self.hasWeapon and self.state_firetarget == state_firetarget_points then
        local next_idx = self:get_next_walkpoint()
        --local next_idx = self.target_walk_pt
        if next_idx then
	        local fw = self.path_walk_info[next_idx]["fw"]
	        if fw then
		        self.fire_wait = if_then_else(fw == "true", true, false)
	        else
	            self.fire_wait = false
	        end

	        local fr = self.path_walk_info[next_idx]["fr"]
	        if fr then
	            local c = tonumber(fr)
		        self.fire_rep = if_then_else(c > 0, c, 0)
	        else
	            self.fire_rep = 0
	        end
	    else
	        self.fire_wait = false
	        self.fire_rep = 0
	    end
        printf("car <fire>: fire_wait = %s", if_then_else(self.fire_wait, "true", "false"))
        printf("car <fire>: fire_rep = %d", self.fire_rep)
    end

	-- Выбрать следующую точку езды:
	self.target_walk_pt = self:get_next_walkpoint()
	printf("car <move>: target_walk_pt = %s.", utils.to_str(self.target_walk_pt))
	if not self.target_walk_pt then
	    printf("car <move>: stop moving.")
	    self:stop_car()
		-- Остановить машину
	    --if self.state_cannon == state_cannon_stop then
		--    xr_logic.mob_capture(self.object, true)
		--end
		--action(self.object, move(move.off, 0), cond(cond.time_end, 1000))
		--self.state_moving = state_moving_end
		return
	end

	-- Если эта точка рядом и уже приехали - не ждать апдейта, чтобы вызвать callback
	if self:at_target_walkpoint() then
		self:walk_arrival_callback(self.target_walk_pt)
    else
        --self.target_dist = -1
	    self:go_to_walkpoint(self.target_walk_pt)
	end
end

--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--
--++++++++++++++++++++-- FIRE SECTION --++++++++++++++++++++--
--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--

function action_car:change_fire_pts()
	self.state_cannon = state_none
	self.state_shooting = state_none
	
	self.fire_pt_arr = {}
	self.fire_pt_count = 0
	self.target_fire_pt_idx = 0
	self.target_fire_pt = nil
	self.fire_rot_dir = 1
	self.fire_start_time = 0

    if not self.path_fire or not self.target_walk_pt then return end
    
	-- Значение флагов огневых точек, котые будем искать:
	local fire_flags = self.path_walk_info[self.target_walk_pt].flags
	
	if fire_flags:get() == 0 then
		return
	end

    local this_val
	for fire_idx = 0, self.path_fire:count() - 1 do
		this_val = self.path_fire_info[fire_idx].flags
		if this_val:equal(fire_flags) then
			table.insert(self.fire_pt_arr, fire_idx)
			self.fire_pt_count = self.fire_pt_count + 1
		end
	end
	
	if self.fire_pt_count == 0 then
	    self.state_cannon = state_cannon_stop
	    return
	end
	
	printf("car <fire>: action_car:change_fire_pts()")
	print_table(self.fire_pt_arr)

	--if self.fire_pt_count > 0 then
	--    self.target_fire_pt_idx = 0
	--    self.target_fire_pt = self.path_fire:point(self.fire_pt_arr[0])
	--end
end

function action_car:get_next_firepoint()
    if self.fire_pt_count < 1 then return nil end

    printf("car <fire>: action_car:get_next_firepoint()")
    local pt_idx
    if self.target_fire_pt_idx > 0 then -- not first time
        if self.fire_pt_count > 1 then -- we have at least 2 point to switch
            pt_idx = self.target_fire_pt_idx + self.fire_rot_dir
            if (pt_idx < 1 or pt_idx > self.fire_pt_count) then
                self.fire_rot_dir = -self.fire_rot_dir -- change rotate direction [-1,1]
                --printf("car <fire>: changing direction")
                if self.fire_rep > 0 then
                    pt_idx = self.target_fire_pt_idx + self.fire_rot_dir
                    self.fire_rep = self.fire_rep - 1
                else
                    pt_idx = 0
                end
            end
        elseif self.fire_rep > 0 then -- left same point if loop defined
            pt_idx = 1
        end
    else
        pt_idx = 1
    end
    --self.target_fire_pt_idx = pt_idx
    
    printf("car <fire>: pt_idx = %d", pt_idx)

	if pt_idx > 0 then
	    return pt_idx, self.path_fire:point(self.fire_pt_arr[pt_idx])
	end

	return pt_idx, nil
end

function action_car:rot_to_firepoint(pt)
--[[
    if pt then
        self.car:SetParam(CCar.eWpnDesiredPos, pt)
    end
    printf("car <fire>: action_car:rot_to_firepoint(%d)", shooting)
    self.car:Action(CCar.eWpnFire, shooting)
--]]
    if self.target_fire_pt then
    --    self.state_cannon = state_cannon_rotate
        self.car:SetParam(CCar.eWpnDesiredPos, self.target_fire_pt)
        printf("car <fire>: action_car:rot_to_firepoint(%d)", self.target_fire_pt_idx)
    --else
    --    self.state_cannon = state_cannon_stop
    end
end

function action_car:set_shooting(shooting)
    self.car:Action(CCar.eWpnFire, self.state_shooting)
    printf("car <fire>: action_car:set_shooting(%d)", self.state_shooting)
end

function action_car:fire_arrival_callback(cur_index)
    if self.fire_pt_count < 1 or self.state_cannon == state_cannon_stop then return end
    
    printf("car <fire>: action_car:fire_arrival_callback(%s)", utils.to_str(cur_index))
    if self.state_cannon == state_cannon_delay then
        printf("car <fire>: 1.delay mode off.")
	    -- Выбрать следующую точку езды:
	    self.target_fire_pt_idx, self.target_fire_pt = self:get_next_firepoint()

	    if self.target_fire_pt then
            printf("car <fire>: 1.rotate mode on.")
	        self.state_cannon = state_cannon_rotate
		    if self.fire_rot_dir == 1  and self.fire_forward or
		       self.fire_rot_dir == -1 and self.fire_backward then
		        printf("car <fire>: 1.shooting on.")
		        self.state_shooting = state_shooting_on
	        else
		        printf("car <fire>: 1.shooting off.")
		        self.state_shooting = state_none
	        end
	        self:rot_to_firepoint(self.target_fire_pt)
	        self:set_shooting(self.state_shooting)
	    else
            printf("car <fire>: 1.cannon stopped.")
	        self.state_cannon = state_cannon_stop
	        self.state_shooting = state_none
            --self:rot_to_firepoint(nil)
            self:set_shooting(self.state_shooting)
            self:set_signal("fire_end")
	    end
	    return
    end

	--printf("car <fire>: action_car: fire_arrival_callback(%s)", utils.to_str(cur_index))
    if cur_index > 0 then
        local idx = self.fire_pt_arr[cur_index]

	    local ff = self.path_fire_info[idx]["ff"]
	    if ff then
		    self.fire_forward = if_then_else(ff == "true", true, false)
		else
		    self.fire_forward = false
	    end

	    local fb = self.path_fire_info[idx]["fb"]
	    if fb then
		    self.fire_backward = if_then_else(fb == "true", true, false)
		else
		    self.fire_backward = false
	    end

	    local f = self.path_fire_info[idx]["f"]
	    if f then
		    self.state_shooting = if_then_else(f == "true", state_shooting_on, state_none)
	    else
		    self.state_shooting = if_then_else(self.st.auto_fire, state_shooting_on, state_none)
	    end

	    local ft = self.path_fire_info[idx]["ft"]
	    if ft then
		    self.fire_time = tonumber(ft)
	    else
		    self.fire_time = def_min_fire_time
	    end
	else
		    self.fire_forward = false
		    self.fire_backward = false
		    self.state_shooting = if_then_else(self.st.auto_fire, state_shooting_on, state_none)
		    self.fire_time = def_min_fire_time
	end
    printf("car <fire>: state_shooting = %s", if_then_else(self.state_shooting ~= 0, "true", "false"))
    --printf("car <fire>: auto_fire = %s", if_then_else(self.st.auto_fire, "true", "false"))
    printf("car <fire>: fire_time = %f", self.fire_time)

	if self.fire_time > 0 then
        printf("car <fire>: 2.delay mode on.")
	    self.state_cannon = state_cannon_delay
        self.fire_start_time = time_global()
        --printf("car <fire>: state_shooting = %s", if_then_else(self.state_shooting ~= 0, "true", "false"))
        --self:rot_to_firepoint(nil)
        self:set_shooting(self.state_shooting)
    else
	    -- Выбрать следующую точку стрельбы:
	    self.target_fire_pt_idx, self.target_fire_pt = self:get_next_firepoint()

	    -- Если мы уже целимся в эту точку - не ждать апдейта, чтобы вызвать callback
	    if self.target_fire_pt then
            printf("car <fire>: 2.rotate mode on.")
		    self.state_cannon = state_cannon_rotate
		    if self.fire_rot_dir == 1  and self.fire_forward or
		       self.fire_rot_dir == -1 and self.fire_backward then
		        self.state_shooting = state_shooting_on
		        printf("car <fire>: 2.shooting on.")
	        else
		        self.state_shooting = state_none
		        printf("car <fire>: 2.shooting off.")
	        end
	        self:rot_to_firepoint(self.target_fire_pt)
	        self:set_shooting(self.state_shooting)
	    else
            printf("car <fire>: 2.cannon stopped.")
	        self.state_cannon = state_cannon_stop
	        self.state_shooting =state_none
            --self:rot_to_firepoint(nil)
            self:set_shooting(self.state_shooting)
            self:set_signal("fire_end")
	    end
	end
end

--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--
--+++++++++++++++++++-- COMMON SECTION --+++++++++++++++++++--
--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--
function action_car:set_signal(sig)
	local stor = db.storage[self.object:id()]
	stor[stor.active_scheme].signals[sig] = true
end

function angle_xz(npc, target_pos)
	local dir1 = npc:direction()
	dir1.y = 0
	local dir2 = utils.vector_copy_by_val(target_pos):sub(npc:position())
	dir2.y = 0
	return yaw(dir1, dir2)
end

function get_katet(npc, target_pos)
	local p = utils.vector_copy_by_val(target_pos):sub(npc:position())
	local q = npc:direction()
	local k = p.x * q.x + p.y * q.y
	if k ~= 0 then
	    return target_pos:distance_to(npc:position()) * (p.x * q.y - p.y * q.x) / k
	end
	return -1
end

function action_car:fastcall()
	if db.storage[self.object:id()].active_scheme ~= "ph_car" then
		-- Если активная схема - не машина, снять быстрый апдейт
		return true
	end
	return self:fast_update()
end

function action_car:update(delta)
	if xr_logic.try_switch_to_another_section(self.object, self.st, db.actor) then
		return
	end
	
	if self.st.invulnerable then
	    self.object.health = self.def_health
	end
end

-- Вернуть true, если апдейты больше не нужны
function action_car:fast_update()
    --printf("car <state>: action_car:update(): state=%d", self.state_moving)

	--if not self.object:action() then
	--	printf("_pc: CAR EXPLODE")
	--	self.object:explode(0)
	--	self.object:Explode()
	--end
	
	if self.car:GetfHealth() <= 0 then
	    printf("car <state>: killed.")
	    self.state_moving = state_moving_end
	    self:stop_car()
	    self.state_cannon = state_none
	    self.state_firetarget = state_none
	    self.state_shooting = state_none
	    self:set_shooting(self.state_shooting)
	    xr_logic.mob_release(self.object)
	    return true
	end
	
	local time = time_global()

	if self.fc_upd_num < def_max_fc_upd_num then
	    local last_upd = self.fc_last_upd_tm
	    if last_upd ~= -1 then
	        local n = self.fc_upd_num
	        self.fc_upd_avg = (self.fc_upd_avg * n + (time - last_upd))/(n + 1)
	        self.fc_upd_num = n + 1
	    end
	    self.fc_last_upd_tm = time
	    --printf("car <state>: average update = %f, time(%f)", self.fc_upd_avg, time)
	end

	if self.state_moving == state_moving_end and self.state_cannon == state_cannon_stop then
		if xr_logic.mob_captured(self.object) and not self.object:action() then
		    --printf("car <state>: stop fast updating. moving(%s) cannon(%s)", utils.to_str(self.state_moving), utils.to_str(self.state_cannon))
			xr_logic.mob_release(self.object)
			return true -- апдейты больше не нужны
		end
		return false
	end

	if self.state_moving ~= state_moving_end and self.state_moving ~= state_moving_stop and 
	   time >= self.last_pos_time + self.min_car_explode_time then
	    printf("car <state>: moving(%s)", utils.to_str(self.state_moving))
		if not self.last_pos then
			self.last_pos = self.object:position()
			self.last_pos_time = time_global()
		else
			local cur_pos = self.object:position()
			local diff = self.last_pos:distance_to(cur_pos)
			if diff < self.min_delta_per_sec then
                printf("car <move>: got stuck (%f < %f) - stop.", diff, self.min_delta_per_sec)
                self:stop_car()
				--self:car_explode()
				self.state_moving = state_moving_end
				--return false
			else
			    self.last_pos = cur_pos
			end
			self.last_pos_time = time_global()
		end
	end
	
	if self.state_moving ~= state_moving_end and self.state_moving ~= state_none then
	    if self.target_walk_pt then
	        if self:at_target_walkpoint() then
	            -- если нет флага ожидания стрельбы или мы уже отстрелялись или пошли в цикле обратно
	            if not self.fire_wait or self.state_cannon == state_cannon_stop then --self.fire_rot_dir == -1 then
	                    --printf("car <move>: car go to the new point.")
		                -- Прибыли, выбрать новую точку
		                printf("car <move>: new target = %s", utils.to_str(self.target_walk_pt))
		                self:walk_arrival_callback(self.target_walk_pt)
		                -- меняем точки отстрела
		                self:change_fire_pts()
	            elseif self.state_moving ~= state_moving_stop then
	                printf("car <move>: 1.car stopped.")
	                self:stop_car()
	                --xr_logic.mob_capture(self.object, true)
		            --action(self.object, move(move.off, 0), cond(cond.time_end, 1000)) --cond(cond.move_end))
		            --action(self.object, move(move.off + move.back, 0), cond(cond.time_end, 1000)) --cond(cond.move_end))
		            --action(self.object, move(move.on, 0.0), cond(cond.time_end, 10)) --cond(cond.move_end))
	                self.state_moving = state_moving_stop
	            end
	        else
	            --printf("_pc: car keep going.")
		        -- Продолжать ехать, или поворачиваться
		        self:go_to_walkpoint(self.target_walk_pt)
	        end
	    elseif self.state_cannon == state_cannon_stop then
	        printf("car <move>: 2.car stopped.")
	        self:stop_car()
            self.state_moving = state_moving_end
	    end
	end
	
	--printf("car <fire>: TEST")
	if self.hasWeapon then
	    --printf("car <fire>: target(%d)", self.state_firetarget)
	    if self.state_firetarget == state_firetarget_points then
	        if self.fire_pt_count > 0 and self.state_cannon ~= state_cannon_stop then
	            printf("car <fire>: shooting points")
	            if self.state_cannon == state_cannon_delay then
	                if self.fire_start_time + self.fire_time < time_global() then
	                    --printf("car <fire>: stop delaying(%.2f + %.2f < %.2f)", self.fire_start_time, self.fire_time, time_global())
		                --printf("car <fire>: 1.new fire point.")
	                    self:fire_arrival_callback(self.target_fire_pt_idx)
	                else
	                    printf("car <fire>: delaying(%.2f + %.2f < %.2f)", self.fire_start_time, self.fire_time, time_global())
	                end
	            else
	                if self.car:CanHit() or self.target_fire_pt_idx == 0 then
		                printf("car <fire>: 2.new fire point.")
		                -- Прибыли, выбрать новую точку
		                self:fire_arrival_callback(self.target_fire_pt_idx)
		            end
	            end
	        end
	    elseif self.state_firetarget == state_firetarget_actor then
	        if self.car:IsObjectVisible(db.actor) then
	            printf("car <fire>: actor is visible.")

		        self.target_fire_pt = db.actor:position()
		        self:rot_to_firepoint(self.target_fire_pt)

	            if self.car:CanHit() then
	                printf("car <fire>: fighting actor.")
	                if self.state_shooting == state_none then
		                self.state_shooting = state_shooting_on
		                self:set_shooting(self.state_shooting)

		                self:set_signal("fire_start")
		            end
		        else
	                printf("car <fire>: searching actor.")

		            self.state_shooting = state_none
		            self:set_shooting(self.state_shooting)

		            self:set_signal("fire_end")
		        end
		    else
	            printf("car <fire>: actor isn't visible.")
		        self.state_shooting = state_none
		        --self:rot_to_firepoint(nil)
		        self:set_shooting(self.state_shooting)
		        self:set_signal("fire_end")
		    end
	    end
	end
	
	return false
end

function action_car:car_explode()
	self.object:explode(time_global())
end

---------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
--	printf("DEBUG: add_to_binder: scheme='%s', section='%s'", scheme, section)

	local new_action = action_car(npc, storage)

	-- Зарегистрировать все actions, в которых должен быть вызван метод reset_scheme при изменении настроек схемы:
	xr_logic.subscribe_action_for_events(npc, storage, new_action)
end

function set_scheme(npc, ini, scheme, section, gulag_name)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)

	st.logic     = xr_logic.cfg_get_switch_conditions(ini, section, npc)

	st.path_walk = utils.cfg_get_string(ini, section, "path_walk", npc, false, gulag_name)
	st.path_fire = utils.cfg_get_string(ini, section, "path_fire", npc, false, gulag_name, nil)
	st.auto_fire = utils.cfg_get_bool(ini, section, "auto_fire", npc, false, false)
	st.fire_target = utils.cfg_get_string(ini, section, "target", npc, false, gulag_name, "points")
	st.nonscript_usable = utils.cfg_get_bool(ini, section, "nonscript_usable", npc, false)
	st.invulnerable = utils.cfg_get_bool(ini, section, "invulnerable", npc, false, false)
	st.headlights = utils.cfg_get_string(ini, section, "headlights", npc, false, gulag_name, "off")

	st.path_walk_info = nil -- Будут инициализированы в reset(), сейчас пути могут быть еще не загружены.
	st.path_fire_info = nil
end

