
--------------------------------------------------------------------------
-- Member counts
--------------------------------------------------------------------------
local mob_spring_count = 20

--------------------------------------------------------------------------
-- States
--------------------------------------------------------------------------
local state_normal = 0
local state_alarm = 1
local state_alarm_actor_inside = 2
local state_fight = 1

--------------------------------------------------------------------------
-- General
--------------------------------------------------------------------------
local t = {}
local gulags = {}

-- Job -------------------------------------------------------------------
function load_job(sj, gname, type, squad, groups)
    local g = gulags[type]
    if g then
        g[1](sj, gname, type, squad, groups)
    end
end

-- State -----------------------------------------------------------------
function load_states(gname, type)
    local g = gulags[type]

    if g then
        return g[2]
    end

	return nil
end
	    
-- Dynamic ltx -----------------------------------------------------------
function load_ltx(gname, type)
    local g = gulags[type]
    if g and g[4] then
        return g[4](gname, type)
    end

	return nil
end

-- Check communities -----------------------------------------------------
local function checkCommon(npc_community, gulag_type, npc_rank, se_obj, stalker)
    local g = gulags[gulag_type]
    if g then
        local i, v, n = 0, 0, 0

        if g[3] then
            for i, v in pairs(g[3]) do
                if type(v) == "function" and v(npc_community, gulag_type, npc_rank, se_obj, stalker) then
                    return true
                elseif npc_community == v then
                    return true
                end
                n = n + 1
            end
            if n > 0 then
                return false
            else
                return true
            end
        else
            return true
        end
    end
	return false
end

function checkStalker(npc_community, gulag_type, npc_rank, se_obj)
	return checkCommon(npc_community, gulag_type, npc_rank, se_obj, true)
end

function checkMonster(npc_community, gulag_type, npc_rank, se_obj)
	return checkCommon(npc_community, gulag_type, npc_rank, se_obj, false)
end


--------------------------------------------------------------------------
-- Gulags
--------------------------------------------------------------------------

--------------------------------------------------------------------------
-- Escort
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function e_predicate_n(data) -- nap1
	return data.story_id == 406
end

function e_predicate_c(data) -- captive
	return data.story_id == 400
end

function e_predicate_w(data) -- wounded bandit
	return data.story_id == 424
end

function e_predicate_g(data) -- guards
	return data.profile_name == "val_bandit_general"
end

-- Jobs ------------------------------------------------------------------
function load_job_escort(sj, gname, type, squad, groups)
	t = { section = "logic@" .. gname .. "_nap1",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		predicate = e_predicate_n
	}
	table.insert(sj, t)

	t = { section = "logic@" .. gname .. "_captive",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		predicate = e_predicate_c
	}
	table.insert(sj, t)

	t = { section = "logic@" .. gname .. "_guard1",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		predicate = e_predicate_g
	}
	table.insert(sj, t)

	t = { section = "logic@" .. gname .. "_guard2",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		predicate = e_predicate_g
	}
	table.insert(sj, t)

	t = { section = "logic@" .. gname .. "_wounded_bandit",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		predicate = e_predicate_w
	}
	table.insert(sj, t)
end

-- States ----------------------------------------------------------------
function check_state_escort(gulag)
	return 0
end

-- Dynamic ltx -----------------------------------------------------------
function load_ltx_escort(gname, type)
    local ltx = ""

    ltx = ltx.."#include \"scripts\\val_escort_nap1.ltx\"\n"
    ltx = ltx.."#include \"scripts\\val_escort_captive.ltx\"\n"
    ltx = ltx.."#include \"scripts\\val_escort_guard1.ltx\"\n"
    ltx = ltx.."#include \"scripts\\val_escort_guard2.ltx\"\n"
    
    ltx = ltx.."[logic@" .. gname .. "_wounded_bandit]\n" ..
               "active          = remark@" .. gname .. "_wounded_bandit\n" ..

               "[remark@" .. gname .. "_wounded_bandit]\n" ..
               "path_walk       = nap1_look\n" ..
               "no_move         = true\n" ..
               "no_rotate       = true\n" ..
               "anim            = wait\n" ..
               "wounded         = wounded@" .. gname .. "_wounded_bandit\n" ..

               "[wounded@" .. gname .. "_wounded_bandit]\n" ..
               "hp_state        = 10|wounded_heavy\n" ..
               "hp_state_see    = 10|wounded_heavy\n" ..
               "psy_state       = 30|psy_pain\n" ..
               "hp_victim       = 30|actor|10|nil\n" ..
               "hp_cover        = 30|true|10|false\n" ..
               "hp_fight        = 30|true|10|false\n" ..
               "syndata         = wounded@help\n"

    return ltx
end


--------------------------------------------------------------------------
-- Sacrifice
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function scf_predicate_v(data) -- victim
	return data.story_id == 401
end

function scf_predicate_g1(data) -- guard1
	return data.story_id == 404
end

function scf_predicate_g2(data) -- guard2
	return data.story_id == 405
end

function scf_predicate_tb(data) -- tunnel bandit
	return data.story_id == 409
end

-- Jobs ------------------------------------------------------------------
function load_job_sacrifice(sj, gname, type, squad, groups)
	t = { section = "logic@" .. gname .. "_victim",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		predicate = scf_predicate_v
	}
	table.insert(sj, t)

	t = { section = "logic@" .. gname .. "_guard1",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		predicate = scf_predicate_g1
	}
	table.insert(sj, t)

	t = { section = "logic@" .. gname .. "_guard2",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		predicate = scf_predicate_g2
	}
	table.insert(sj, t)

	t = { section = "logic@" .. gname .. "_tunnel_bandit",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		predicate = scf_predicate_tb
	}
	table.insert(sj, t)
end

-- States ----------------------------------------------------------------
function check_state_sacrifice(gulag)
	return 0
end

-- Dynamic ltx -----------------------------------------------------------
function load_ltx_sacrifice(gname, type)
    local ltx = ""
    
    ltx = ltx.."[combat@" .. gname .. "]\n" ..
               "on_info = {=see_actor} %+val_sacrifice_plr_detected +val_sacrifice_finish%\n" ..

               ";[hit@" .. gname .. "_guard]\n" ..
               ";on_info = {=hit_by_actor} %+val_sacrifice_plr_detected +val_sacrifice_finish%\n" ..

               "[danger@" .. gname .. "_guard]\n" ..
               "ignore_danger_sound = 1\n"

    ltx = ltx.."#include \"scripts\\val_sacrifice_victim.ltx\"\n" ..
               "#include \"scripts\\val_sacrifice_guard1.ltx\"\n" ..
               "#include \"scripts\\val_sacrifice_guard2.ltx\"\n" ..
               "#include \"scripts\\val_tunnel_bandit.ltx\"\n"
    return ltx
end


--------------------------------------------------------------------------
-- Prisoner
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function p_predicate(data) -- prisoner
	return data.story_id == 402
end

-- Jobs ------------------------------------------------------------------
function load_job_prisoner(sj, gname, type, squad, groups)
	t = { section = "logic@" .. gname,
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		predicate = p_predicate
	}
	table.insert(sj, t)
end

-- States ----------------------------------------------------------------
function check_state_prisoner(gulag)
	return 0
end

-- Dynamic ltx -----------------------------------------------------------
function load_ltx_prisoner(gname, type)
    return "#include \"scripts\\val_prisoner_captive.ltx\"\n"
end


--------------------------------------------------------------------------
-- Robbers
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------

-- Jobs ------------------------------------------------------------------
function load_job_robbers(sj, gname, type, squad, groups)
    local i = 0

	t = { section = "logic@" .. gname .. "_leader",
		idle = 0,
		prior = 3, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = ""
	}
	table.insert(sj, t)

    for i = 1, 2 do
	    t = { section = "logic@" .. gname .. "_guard" .. i,
		    idle = 0,
		    prior = 2, state = {0},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = ""
	    }
	    table.insert(sj, t)
	end

    for i = 1, 4 do
	    t = { section = "logic@" .. gname .. "_kamp",
		    idle = 0,
		    prior = 1, state = {0},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = ""
	    }
	    table.insert(sj, t)
	end
end

-- States ----------------------------------------------------------------
function check_state_robbers(gulag)
	return 0
end

-- Check stalker ---------------------------------------------------------
function check_stalker_rob(npc_community, gulag_type, npc_rank, se_obj, stalker)
    return stalker
end

-- Dynamic ltx -----------------------------------------------------------
function load_ltx_robbers(gname, type)
    local i, ltx = 0, ""
    
    ltx = ltx.."#include \"scripts\\val_rob_leader.ltx\"\n"

    ltx = ltx.."[meet@" .. gname .. "_guard]\n" ..
               "meet_state 	   = 30| {+val_rob_buying} threat, wait@ {+val_rob_buying} val_rob_guard_jeer, weather\n" ..
               "meet_state_wpn = 30| threat@threat_back\n" ..
               ";victim        = 30| actor\n" ..
               ";victim_wpn    = 30| actor\n" ..
               ";use           = true\n" ..
               "use_wpn	       = true\n" ..
               "zone           = val_rob_warn_zone| threat@ {+val_rob_buying} val_rob_guard_jeer, threat_back | val_rob_kill_zone| true@talk_abuse\n"

    for i = 1, 2 do
        ltx = ltx.."[logic@" .. gname .. "_guard" .. i .. "]\n" ..
                   "active = walker@" .. gname .. "_guard" .. i .. "\n" ..

                   "[walker@" .. gname .. "_guard" .. i .. "]\n" ..
                   "path_walk = guard" .. i .. "_walk\n" ..
                   "path_look = guard" .. i .. "_look\n" ..
                   "meet      = meet@" .. gname .. "_guard\n"
    end
    
    ltx = ltx.."[logic@" .. gname .. "_kamp]\n" ..
               "active = kamp@" .. gname .. "\n" ..

               "[kamp@" .. gname .. "]\n" ..
               "center_point = kamp\n"
    return ltx
end


--------------------------------------------------------------------------
-- Bandits
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function lb_predicate1(data) 
	return data.profile_name == "val_bandit_borov"
end

function lb_predicate2(data) 
	return data.profile_name == "val_bandit_veteran"
end

function lb_predicate3(data) 
	return data.profile_name == "val_bandit_general"
end

-- Jobs ------------------------------------------------------------------
function load_job_lager_bandits(sj, gname, type, squad, groups)
    local i, v, j = 0, 0, 0
    local restr, gr, prior, rst = 0, 0, 0, 0

	-- ÁÎÐÎÂ
	t = { section = "logic@" .. gname .. "_leader_normal",
		idle = 0,
		prior = 9, state = {state_normal},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = gname .. "_borov_restrictor",
		predicate = lb_predicate1
	}
	table.insert(sj, t)

	t = { section = "logic@" .. gname .. "_leader_alarm",
		idle = 0,
		prior = 9, state = {state_alarm},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = gname .. "_borov_restrictor",
		predicate = lb_predicate1
	}
	table.insert(sj, t)

	t = { section = "logic@" .. gname .. "_leader_alarm",
		idle = 0,
		prior = 9, state = {state_alarm_actor_inside},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = gname .. "_borov_restrictor",
		predicate = lb_predicate1
	}
	table.insert(sj, t)

	-- ÎÕÐÀÍÍÈÊÈ ÁÎÐÎÂÀ
    for i = 1, 3 do
	    t = { section = "logic@" .. gname .. "_bodyguard_normal" .. i,
		    idle = 0,
		    prior = 8, state = {state_normal},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_main_building_restrictor",
		    predicate = lb_predicate2
	    }
	    table.insert(sj, t)

	    t = { section = "logic@" .. gname .. "_bodyguard_alarm" .. i,
		    idle = 0,
		    prior = 8, state = {state_alarm},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_main_building_restrictor",
		    predicate = lb_predicate2
	    }
	    table.insert(sj, t)

	    t = { section = "logic@" .. gname .. "_bodyguard_alarm" .. i,
		    idle = 0,
		    prior = 8, state = {state_alarm_actor_inside},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_main_building_restrictor",
		    predicate = lb_predicate2
	    }
	    table.insert(sj, t)
    end

	-- ÑÈÄßÙÈÅ Â ÊÅÌÏÅ 1 ÂÎÇËÅ ÁÎÐÎÂÀ È Â ÊÅÌÏÅ 2 ÍÀ ÂÒÎÐÎÌ ÝÒÀÆÅ
	restr = {gname .. "_main_building_restrictor", gname .. "_nedostroyka_restrictor", gname .. "_nedostroyka_restrictor"}
	local pr = {7, 7, 2}
	for i, v in pairs({3, 4, 2}) do
	    for j = 1, v do
	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_normal",
		        idle = 0,
		        prior = pr[i], state = {state_normal},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = restr[i],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)

	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_alarm" .. j,
		        idle = 0,
		        prior = pr[i], state = {state_alarm},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = restr[i],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)

	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_alarm" .. j,
		        idle = 0,
		        prior = pr[i], state = {state_alarm_actor_inside},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = restr[i],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)
	    end
	end

	-- ÁÀÍÄÈÒÛ ÍÀ ÂÎÐÎÒÀÕ
	restr =  {{gname .. "_main_side_restrictor", gname .. "_restrictor"},
	          {gname .. "_main_side_restrictor", gname .. "_restrictor", gname .. "_restrictor", gname .. "_restrictor"},
	          {gname .. "_restrictor", gname .. "_restrictor"},
	          {gname .. "_restrictor", gname .. "_restrictor", gname .. "_restrictor", gname .. "_restrictor"}}
	gr = {"guard", "patrol", "sniper", "sleeper"}
	prior =  {6, 5, 4, 3}
	for i, v in pairs({2, 4, 2, 4}) do
	    rst = restr[i]
	    for j = 1, v do
	        t = { section = "logic@" .. gname .. "_" .. gr[i] .. "_normal" .. j,
		        idle = 0,
		        prior = prior[i], state = {state_normal},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = rst[j],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)

	        t = { section = "logic@" .. gname .. "_" .. gr[i] .. "_alarm" .. j,
		        idle = 0,
		        prior = prior[i], state = {state_alarm},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = rst[j],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)

	        t = { section = "logic@" .. gname .. "_" .. gr[i] .. "_alarm" .. j,
		        idle = 0,
		        prior = prior[i], state = {state_alarm_actor_inside},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = rst[j],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)
	    end
	end
end

-- States ----------------------------------------------------------------
function check_state_lager_bandits(gulag)
	for k,v in pairs(gulag.Object) do
	    if v ~= true then
		    local enemy = v:best_enemy()
		    if enemy ~= nil then
			    enemy_type = get_clsid(enemy)
			    if enemy_type == clsid.actor and
				    utils.npc_in_zone(db.actor, db.zone_by_name["val_lager_bandits_restrictor"]) then
				    return state_alarm_actor_inside
			    end
			    if enemy_type == clsid.actor or
  	   			    enemy_type == clsid.soldier or
	   			    enemy_type == clsid.script_stalker or
   				    enemy_type == clsid.trader
   			    then
   				    gulag.alarm_start = game.get_game_time()
   				    return state_alarm
   			    end
		    end
		end
	end		
	
	if gulag.alarm_start == nil or game.get_game_time():diffSec(gulag.alarm_start) > 900 then
		return state_normal -- îáû÷íîå ñîñòîÿíèå
	end
	return state_alarm -- òðåâîãà
end


--------------------------------------------------------------------------
-- Monolith base
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------

-- Jobs ------------------------------------------------------------------
function load_job_monolith_base(sj, gname, type, squad, groups)
    local i, v, j

    -- ïàòðóëè
    for i = 1, 6 do
	    t = { section = "logic@" .. gname .. "_patrol_normal" .. i,
		    idle = 0,
		    prior = 4, state = {state_normal},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_main_building_restrictor"
	    }
	    table.insert(sj, t)        
    end

    local pr = {1, 1, 1, 3, 2}
    -- êåìïû
    for i, v in pairs({4, 4, 4, 5, 4}) do
        for j = 1, v do
	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_normal",
		        idle = 0,
		        prior = pr[i], state = {state_normal},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = gname .. "_main_building_restrictor"
	        }
	        table.insert(sj, t)        
        end
    end
end

-- States ----------------------------------------------------------------
function check_state_monolith_base(gulag)
	return state_normal
end

-- Check stalker ---------------------------------------------------------
function check_stalker_monolith_base(npc_community, gulag_type, npc_rank, se_obj, stalker)
    return stalker and se_obj:profile_name() == "val_monolith_regular"
end

-- Dynamic ltx -----------------------------------------------------------
function load_ltx_monolith_base(gname, type)
    local i, res = 0, ""

    -- ïàòðóëè
    for i = 1, 6 do
        res = res.."[logic@" .. gname .. "_patrol_normal" .. i .. "]\n" ..
                   "active              = walker@" .. gname .. "_patrol_normal" .. i .. "\n" ..
                   --"combat_ignore      = combat_ignore\n" ..

                   "[walker@" .. gname .. "_patrol_normal" .. i .. "]\n" ..
                   "path_walk           = in_patrol_walk" .. i .. "\n" ..
                   "path_look           = in_patrol_look" .. i .. "\n" ..
                   "def_state_moving    = rush\n" --..
                   --"combat_ignore_cond  = {=val_fighting_captive}, {=fighting_actor +val_monolith_actor_detected} never, {=fighting_actor =actor_wears_bandit_outfit} always, {=fighting_actor} never %+val_monolith_actor_detected%\n"
    end

    -- êåìïû
    for i = 1, 5 do
        res = res.."[logic@" .. gname .. "_kamp" .. i .. "_normal]\n" ..
                   "active              = kamp@" .. gname .. "_kamp" .. i .. "_normal\n" ..
                   --"combat_ignore      = combat_ignore\n" ..

                   "[kamp@" .. gname .. "_kamp" .. i .. "_normal]\n" ..
                   "center_point        = in_kamp" .. i .. "\n" ..
                   "def_state_moving    = rush\n" --..
                   --"combat_ignore_cond  = {=val_fighting_captive}, {=fighting_actor +val_monolith_actor_detected} never, {=fighting_actor =actor_wears_bandit_outfit} always, {=fighting_actor} never %+val_monolith_actor_detected%\n"
    end

    return res
end


--------------------------------------------------------------------------
-- War soldiers
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function ws_predicate(data)
    local pname = data.profile_name
	return pname == "val_soldier_regular" or pname == "val_soldier_specnaz"
end

-- Jobs ------------------------------------------------------------------
function load_job_war_soldiers(sj, gname, type, squad, groups)
    local i, v, j

    -- ïàòðóëè
    for i = 1, 6 do
        -- normal
	    t = { section = "logic@" .. gname .. "_patrol_normal" .. i,
		    idle = 0,
		    prior = 4, state = {state_normal},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_main_building_restrictor",
		    predicate = ws_predicate
	    }
	    table.insert(sj, t)
	    -- fight
	    t = { section = "logic@" .. gname .. "_fight1",
		    idle = 0,
		    prior = 4, state = {state_fight},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = "val_monolith_base_war_restrictor",
		    predicate = ws_predicate
	    }
	    table.insert(sj, t)
    end

    local pr = {1, 1, 1, 3, 2}
    -- êåìïû
    for i, v in pairs({4, 4, 4, 5, 4}) do
        for j = 1, v do
            -- normal
	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_normal",
		        idle = 0,
		        prior = pr[i], state = {state_normal},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = gname .. "_main_building_restrictor",
		        predicate = ws_predicate
	        }
	        table.insert(sj, t)        
	        -- fight
	        t = { section = "logic@" .. gname .. "_fight" .. i ,
		        idle = 0,
		        prior = 1, state = {state_fight},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = "val_monolith_base_war_restrictor",
		        predicate = ws_predicate
	        }
	        table.insert(sj, t)
        end
    end
end

-- States ----------------------------------------------------------------
function check_state_war_soldiers(gulag)
	if db.actor:has_info("val_opendoor_chase_start") then
		return state_normal
	end
	return state_fight
end

-- Dynamic ltx -----------------------------------------------------------
function load_ltx_war_soldiers(gname, type)
    local i, res = 0, ""

    -- ïàòðóëè
    for i = 1, 6 do
        res = res.."[logic@" .. gname .. "_patrol_normal" .. i .. "]\n" ..
                   "active              = walker@" .. gname .. "_patrol_normal" .. i .. "\n" ..
                   "combat_ignore       = combat_ignore\n" ..

                   "[walker@" .. gname .. "_patrol_normal" .. i .. "]\n" ..
                   "path_walk           = in_patrol_walk" .. i .. "\n" ..
                   "path_look           = in_patrol_look" .. i .. "\n" ..
                   "def_state_moving    = rush\n" ..
                   "combat_ignore_cond  = {=check_fighting(410)}\n"
    end

    -- êåìïû
    for i = 1, 5 do
        res = res.."[logic@" .. gname .. "_kamp" .. i .. "_normal]\n" ..
                   "active             = kamp@" .. gname .. "_kamp" .. i .. "_normal\n" ..
                   "combat_ignore      = combat_ignore\n" ..
                   
                   "[kamp@" .. gname .. "_kamp" .. i .. "_normal]\n" ..
                   "center_point       = in_kamp" .. i .."\n" ..
                   "def_state_moving   = rush\n" ..
                   "combat_ignore_cond = {=check_fighting(410)}\n" ..
                   
                   "[logic@" .. gname .. "_fight" .. i .. "]\n" ..
                   "active              = remark@" .. gname .. "_fight" .. i .. "\n" ..
                   "combat_ignore       = combat_ignore\n" ..

                   "[remark@" .. gname .. "_fight" .. i .. "]\n" ..
                   "center_point       = in_kamp" .. i .."\n" ..
                   "no_move             = true\n" ..
                   "combat_ignore_cond  = {=check_fighting(410)}\n"
    end

    return res
end


-------------------------------------------------------------------------------------------------------------------------
-- gulags                      -- job_func              -- check_state func         -- communities      -- dynamic ltx func
gulags.val_escort           = {load_job_escort,         check_state_escort,         {"bandit", "dolg"}, load_ltx_escort}
gulags.val_sacrifice        = {load_job_sacrifice,      check_state_sacrifice,      {"bandit", "dolg"}, load_ltx_sacrifice}
gulags.val_prisoner         = {load_job_prisoner,       check_state_prisoner,       {"dolg"},           load_ltx_prisoner}
gulags.val_rob              = {load_job_robbers,        check_state_robbers,        {check_stalker_rob},                 load_ltx_robbers}
gulags.val_lager_bandits    = {load_job_lager_bandits,  check_state_lager_bandits,  {"bandit"}}
gulags.val_monolith_base    = {load_job_monolith_base,  check_state_monolith_base,  {check_stalker_monolith_base},  load_ltx_monolith_base}
gulags.val_war_soldiers     = {load_job_war_soldiers,   check_state_war_soldiers,   {"military"},                   load_ltx_war_soldiers}
