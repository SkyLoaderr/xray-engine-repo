-----------------------------------------------------------------------
-- —ÓÒÚÓˇÌËˇ ·‡Á˚ ·‡Ì‰ËÚÓ‚
--    0 - ÌÓÏ‡Î¸ÌÓÂ ÒÓÒÚÓˇÌËÂ
--    2 - ÚÂ‚Ó„‡
-----------------------------------------------------------------------

--------------------------------------------------------------------------
-- Member counts
--------------------------------------------------------------------------
local mob_spring_count = 10

--------------------------------------------------------------------------
-- States
--------------------------------------------------------------------------
local state_normal = 0
local state_alarm = 1
local state_alarm_actor_inside = 2
local state_fight = 1

local gulags = {}

--------------------------------------------------------------------------
-- General
--------------------------------------------------------------------------
-- Job -------------------------------------------------------------------
function load_job(sj, gname, type, squad, groups)
    local g = gulags[type]
    if g then
        g[1](sj, gname, type, squad, groups)
    end
end

-- State -----------------------------------------------------------------
function load_states(gname, type)
    local g = gulags[type]

    if g then
        return g[2]
    end

	return nil
end
	    
-- Dynamic ltx -----------------------------------------------------------
function load_ltx(gname, type)
    local g = gulags[type]
    if g and g[4] then
        return g[4](gname, type)
    end

	return nil
end

-- Check communities -----------------------------------------------------
local function checkCommon(npc_community, g)
    local not_exist = true
    local i, v

    for i, v in pairs(g[3]) do
        if npc_community == v then
            return true
        end
        not_exist = false
    end

    return not_exist
end

function checkStalker(npc_community, gulag_type)
    local g = gulags[gulag_type]
    if g then
        return checkCommon(npc_community, g)
    end

	return false
end

function checkMonster(npc_community, gulag_type)
    local g = gulags[gulag_type]
    if g then
        return checkCommon(npc_community, g)
    end

    return false
end

--------------------------------------------------------------------------
-- Gulags
--------------------------------------------------------------------------

--------------------------------------------------------------------------
-- Bandits
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function lb_predicate1(obj) 
	return obj:profile_name() == "val_bandit_borov"
end

function lb_predicate2(obj) 
	return obj:profile_name() == "val_bandit_veteran"
end

function lb_predicate3(obj) 
	return obj:profile_name() == "val_bandit_general"
end

-- Jobs ------------------------------------------------------------------
function load_job_lager_bandits(sj, gname, type, squad, groups)
    local i, v, j = 0, 0, 0
    local restr, gr, prior, rst = 0, 0, 0, 0

	-----------------------------------------------------------------------
	-- œ–»Œ–»“≈“ 9 - ¡Œ–Œ¬
	-----------------------------------------------------------------------
	t = { section = "logic@" .. gname .. "_leader_normal",
		idle = 0,
		prior = 9, state = {state_normal},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = gname .. "_borov_restrictor",
		predicate = lb_predicate1
	}
	table.insert(sj, t)

	t = { section = "logic@" .. gname .. "_leader_alarm",
		idle = 0,
		prior = 9, state = {state_alarm},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = gname .. "_borov_restrictor",
		predicate = lb_predicate1
	}
	table.insert(sj, t)

	t = { section = "logic@" .. gname .. "_leader_alarm",
		idle = 0,
		prior = 9, state = {state_alarm_actor_inside},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = gname .. "_borov_restrictor",
		predicate = lb_predicate1
	}
	table.insert(sj, t)

	-----------------------------------------------------------------------
	-- œ–»Œ–»“≈“ 8 - Œ’–¿ÕÕ» » ¡Œ–Œ¬¿
	-----------------------------------------------------------------------
    for i = 1, 3 do
	    t = { section = "logic@" .. gname .. "_bodyguard_normal" .. i,
		    idle = 0,
		    prior = 8, state = {state_normal},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_main_building_restrictor",
		    predicate = lb_predicate2
	    }
	    table.insert(sj, t)

	    t = { section = "logic@" .. gname .. "_bodyguard_alarm" .. i,
		    idle = 0,
		    prior = 8, state = {state_alarm},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_main_building_restrictor",
		    predicate = lb_predicate2
	    }
	    table.insert(sj, t)

	    t = { section = "logic@" .. gname .. "_bodyguard_alarm" .. i,
		    idle = 0,
		    prior = 8, state = {state_alarm_actor_inside},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_main_building_restrictor",
		    predicate = lb_predicate2
	    }
	    table.insert(sj, t)
    end

	-----------------------------------------------------------------------
	-- œ–»Œ–»“≈“ 7 - —»ƒﬂŸ»≈ ¬  ≈Ãœ≈ 1 ¬Œ«À≈ ¡Œ–Œ¬¿ » ¬  ≈Ãœ≈ 2 Õ¿ ¬“Œ–ŒÃ ›“¿∆≈
	-----------------------------------------------------------------------
	restr = {gname .. "_main_building_restrictor", gname .. "_nedostroyka_restrictor", gname .. "_nedostroyka_restrictor"}
	local pr = {7, 7, 2}
	for i, v in pairs({3, 4, 2}) do
	    for j = 1, v do
	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_normal",
		        idle = 0,
		        prior = pr[i], state = {state_normal},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = restr[i],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)

	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_alarm" .. j,
		        idle = 0,
		        prior = pr[i], state = {state_alarm},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = restr[i],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)

	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_alarm" .. j,
		        idle = 0,
		        prior = pr[i], state = {state_alarm_actor_inside},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = restr[i],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)
	    end
	end

	-----------------------------------------------------------------------
	-- œ–»Œ–»“≈“ 6 - ¡¿Õƒ»“€ Õ¿ ¬Œ–Œ“¿’
	-----------------------------------------------------------------------
	restr =  {{gname .. "_main_side_restrictor", gname .. "_restrictor"},
	          {gname .. "_main_side_restrictor", gname .. "_restrictor", gname .. "_restrictor", gname .. "_restrictor"},
	          {gname .. "_restrictor", gname .. "_restrictor"},
	          {gname .. "_restrictor", gname .. "_restrictor", gname .. "_restrictor", gname .. "_restrictor"}}
	gr = {"guard", "patrol", "sniper", "sleeper"}
	prior =  {6, 5, 4, 3}
	for i, v in pairs({2, 4, 2, 4}) do
	    rst = restr[i]
	    for j = 1, v do
	        t = { section = "logic@" .. gname .. "_" .. gr[i] .. "_normal" .. j,
		        idle = 0,
		        prior = prior[i], state = {state_normal},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = rst[j],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)

	        t = { section = "logic@" .. gname .. "_" .. gr[i] .. "_alarm" .. j,
		        idle = 0,
		        prior = prior[i], state = {state_alarm},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = rst[j],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)

	        t = { section = "logic@" .. gname .. "_" .. gr[i] .. "_alarm" .. j,
		        idle = 0,
		        prior = prior[i], state = {state_alarm_actor_inside},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = rst[j],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)
	    end
	end

--[[
	-----------------------------------------------------------------------
	-- œ–»Œ–»“≈“ 5 - œ¿“–”À‹Õ€≈ Õ¿ “≈––»“Œ–»»
	-----------------------------------------------------------------------
	restr = {gname .. "_main_side_restrictor", gname .. "_restrictor", gname .. "_restrictor", gname .. "_restrictor"}
	for i = 1, 4 do
	    t = { section = "logic@" .. gname .. "_patrol_normal" .. i,
		    idle = 0,
		    prior = 5, state = {state_normal},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = restr[i],
		    predicate = lb_predicate3
	    }
	    table.insert(sj, t)

	    t = { section = "logic@" .. gname .. "_patrol_alarm" .. i,
		    idle = 0,
		    prior = 5, state = {state_alarm},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = restr[i],
		    predicate = lb_predicate3
	    }
	    table.insert(sj, t)

	    t = { section = "logic@" .. gname .. "_patrol_alarm" .. i,
		    idle = 0,
		    prior = 5, state = {state_alarm_actor_inside},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = restr[i],
		    predicate = lb_predicate3
	    }
	    table.insert(sj, t)
	end

	-----------------------------------------------------------------------
	-- œ–»Œ–»“≈“ 4 - —Õ¿…œ≈–€ Õ¿ ¬€ÿ ¿’
	-----------------------------------------------------------------------
	restr = gname .. "_restrictor"
	for i = 1, 2 do
	    t = { section = "logic@" .. gname .. "_sniper_normal" .. i,
		    idle = 0,
		    prior = 4, state = {state_normal},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = restr,
		    predicate = lb_predicate3
	    }
	    table.insert(sj, t)

	    t = { section = "logic@" .. gname .. "_sniper_alarm" .. i,
		    idle = 0,
		    prior = 4, state = {state_alarm},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = restr,
		    predicate = lb_predicate3
	    }
	    table.insert(sj, t)

	    t = { section = "logic@" .. gname .. "_sniper_alarm" .. i,
		    idle = 0,
		    prior = 4, state = {state_alarm_actor_inside},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = restr,
		    predicate = lb_predicate3
	    }
	    table.insert(sj, t)
	end

	-----------------------------------------------------------------------
	-- œ–»Œ–»“≈“ 3 - —œﬂŸ»≈ ¡¿Õƒ»“€
	-----------------------------------------------------------------------
	restr = gname .. "_restrictor"
	for i = 1, 4 do
	    t = { section = "logic@" .. gname .. "_sleeper_normal" .. i,
		    idle = 0,
		    prior = 3, state = {state_normal},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = restr,
		    predicate = lb_predicate3
	    }
	    table.insert(sj, t)

	    t = { section = "logic@" .. gname .. "_sleeper_alarm" .. i,
		    idle = 0,
		    prior = 3, state = {state_alarm},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = restr,
		    predicate = lb_predicate3
	    }
	    table.insert(sj, t)

	    t = { section = "logic@" .. gname .. "_sleeper_alarm" .. i,
		    idle = 0,
		    prior = 3, state = {state_alarm_actor_inside},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = restr,
		    predicate = lb_predicate3
	    }
	    table.insert(sj, t)
	end
]]
end

-- States ----------------------------------------------------------------
function check_state_lager_bandits(gulag)
	for k,v in pairs(gulag.Object) do
		local enemy = v:best_enemy()
		if enemy ~= nil then
			enemy_type = get_clsid(enemy)
			if enemy_type == clsid.actor and
				utils.npc_in_zone(db.actor, db.zone_by_name["val_lager_bandits_restrictor"]) then
				return state_alarm_actor_inside
			end
			if enemy_type == clsid.actor or
  	   			enemy_type == clsid.soldier or
	   			enemy_type == clsid.script_stalker or
   				enemy_type == clsid.trader
   			then
   				gulag.alarm_start = game.get_game_time()
   				return state_alarm
   			end
		end
	end		
	
	if gulag.alarm_start == nil or game.get_game_time():diffSec(gulag.alarm_start) > 900 then
		return state_normal -- Ó·˚˜ÌÓÂ ÒÓÒÚÓˇÌËÂ
	end
	return state_alarm -- ÚÂ‚Ó„‡
end


--------------------------------------------------------------------------
-- Monolith base
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function mb_predicate(obj)
    return obj:profile_name() == "val_monolith_regular"
end

-- Jobs ------------------------------------------------------------------
function load_job_monolith_base(sj, gname, type, squad, groups)
    local i, v, j

    -- Ô‡ÚÛÎË
    for i = 1, 6 do
	    t = { section = "logic@" .. gname .. "_patrol_normal" .. i,
		    idle = 0,
		    prior = 4, state = {state_normal},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_main_building_restrictor",
		    predicate = mb_predicate
	    }
	    table.insert(sj, t)        
    end

    local pr = {1, 1, 1, 3, 2}
    -- ÍÂÏÔ˚
    for i, v in pairs({4, 4, 4, 5, 4}) do
        for j = 1, v do
	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_normal",
		        idle = 0,
		        prior = pr[i], state = {state_normal},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = gname .. "_main_building_restrictor",
		        predicate = mb_predicate
	        }
	        table.insert(sj, t)        
        end
    end
end

-- States ----------------------------------------------------------------
function check_state_monolith_base(gulag)
	return state_normal
end

-- Dynamic ltx -----------------------------------------------------------
function load_ltx_monolith_base(gname, type)
    local i, res = 0, ""

    -- Ô‡ÚÛÎË
    for i = 1, 6 do
        res = res.."[logic@" .. gname .. "_patrol_normal" .. i .. "]\n" ..
                   "active              = walker@" .. gname .. "_patrol_normal" .. i .. "\n" ..
                   --"combat_ignore      = combat_ignore\n" ..

                   "[walker@" .. gname .. "_patrol_normal" .. i .. "]\n" ..
                   "path_walk           = in_patrol_walk" .. i .. "\n" ..
                   "path_look           = in_patrol_look" .. i .. "\n" ..
                   "def_state_moving    = rush\n" --..
                   --"combat_ignore_cond  = {=val_fighting_captive}, {=fighting_actor +val_monolith_actor_detected} never, {=fighting_actor =actor_wears_bandit_outfit} always, {=fighting_actor} never %+val_monolith_actor_detected%\n"
    end

    -- ÍÂÏÔ˚
    for i = 1, 5 do
        res = res.."[logic@" .. gname .. "_kamp" .. i .. "_normal]\n" ..
                   "active              = kamp@" .. gname .. "_kamp" .. i .. "_normal\n" ..
                   --"combat_ignore      = combat_ignore\n" ..

                   "[kamp@" .. gname .. "_kamp" .. i .. "_normal]\n" ..
                   "center_point        = in_kamp" .. i .. "\n" ..
                   "def_state_moving    = rush\n" --..
                   --"combat_ignore_cond  = {=val_fighting_captive}, {=fighting_actor +val_monolith_actor_detected} never, {=fighting_actor =actor_wears_bandit_outfit} always, {=fighting_actor} never %+val_monolith_actor_detected%\n"
    end

    return res
end


--------------------------------------------------------------------------
-- War soldiers
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function ws_predicate(obj)
    local pname = obj:profile_name()
	return pname == "val_soldier_regular" or pname == "val_soldier_specnaz"
end

-- Jobs ------------------------------------------------------------------
function load_job_war_soldiers(sj, gname, type, squad, groups)
    local i, v, j

    -- Ô‡ÚÛÎË
    for i = 1, 6 do
        -- normal
	    t = { section = "logic@" .. gname .. "_patrol_normal" .. i,
		    idle = 0,
		    prior = 4, state = {state_normal},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_main_building_restrictor",
		    predicate = ws_predicate
	    }
	    table.insert(sj, t)
	    -- fight
	    t = { section = "logic@" .. gname .. "_fight",
		    idle = 0,
		    prior = 4, state = {state_fight},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = "val_monolith_base_war_restrictor",
		    predicate = ws_predicate
	    }
	    table.insert(sj, t)
    end

    local pr = {1, 1, 1, 3, 2}
    -- ÍÂÏÔ˚
    for i, v in pairs({4, 4, 4, 5, 4}) do
        for j = 1, v do
            -- normal
	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_normal",
		        idle = 0,
		        prior = pr[i], state = {state_normal},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = gname .. "_main_building_restrictor",
		        predicate = mb_predicate
	        }
	        table.insert(sj, t)        
	        -- fight
	        t = { section = "logic@" .. gname .. "_fight",
		        idle = 0,
		        prior = 1, state = {state_fight},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = "val_monolith_base_war_restrictor",
		        predicate = ws_predicate
	        }
	        table.insert(sj, t)
        end
    end
end

-- States ----------------------------------------------------------------
function check_state_war_soldiers(gulag)
	if db.actor:has_info("val_opendoor_chase_start") then
		return state_normal
	end
	return state_fight
end

-- Dynamic ltx -----------------------------------------------------------
function load_ltx_war_soldiers(gname, type)
    local i, res = 0, ""

    -- Ô‡ÚÛÎË
    for i = 1, 6 do
        res = res.."[logic@" .. gname .. "_patrol_normal" .. i .. "]\n" ..
                   "active              = walker@" .. gname .. "_patrol_normal" .. i .. "\n" ..
                   "combat_ignore       = combat_ignore\n" ..

                   "[walker@" .. gname .. "_patrol_normal" .. i .. "]\n" ..
                   "path_walk           = in_patrol_walk" .. i .. "\n" ..
                   "path_look           = in_patrol_look" .. i .. "\n" ..
                   "def_state_moving    = rush\n" ..
                   "combat_ignore_cond  = {=check_fighting(410)}\n"
    end

    -- ÍÂÏÔ˚
    for i = 1, 5 do
        res = res.."logic@" .. gname .. "_kamp" .. i .. "_normal\n" ..
                    "active             = kamp@" .. gname .. "_kamp" .. i .. "_normal\n" ..
                    "combat_ignore      = combat_ignore\n" ..
                    
                    "[kamp@" .. gname .. "_kamp" .. i .. "_normal]\n" ..
                    "center_point       = in_kamp" .. i .."\n" ..
                    "def_state_moving   = rush\n" ..
                    "combat_ignore_cond = {=check_fighting(410)}\n"
    end
    
    res = res.."[logic@" .. gname .. "_fight]\n" ..
               "active              = remark@" .. gname .. "_fight\n" ..
               "combat_ignore       = combat_ignore\n" ..

               "[remark@" .. gname .. "_fight]\n" ..
               "no_move             = true\n" ..
               "combat_ignore_cond  = {=check_fighting(410)}\n"

    return res
end


--------------------------------------------------------------------------
-- Monster on spring
--------------------------------------------------------------------------
-- Jobs ------------------------------------------------------------------
function load_job_mob_spring(sj, gname, type, squad, groups)
    local i = 0
    for i = 1, mob_spring_count do
        --- state 0
	    t = { section = "logic@nil",
		    idle = 0,
		    prior = 1, state = {0}, squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_small_restr"
	    }
	    table.insert(sj, t)
        --- state 1
	    t = { section = "logic@nil",
		    idle = 0,
		    prior = 1, state = {1}, squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_big_restr"
	    }
        table.insert(sj, t)
   end
end

-- States ----------------------------------------------------------------
function check_state_mob_spring(gulag)
	local t = db.zone_by_name[gulag.name .. "_big_restr"] -- ËÏˇ ·ÓÎ¸¯Ó„Ó ÂÒÚ.
	if t and db.actor then
		if t:inside(db.actor:position()) then
			return 1
		else
			return 0
		end
	else
		return gulag.state
	end
end

-------------------------------------------------------------------------------------------------------------------------
-- gulags                      -- job_func              -- check_state func         -- communities  -- dynamic ltx func
gulags.val_lager_bandits    = {load_job_lager_bandits,  check_state_lager_bandits,  {"bandit"}}
gulags.val_monolith_base    = {load_job_monolith_base,  check_state_monolith_base,  {"monolith"},   load_ltx_monolith_base}
gulags.val_war_soldiers     = {load_job_war_soldiers,   check_state_war_soldiers,   {"military"},   load_ltx_war_soldiers}

gulags.val_dogs_nest1       = {load_job_mob_spring,     check_state_mob_spring,     {"dog"}}
gulags.val_dogs_nest2       = {load_job_mob_spring,     check_state_mob_spring,     {"dog"}}
gulags.val_dogs_nest3       = {load_job_mob_spring,     check_state_mob_spring,     {"dog"}}
gulags.val_dogs_nest4       = {load_job_mob_spring,     check_state_mob_spring,     {"dog"}}
gulags.val_dogs_nest5       = {load_job_mob_spring,     check_state_mob_spring,     {"dog"}}

gulags.val_fleshes_nest1    = {load_job_mob_spring,     check_state_mob_spring,     {"flesh"}}
gulags.val_fleshes_nest2    = {load_job_mob_spring,     check_state_mob_spring,     {"flesh"}}
gulags.val_fleshes_nest3    = {load_job_mob_spring,     check_state_mob_spring,     {"flesh"}}
gulags.val_fleshes_nest4    = {load_job_mob_spring,     check_state_mob_spring,     {"flesh"}}
gulags.val_fleshes_nest5    = {load_job_mob_spring,     check_state_mob_spring,     {"flesh"}}

gulags.val_boars_nest1      = {load_job_mob_spring,     check_state_mob_spring,     {"boar"}}
gulags.val_boars_nest2      = {load_job_mob_spring,     check_state_mob_spring,     {"boar"}}
gulags.val_boars_nest3      = {load_job_mob_spring,     check_state_mob_spring,     {"boar"}}
gulags.val_boars_nest4      = {load_job_mob_spring,     check_state_mob_spring,     {"boar"}}
gulags.val_boars_nest5      = {load_job_mob_spring,     check_state_mob_spring,     {"boar"}}
