
--------------------------------------------------------------------------
-- Member counts
--------------------------------------------------------------------------
local mob_spring_count = 20

--------------------------------------------------------------------------
-- States
--------------------------------------------------------------------------
local state_normal = 0
local state_alarm = 1
local state_alarm_actor_inside = 2
local state_fight = 1

--------------------------------------------------------------------------
-- General
--------------------------------------------------------------------------
local t = {}
local gulags = {val_escort = {comm = {"bandit", "dolg"}}, val_sacrifice = {comm = {"bandit", "dolg"}},
                val_prisoner = {comm = {"dolg"}}, val_rob = {},
                val_lager_bandits = {comm = {"bandit"}}, val_war_soldiers = {comm = {"military"}},
                val_monolith_base = {}, val_offline_group = {}}

-- Job -------------------------------------------------------------------
function load_job(sj, gname, type, squad, groups)
    local g = gulags[type]
    if g then
        --g[1](sj, gname, type, squad, groups)
        g.job(sj, gname, type, squad, groups)
    end
end

-- State -----------------------------------------------------------------
function load_states(gname, type)
    local g = gulags[type]

    if g then
        --return g[2]
        return g.state
    end

	return nil
end
	    
-- Dynamic ltx -----------------------------------------------------------
function load_ltx(gname, type)
    local g = gulags[type]
    if g then --and g.ltx then --g[4] then
        --return g[4](gname, type)
        return g.ltx --(gname, type)
    end

	return nil
end

-- Check communities -----------------------------------------------------
local function checkCommon(npc_community, gulag_type, npc_rank, se_obj, stalker)
    local g = gulags[gulag_type]
    if g then
        if g.comm then
            if type(g.comm) == "function" then
                return g.comm(npc_community, gulag_type, npc_rank, se_obj, stalker)
            end
            if type(g.comm) == "boolean" then
                return g.comm == stalker
            end

            local i, v = 0, 0
            for i, v in pairs(g.comm) do
                if npc_community == v then
                    return true
                end
            end
            if i > 0 then
                return false
            end
        end
        return true
    end
	return false
end

function checkStalker(npc_community, gulag_type, npc_rank, se_obj)
	return checkCommon(npc_community, gulag_type, npc_rank, se_obj, true)
end

function checkMonster(npc_community, gulag_type, npc_rank, se_obj)
	return checkCommon(npc_community, gulag_type, npc_rank, se_obj, false)
end


--------------------------------------------------------------------------
-- Gulags
--------------------------------------------------------------------------

--------------------------------------------------------------------------
-- Escort
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function e_predicate_n(data) -- nap1
	return data.story_id == 406
end

function e_predicate_c(data) -- captive
	return data.story_id == 400
end

function e_predicate_w(data) -- wounded bandit
	return data.story_id == 424
end

function e_predicate_g(data) -- guards
	return data.profile_name == "val_bandit_general"
end

-- Jobs ------------------------------------------------------------------
function load_job_escort(sj, gname, type, squad, groups)
    local ltx = ""

	t = { section = "logic@" .. gname .. "_nap1",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		online = true,
		predicate = e_predicate_n
	}
	table.insert(sj, t)
    ltx = ltx.."#include \"scripts\\val_escort_nap1.ltx\"\n"

	t = { section = "logic@" .. gname .. "_captive",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		online = true,
		predicate = e_predicate_c
	}
	table.insert(sj, t)
    ltx = ltx.."#include \"scripts\\val_escort_captive.ltx\"\n"

	t = { section = "logic@" .. gname .. "_guard1",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		online = true,
		predicate = e_predicate_g
	}
	table.insert(sj, t)
    ltx = ltx.."#include \"scripts\\val_escort_guard1.ltx\"\n"

	t = { section = "logic@" .. gname .. "_guard2",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		online = true,
		predicate = e_predicate_g
	}
	table.insert(sj, t)
    ltx = ltx.."#include \"scripts\\val_escort_guard2.ltx\"\n"

	t = { section = "logic@" .. gname .. "_halfdead",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		--online = true,
		predicate = e_predicate_w
	}
	table.insert(sj, t)

    ltx = ltx.."[logic@" .. gname .. "_halfdead]\n" ..
               "active          = remark@" .. gname .. "_halfdead_wait\n" ..
               "combat_ignore   = combat_ignore\n" ..

               "[wounded@" .. gname .. "_halfdead]\n" ..
               "hp_state        = 10|wounded_heavy\n" ..
               "hp_state_see    = 10|wounded_heavy\n" ..
               "hp_cover        = 10|false\n" ..
               "hp_fight        = 10|false\n" ..

               "[wounded@" .. gname .. "_halfdead1]\n" ..
               "hp_state        = 1|wounded_heavy\n" ..
               "hp_state_see    = 1|wounded_heavy\n" ..
               "hp_cover        = 10|false\n" ..
               "hp_fight        = 10|false\n" ..

               "[remark@" .. gname .. "_halfdead_wait]\n" ..
               "path_walk           = nap1_look\n" ..
               "anim                = wounded_heavy ;wait\n" ..
               "target              = 406\n" ..
               "on_info             = {+val_nap1_phrase1_end} remark@" .. gname .. "_halfdead_phrase\n" ..
               "wounded             = wounded@" .. gname .. "_halfdead\n" ..
               "combat_ignore_cond  = always\n" ..

               --------------------------------------------------------------------------
               -- фраза: Не-еет!!! Не убивай меня! Твоего напарника, сейчас будут вести на Базу Монолита.
               --        Это все, что я знаю...бля-буду...
               --------------------------------------------------------------------------
               "[remark@" .. gname .. "_halfdead_phrase]\n" ..
               "anim                = wounded_heavy ;wait\n" ..
               "snd                 = speech\n" ..
               "target              = 406\n" ..
               "on_signal           = sound_end | remark@" .. gname .. "_halfdead_end %+val_halfdead_phrase_end%\n" ..
               "wounded             = wounded@" .. gname .. "_halfdead1\n" ..
               "combat_ignore_cond  = always\n" ..

               "[remark@" .. gname .. "_halfdead_end]\n" ..
               "anim            = wounded_heavy ;wait\n" ..
               "target          = 406\n" ..
               "wounded         = wounded@" .. gname .. "_halfdead\n"

    gulags.val_escort.ltx = ltx
end

-- States ----------------------------------------------------------------
function check_state_escort(gulag)
	return 0
end


--------------------------------------------------------------------------
-- Sacrifice
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function scf_predicate_v(data) -- victim
	return data.story_id == 401
end

function scf_predicate_g1(data) -- guard1
	return data.story_id == 404
end

function scf_predicate_g2(data) -- guard2
	return data.story_id == 405
end

function scf_predicate_tb(data) -- tunnel bandit
	return data.story_id == 409
end

-- Jobs ------------------------------------------------------------------
function load_job_sacrifice(sj, gname, type, squad, groups)
	t = { section = "logic@" .. gname .. "_victim",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		online = true,
		predicate = scf_predicate_v
	}
	table.insert(sj, t)

	t = { section = "logic@" .. gname .. "_guard1",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		online = true,
		predicate = scf_predicate_g1
	}
	table.insert(sj, t)

	t = { section = "logic@" .. gname .. "_guard2",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		online = true,
		predicate = scf_predicate_g2
	}
	table.insert(sj, t)

	t = { section = "logic@" .. gname .. "_tunnel_bandit",
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		predicate = scf_predicate_tb
	}
	table.insert(sj, t)

    local ltx = "[combat@" .. gname .. "]\n" ..
                "on_info = {=see_actor} %+val_sacrifice_plr_detected +val_sacrifice_finish%\n" ..

                ";[hit@" .. gname .. "_guard]\n" ..
                ";on_info = {=hit_by_actor} %+val_sacrifice_plr_detected +val_sacrifice_finish%\n" ..

                "[danger@" .. gname .. "_guard]\n" ..
                "ignore_distance = 1\n" ..
                    
                "#include \"scripts\\val_sacrifice_victim.ltx\"\n" ..
                "#include \"scripts\\val_sacrifice_guard1.ltx\"\n" ..
                "#include \"scripts\\val_sacrifice_guard2.ltx\"\n" ..
                "#include \"scripts\\val_tunnel_bandit.ltx\"\n"

    gulags.val_sacrifice.ltx = ltx
end

-- States ----------------------------------------------------------------
function check_state_sacrifice(gulag)
	return 0
end


--------------------------------------------------------------------------
-- Prisoner
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function p_predicate(data) -- prisoner
	return data.story_id == 402
end

-- Jobs ------------------------------------------------------------------
function load_job_prisoner(sj, gname, type, squad, groups)
	t = { section = "logic@" .. gname,
		idle = 0,
		prior = 1, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = "",
		online = true,
		predicate = p_predicate
	}
	table.insert(sj, t)

    gulags.val_prisoner.ltx = "#include \"scripts\\val_prisoner_captive.ltx\"\n"
end

-- States ----------------------------------------------------------------
function check_state_prisoner(gulag)
	return 0
end


--------------------------------------------------------------------------
-- Robbers
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------

-- Jobs ------------------------------------------------------------------
function load_job_robbers(sj, gname, type, squad, groups)
    local i, ltx = 0, ""

	t = { section = "logic@" .. gname .. "_leader",
		idle = 0,
		prior = 3, state = {0},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = ""
	}
	table.insert(sj, t)
    ltx = ltx.."#include \"scripts\\val_rob_leader.ltx\"\n"

    ltx = ltx.."[meet@" .. gname .. "_guard]\n" ..
               "meet_state 	   = 30| {+val_rob_buying} threat, wait@ {+val_rob_buying} val_rob_guard_jeer, weather\n" ..
               "meet_state_wpn = 30| threat@threat_back\n" ..
               ";victim        = 30| actor\n" ..
               ";victim_wpn    = 30| actor\n" ..
               ";use           = true\n" ..
               "use_wpn	       = true\n" ..
               "zone           = val_rob_warn_zone| threat@ {+val_rob_buying} val_rob_guard_jeer, threat_back | val_rob_kill_zone| true@talk_abuse\n"

    for i = 1, 2 do
	    t = { section = "logic@" .. gname .. "_guard" .. i,
		    idle = 0,
		    prior = 2, state = {0},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = ""
	    }
	    table.insert(sj, t)

        ltx = ltx.."[logic@" .. gname .. "_guard" .. i .. "]\n" ..
                   "active = walker@" .. gname .. "_guard" .. i .. "\n" ..

                   "[walker@" .. gname .. "_guard" .. i .. "]\n" ..
                   "path_walk = guard" .. i .. "_walk\n" ..
                   "path_look = guard" .. i .. "_look\n" ..
                   "meet      = meet@" .. gname .. "_guard\n"
	end

    for i = 1, 4 do
	    t = { section = "logic@" .. gname .. "_kamp",
		    idle = 0,
		    prior = 1, state = {0},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = ""
	    }
	    table.insert(sj, t)
	end

    ltx = ltx.."[logic@" .. gname .. "_kamp]\n" ..
               "active = kamp@" .. gname .. "\n" ..

               "[kamp@" .. gname .. "]\n" ..
               "center_point = kamp\n"

    gulags.val_rob.ltx = ltx
end

-- States ----------------------------------------------------------------
function check_state_robbers(gulag)
	return 0
end

-- Check stalker ---------------------------------------------------------
function check_stalker_rob(npc_community, gulag_type, npc_rank, se_obj, stalker)
    return stalker
end


--------------------------------------------------------------------------
-- Bandits
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function lb_predicate1(data) 
	return data.profile_name == "val_bandit_borov"
end

function lb_predicate2(data) 
	return data.profile_name == "val_bandit_veteran"
end

function lb_predicate3(data) 
	return data.profile_name == "val_bandit_general"
end

-- Jobs ------------------------------------------------------------------
function load_job_lager_bandits(sj, gname, type, squad, groups)
    local i, v, j = 0, 0, 0
    local restr, gr, prior, rst = 0, 0, 0, 0

	-- БОРОВ
	t = { section = "logic@" .. gname .. "_leader_normal",
		idle = 0,
		prior = 9, state = {state_normal},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = gname .. "_borov_restrictor",
		predicate = lb_predicate1
	}
	table.insert(sj, t)

	t = { section = "logic@" .. gname .. "_leader_alarm",
		idle = 0,
		prior = 9, state = {state_alarm},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = gname .. "_borov_restrictor",
		predicate = lb_predicate1
	}
	table.insert(sj, t)

	t = { section = "logic@" .. gname .. "_leader_alarm",
		idle = 0,
		prior = 9, state = {state_alarm_actor_inside},
		squad = squad, group = groups[1],
		in_rest = "", out_rest = gname .. "_borov_restrictor",
		predicate = lb_predicate1
	}
	table.insert(sj, t)

	-- ОХРАННИКИ БОРОВА
    for i = 1, 3 do
	    t = { section = "logic@" .. gname .. "_bodyguard_normal" .. i,
		    idle = 0,
		    prior = 8, state = {state_normal},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_main_building_restrictor",
		    predicate = lb_predicate2
	    }
	    table.insert(sj, t)

	    t = { section = "logic@" .. gname .. "_bodyguard_alarm" .. i,
		    idle = 0,
		    prior = 8, state = {state_alarm},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_main_building_restrictor",
		    predicate = lb_predicate2
	    }
	    table.insert(sj, t)

	    t = { section = "logic@" .. gname .. "_bodyguard_alarm" .. i,
		    idle = 0,
		    prior = 8, state = {state_alarm_actor_inside},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_main_building_restrictor",
		    predicate = lb_predicate2
	    }
	    table.insert(sj, t)
    end

	-- СИДЯЩИЕ В КЕМПЕ 1 ВОЗЛЕ БОРОВА И В КЕМПЕ 2 НА ВТОРОМ ЭТАЖЕ
	restr = {gname .. "_main_building_restrictor", gname .. "_nedostroyka_restrictor", gname .. "_nedostroyka_restrictor"}
	local pr = {7, 7, 2}
	for i, v in pairs({3, 4, 2}) do
	    for j = 1, v do
	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_normal",
		        idle = 0,
		        prior = pr[i], state = {state_normal},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = restr[i],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)

	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_alarm" .. j,
		        idle = 0,
		        prior = pr[i], state = {state_alarm},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = restr[i],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)

	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_alarm" .. j,
		        idle = 0,
		        prior = pr[i], state = {state_alarm_actor_inside},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = restr[i],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)
	    end
	end

	-- БАНДИТЫ НА ВОРОТАХ
	restr =  {{gname .. "_main_side_restrictor", gname .. "_restrictor"},
	          {gname .. "_main_side_restrictor", gname .. "_restrictor", gname .. "_restrictor", gname .. "_restrictor"},
	          {gname .. "_restrictor", gname .. "_restrictor"},
	          {gname .. "_restrictor", gname .. "_restrictor", gname .. "_restrictor", gname .. "_restrictor"}}
	gr = {"guard", "patrol", "sniper", "sleeper"}
	prior =  {6, 5, 4, 3}
	for i, v in pairs({2, 4, 2, 4}) do
	    rst = restr[i]
	    for j = 1, v do
	        t = { section = "logic@" .. gname .. "_" .. gr[i] .. "_normal" .. j,
		        idle = 0,
		        prior = prior[i], state = {state_normal},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = rst[j],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)

	        t = { section = "logic@" .. gname .. "_" .. gr[i] .. "_alarm" .. j,
		        idle = 0,
		        prior = prior[i], state = {state_alarm},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = rst[j],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)

	        t = { section = "logic@" .. gname .. "_" .. gr[i] .. "_alarm" .. j,
		        idle = 0,
		        prior = prior[i], state = {state_alarm_actor_inside},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = rst[j],
		        predicate = lb_predicate3
	        }
	        table.insert(sj, t)
	    end
	end
end

-- States ----------------------------------------------------------------
function check_state_lager_bandits(gulag)
	for k,v in pairs(gulag.Object) do
	    if v ~= true then
		    local enemy = v:best_enemy()
		    if enemy ~= nil then
			    enemy_type = get_clsid(enemy)
			    if enemy_type == clsid.actor and
				    utils.npc_in_zone(db.actor, db.zone_by_name["val_lager_bandits_restrictor"]) then
				    return state_alarm_actor_inside
			    end
			    if enemy_type == clsid.actor or
  	   			    enemy_type == clsid.soldier or
	   			    enemy_type == clsid.script_stalker or
   				    enemy_type == clsid.trader
   			    then
   				    gulag.alarm_start = game.get_game_time()
   				    return state_alarm
   			    end
		    end
		end
	end		
	
	if gulag.alarm_start == nil or game.get_game_time():diffSec(gulag.alarm_start) > 900 then
		return state_normal -- обычное состояние
	end
	return state_alarm -- тревога
end


--------------------------------------------------------------------------
-- Monolith base
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------

-- Jobs ------------------------------------------------------------------
function load_job_monolith_base(sj, gname, type, squad, groups)
    local i, v, j
    local ltx = ""

    -- патрули
    for i = 1, 6 do
	    t = { section = "logic@" .. gname .. "_patrol_normal" .. i,
		    idle = 0,
		    prior = 4, state = {state_normal},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_main_building_restrictor"
	    }
	    table.insert(sj, t)        

        ltx = ltx.."[logic@" .. gname .. "_patrol_normal" .. i .. "]\n" ..
                   "active              = walker@" .. gname .. "_patrol_normal" .. i .. "\n" ..
                   --"combat_ignore       = combat_ignore\n" ..

                   "[walker@" .. gname .. "_patrol_normal" .. i .. "]\n" ..
                   "path_walk           = in_patrol_walk" .. i .. "\n" ..
                   "path_look           = in_patrol_look" .. i .. "\n" ..
                   "def_state_moving    = rush\n" --..
                   --"combat_ignore_cond  = {=val_fighting_captive}, {=fighting_actor +val_monolith_actor_detected} never, {=fighting_actor =actor_wears_bandit_outfit} always, {=fighting_actor} never %+val_monolith_actor_detected%\n"
    end

    local pr = {1, 1, 1, 3, 2}
    -- кемпы
    for i, v in pairs({4, 4, 4, 5, 4}) do
        for j = 1, v do
	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_normal",
		        idle = 0,
		        prior = pr[i], state = {state_normal},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = gname .. "_main_building_restrictor"
	        }
	        table.insert(sj, t)        
        end

        ltx = ltx.."[logic@" .. gname .. "_kamp" .. i .. "_normal]\n" ..
                   "active              = kamp@" .. gname .. "_kamp" .. i .. "_normal\n" ..
                   --"combat_ignore       = combat_ignore\n" ..

                   "[kamp@" .. gname .. "_kamp" .. i .. "_normal]\n" ..
                   "center_point        = in_kamp" .. i .. "\n" ..
                   "def_state_moving    = rush\n" --..
                   --"combat_ignore_cond  = {=val_fighting_captive}, {=fighting_actor +val_monolith_actor_detected} never, {=fighting_actor =actor_wears_bandit_outfit} always, {=fighting_actor} never %+val_monolith_actor_detected%\n"
    end

    gulags.val_monolith_base.ltx = ltx
end

-- States ----------------------------------------------------------------
function check_state_monolith_base(gulag)
	return state_normal
end

-- Check stalker ---------------------------------------------------------
function check_stalker_monolith_base(npc_community, gulag_type, npc_rank, se_obj, stalker)
    return stalker and se_obj:profile_name() == "val_monolith_regular"
end


--------------------------------------------------------------------------
-- War soldiers
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function ws_predicate(data)
    local pname = data.profile_name
	return pname == "val_soldier_regular" or pname == "val_soldier_specnaz"
end

-- Jobs ------------------------------------------------------------------
function load_job_war_soldiers(sj, gname, type, squad, groups)
    local i, v, j
    local ltx = ""

    -- патрули
    for i = 1, 6 do
        -- normal
	    t = { section = "logic@" .. gname .. "_patrol_normal" .. i,
		    idle = 0,
		    prior = 4, state = {state_normal},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_main_building_restrictor",
		    predicate = ws_predicate
	    }
	    table.insert(sj, t)
	    -- fight
	    t = { section = "logic@" .. gname .. "_fight1",
		    idle = 0,
		    prior = 4, state = {state_fight},
		    squad = squad, group = groups[1],
		    in_rest = "", out_rest = "val_monolith_base_war_restrictor",
		    predicate = ws_predicate
	    }
	    table.insert(sj, t)

        ltx = ltx.."[logic@" .. gname .. "_patrol_normal" .. i .. "]\n" ..
                   "active              = walker@" .. gname .. "_patrol_normal" .. i .. "\n" ..
                   "combat_ignore       = combat_ignore\n" ..

                   "[walker@" .. gname .. "_patrol_normal" .. i .. "]\n" ..
                   "path_walk           = in_patrol_walk" .. i .. "\n" ..
                   "path_look           = in_patrol_look" .. i .. "\n" ..
                   "def_state_moving    = rush\n" ..
                   "combat_ignore_cond  = {=check_fighting(410)}\n"
    end

    local pr = {1, 1, 1, 3, 2}
    -- кемпы
    for i, v in pairs({4, 4, 4, 5, 4}) do
        for j = 1, v do
            -- normal
	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_normal",
		        idle = 0,
		        prior = pr[i], state = {state_normal},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = gname .. "_main_building_restrictor",
		        predicate = ws_predicate
	        }
	        table.insert(sj, t)        
	        -- fight
	        t = { section = "logic@" .. gname .. "_fight" .. i ,
		        idle = 0,
		        prior = 1, state = {state_fight},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = "val_monolith_base_war_restrictor",
		        predicate = ws_predicate
	        }
	        table.insert(sj, t)
        end

        ltx = ltx.."[logic@" .. gname .. "_kamp" .. i .. "_normal]\n" ..
                   "active             = kamp@" .. gname .. "_kamp" .. i .. "_normal\n" ..
                   "combat_ignore      = combat_ignore\n" ..
                   
                   "[kamp@" .. gname .. "_kamp" .. i .. "_normal]\n" ..
                   "center_point       = in_kamp" .. i .."\n" ..
                   "def_state_moving   = rush\n" ..
                   "combat_ignore_cond = {=check_fighting(410)}\n" ..
                   
                   "[logic@" .. gname .. "_fight" .. i .. "]\n" ..
                   "active              = remark@" .. gname .. "_fight" .. i .. "\n" ..
                   "combat_ignore       = combat_ignore\n" ..

                   "[remark@" .. gname .. "_fight" .. i .. "]\n" ..
                   "center_point        = in_kamp" .. i .."\n" ..
                   "no_move             = true\n" ..
                   "combat_ignore_cond  = {=check_fighting(410)}\n"
    end

    gulags.val_war_soldiers.ltx = ltx
end

-- States ----------------------------------------------------------------
function check_state_war_soldiers(gulag)
	if db.actor:has_info("val_opendoor_chase_start") then
		return state_normal
	end
	return state_fight
end


--------------------------------------------------------------------------
-- Offline group
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------

-- Jobs ------------------------------------------------------------------
function load_job_offline_group(sj, gname, type, squad, groups)
    local i, it = 0, 1
    local ltx = ""
    local pname = "offgroup"
    local phdr = gname .. "_" .. pname .. "_"

	while true do
		local way_name = phdr .. it
		
		if not level.patrol_path_exists(way_name) then
            break
		end

		local ptr = patrol(way_name)
		local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
		local job_count, prior = 5, 1

		-- Необходимо вычитать количество работ из названия точки пути.
		if wp_prop.count ~= nil then
			job_count = wp_prop.count
		end

		if wp_prop.prior ~= nil then
			prior = wp_prop.prior
		end

		for i = 1, job_count do
			-- добавляем должность
			t = { section = "logic@" .. way_name,
				idle = 0,
				prior = prior, state = {0}, squad = squad, group = groups[1],
				position_threshold = 20, in_rest = "", out_rest = "",
				online = false
			}
			table.insert(sj, t)
		end

		-- добавляем описание должности в лтх.
		ltx = ltx .. "[logic@" .. way_name .. "]\n" ..
					 "active    = remark@" .. way_name .. "\n" ..

					 "[remark@" .. way_name .. "]\n" ..
					 "path_walk = " .. pname .. "_" .. it .. "\n" ..
					 "anim      = wait_na\n"
		it = it + 1
	end

    gulags.val_offline_group.ltx = ltx
end

-- States ----------------------------------------------------------------
function check_state_offline_group(gulag)
	return 0
end


-------------------------------------------------------------------------------------------------------------------------
gulags.val_escort.job           = load_job_escort
gulags.val_escort.state         = check_state_escort

gulags.val_sacrifice.job        = load_job_sacrifice
gulags.val_sacrifice.state      = check_state_sacrifice

gulags.val_prisoner.job         = load_job_prisoner
gulags.val_prisoner.state       = check_state_prisoner

gulags.val_rob.job              = load_job_robbers
gulags.val_rob.state            = check_state_robbers
gulags.val_rob.comm             = check_stalker_rob

gulags.val_lager_bandits.job    = load_job_lager_bandits
gulags.val_lager_bandits.state  = check_state_lager_bandits

gulags.val_monolith_base.job    = load_job_monolith_base
gulags.val_monolith_base.state  = check_state_monolith_base
gulags.val_monolith_base.comm   = check_stalker_monolith_base

gulags.val_war_soldiers.job     = load_job_war_soldiers
gulags.val_war_soldiers.state   = check_state_war_soldiers

gulags.val_offline_group.job    = load_job_offline_group
gulags.val_offline_group.state  = check_state_offline_group
----------------------------------
function check_state_offline_group(gulag)
	return 0
end


-------------------------------------------------------------------------------------------------------------------------
gulags.val_escort.job           = load_job_escort
gulags.val_escort.state         = check_state_escort

gulags.val_sacrifice.job        = load_job_sacrifice
gulags.val_sacrifice.state      = check_state_sacrifice

gulags.val_prisoner.job         = load_job_prisoner
gulags.val_prisoner.state       = check_state_prisoner

gulags.val_rob.job              = load_job_robbers
gulags.val_rob.state            = check_state_robbers
gulags.val_rob.comm             = check_stalker_rob

gulags.val_lager_bandits.job    = load_job_lager_bandits
gulags.val_lager_bandits.state  = check_state_lager_bandits

gulags.val_monolith_base.job    = load_job_monolith_base
gulags.val_monolith_base.state  = check_state_monolith_base
gulags.val_monolith_base.comm   = check_stalker_monolith_base

gulags.val_war_soldiers.job     = load_job_war_soldiers
gulags.val_war_soldiers.state   = check_state_war_soldiers

gulags.val_offline_group.job    = load_job_offline_group
gulags.val_offline_group.state  = check_state_offline_group
