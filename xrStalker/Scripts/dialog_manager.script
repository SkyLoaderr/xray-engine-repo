phrase = {
	intro = {},
	trade_info = {},
	action_info = {},
	cool_info = {},
	help_thanks = {}
	}

local phrase_ini = ini_file("misc\\dialog_manager.ltx")

local intro_id = 0
local cool_info_id = 0
local action_info_id = 0
local trade_info_id = 0
local trade_info_price = {}
local help_thanks_id = 0
local phrase_table_filled = false

function get_id(type)
	if type == "intro" then
		intro_id = intro_id + 1
		return intro_id
	elseif type == "cool_info" then
		cool_info_id = cool_info_id + 1
		return cool_info_id
	elseif type == "action_info" then
		action_info_id = action_info_id + 1
		return action_info_id
	elseif type == "trade_info" then
		trade_info_id = trade_info_id + 1
		return trade_info_id
	elseif type == "help_thanks" then
		help_thanks_id = help_thanks_id + 1
		return help_thanks_id
	else
		abort("Dialog manager error: unknown GET_ID() type")
	end
end

-- Необходимо сформировать набор предикатов  table[string_id] = predicate()
function fill_phrase_table()
	-- Итерируемся по всем настройкам фраз
	if not phrase_ini:section_exist("list") then
		abort("There is no section [list] in dialog_manager.ltx")
	end
	local n = phrase_ini:line_count("list")
	local id, value = "",""
	local category = ""
	
	for i=0,n-1 do
		result, id, value	= phrase_ini:r_line("list",i,"","")
		
		if not phrase_ini:section_exist(id) then
			abort("There is no section [%s] in dialog_manager.ltx", id)
		end		
		-- 2. Необходимо сформировать набор предикатов  table[string_id] = predicate()
		if not phrase_ini:line_exist(id, "category") then
			abort("Dialog manager error: not categoried section [%s]", id)
		end
		category = phrase_ini:r_string(id, "category")
		local tt = {}
		tt.name = id
		if phrase_ini:line_exist(id, "community") then
			tt.community = phrase_ini:r_string(id, "community")
		end
		if phrase_ini:line_exist(id, "npc_community") then
			tt.npc_community = phrase_ini:r_string(id, "npc_community")
		end
		if phrase_ini:line_exist(id, "relation") then
			tt.relation = phrase_ini:r_string(id, "relation")
		end
		if phrase_ini:line_exist(id, "npc_rank") then
			tt.npc_rank = phrase_ini:r_u32(id, "npc_rank")
		end
		if phrase_ini:line_exist(id, "level") then
			tt.level = phrase_ini:r_string(id, "level")
		end
		if phrase_ini:line_exist(id, "condlist") then
			tt.condlist = xr_logic.parse_condlist(db.actor, "dialog_manager", "condlist", phrase_ini:r_string(id, "condlist"))
		end
		if phrase_ini:line_exist(id, "smart_terrain") then
			tt.smart_terrain = phrase_ini:r_string(id, "smart_terrain")
		end					
		if phrase_ini:line_exist(id, "cost") then
			tt.price = phrase_ini:r_u32(id, "cost")
		end					
		if phrase_ini:line_exist(id, "article_info") then
			tt.article_info = parse_names(phrase_ini:r_string(id, "article_info"))
		end					
		if phrase_ini:line_exist(id, "wounded") then
			tt.wounded = phrase_ini:r_string(id, "wounded")
		else
			tt.wounded = "false"
		end
		table.insert(phrase[category], tt)
	end
	
	-- Надо отсортировать phrase.trade_info по уменьшению стоимости.
	table.sort(phrase.trade_info, function(a,b) return a.price > b.price end)
end

-- Необходимо создать стартовый диалог, с разветвлением на третьем уровне, где каждая фраза будет иметь
-- одну и ту же функцию в прекондишне
function init_intro_dialog(dlg)
	if phrase_table_filled == false then
		fill_phrase_table()
		phrase_table_filled = true
	end

	local phr = dlg:AddPhrase("",0,-1,-10000)
		phr = dlg:AddPhrase("",get_id("intro"),0,-10000)

	local k,v = 0,0
	for k,v in pairs(phrase.intro) do
		v.phr_id = get_id("intro")
		phr = dlg:AddPhrase(v.name, v.phr_id, 1, -10000)
		
		if phr then
			local phrase_script = phr:GetPhraseScript()
			phrase_script:AddPrecondition("dialog_manager.precondition_intro")
			--' Этот экшн запоминает последнюю фразу, чтобы персонаж говорил одно и то же.
			--' Для фразы просьбы о помощи его добавлять не надо.
			if v.wounded == "false" then
				phrase_script:AddAction("dialog_manager.phrase_action_intro")		
			end
		end
	end
--	phrase_script:AddPrecondition("zzz")
--	phrase_script:AddHasInfo("zzz")
--	phrase_script:AddDontHasInfo("zzz")
--	phrase_script:AddGiveInfo("zzz")
--	phrase_script:AddDisableInfo("zzz")
--	phrase_script:AddAction("zzz")
end

-- Необходимо создать диалог актера, с разветвлением на втором уровне, где каждая фраза будет иметь
-- одну и ту же функцию в прекондишне.
function init_cool_info_dialog(dlg)
	if phrase_table_filled == false then
		fill_phrase_table()
		phrase_table_filled = true
	end

	local phr = dlg:AddPhrase("dm_general_cool_info",0,-1,-10000)
	
	local k,v,kk,vv = 0,0,0,0
	for k,v in pairs(phrase.cool_info) do
		local last_id = get_id("cool_info")
		v.phr_id = last_id
		phr = dlg:AddPhrase(v.name,last_id,0,-10000)		
		if phr then
			local phrase_script = phr:GetPhraseScript()
			phrase_script:AddPrecondition("dialog_manager.precondition_cool_info")
			phrase_script:AddAction("dialog_manager.phrase_action_cool_info")
			
			if v.article_info ~= nil then
				phr = dlg:AddPhrase("",get_id("cool_info"),last_id,-10000)		
				phrase_script = phr:GetPhraseScript()
								
				for kk,vv in pairs(v.article_info) do
					phrase_script:AddGiveInfo(vv)
				end
			end
		end
	end
end

-- Необходимо создать диалог актера, с разветвлением на втором уровне, где каждая фраза будет иметь
-- одну и ту же функцию в прекондишне.
function init_action_info_dialog(dlg)
	if phrase_table_filled == false then
		fill_phrase_table()
		phrase_table_filled = true
	end

	local phr = dlg:AddPhrase("dm_general_action_info",0,-1,-10000)
	
	local k,v,kk,vv = 0,0,0,0
	for k,v in pairs(phrase.action_info) do
		local last_id = get_id("action_info")
		v.phr_id = last_id
		phr = dlg:AddPhrase(v.name,last_id,0,-10000)		
		if phr then
			local phrase_script = phr:GetPhraseScript()
			phrase_script:AddPrecondition("dialog_manager.precondition_action_info")
			phrase_script:AddAction("dialog_manager.phrase_action_action_info")
			
			if v.article_info ~= nil then
				phr = dlg:AddPhrase("",get_id("action_info"),last_id,-10000)		
				phrase_script = phr:GetPhraseScript()
				
				local article_info = parse_names(v.article_info)
				for kk,vv in pairs(article_info) do
					phrase_script:AddGiveInfo(vv)
				end
			end
		end
	end
end

-- Необходимо создать диалог актера, с разветвлением на втором уровне, где каждая фраза будет иметь
-- одну и ту же функцию в прекондишне.
function init_trade_info_dialog(dlg)
	if phrase_table_filled == false then
		fill_phrase_table()
		phrase_table_filled = true
	end

	local phr = dlg:AddPhrase("dm_general_trade_info",0,-1,-10000)
	local phrase_script = phr:GetPhraseScript()
	phrase_script:AddAction("dialog_manager.action_trade_info_init")

	phr = dlg:AddPhrase("dm_general_trade_info_caption",get_id("trade_info"),0,-10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddAction("dialog_manager.action_trade_info_show")
	phrase_script:AddPrecondition("dialog_manager.precondition_can_trade_info")
		
	phr = dlg:AddPhrase("dm_general_trade_info_hasno",get_id("trade_info"),0,-10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddPrecondition("dialog_manager.precondition_cannot_trade_info")
	
	-- Изначально считаем что каждый сталкер знает ВСЮ информацию. Не забыть потом
	-- вставить инфопоршн, что сталкер сам знает информацию
	local k,v,kk,vv = 0,0,0,0
	for k,v in pairs(phrase.trade_info) do
		local phrase_id = get_id("trade_info")
		phr = dlg:AddPhrase(v.name,phrase_id,1,-10000)		
		if phr then
			phrase_script = phr:GetPhraseScript()
			phrase_script:AddPrecondition("dialog_manager.precondition_trade_info")
			phrase_script:AddAction("dialog_manager.action_transfer_money")
			trade_info_price[phrase_id] = v.price
			
			if v.article_info ~= nil then
				for kk,vv in pairs(v.article_info) do
					phrase_script:AddGiveInfo(vv)
				end
			end
		end
	end
	dlg:AddPhrase("dm_general_trade_info_nothing",get_id("trade_info"),1,-10000)
end

-- Диалоги помощи раненным
function init_help_wounded_medkit_dialog(dlg)
	if phrase_table_filled == false then
		fill_phrase_table()
		phrase_table_filled = true
	end

	local phr = dlg:AddPhrase("dm_general_help_medkit",0,-1,-10000)
	local phrase_script = phr:GetPhraseScript()
	phrase_script:AddAction("dialogs.transfer_medkit")
	
	local k,v = 0,0
	for k,v in pairs(phrase.help_thanks) do
		phr = dlg:AddPhrase(v.name,get_id("help_thanks"),0,-10000)		
		if phr then
			phrase_script = phr:GetPhraseScript()
			phrase_script:AddPrecondition("dialog_manager.precondition_help_thanks")
		end
	end
end

local call_count, max_count = 0,0
local tmp_tbl = {}
local show_tbl = {}
function action_trade_info_init(npc, actor)
	local value, number, max_number = 0,0,0
	local k,v = 0,0
	max_count = 0
	show_tbl = {}
	for k,v in pairs(phrase.trade_info) do	
		value, number = calculate_predicate(npc, v)
		max_count = max_count + 1
		if value == true then
			table.insert(show_tbl, k)
			-- отмечаем что игрок может купить данный товар
			tmp_tbl[max_count] = true
		elseif calculate_predicate(npc, v, {no_price = true}) == true then
			table.insert(show_tbl, k)
		end		
	end
	--printf("TRADE INIT [%s] [%s]", tostring(call_count), tostring(max_count))
end
function action_trade_info_show(npc, actor)
	local k,v = 0,0
	for k,v in pairs(show_tbl) do
		db.actor:give_talk_message(game.translate_string(phrase.trade_info[v].name), "ui\\ui_icons_task", Frect():set(350,150,50,50),"iconed_trade_info")
	end
end
function precondition_trade_info(actor, npc)
	call_count = call_count + 1
	--printf("TRADE Prec [%s] [%s]", tostring(call_count), tostring(max_count))
	if call_count < max_count then
		-- При повторном вызове прекондишна (счетчик вызовов не равен количеству сработанных предикатов) 
		-- всегда возвращаем FALSE, кроме случая, что счетчик равен ранее запомненному порядковому номеру вызова.
		return tmp_tbl[call_count] == true
	elseif call_count >= max_count then
		-- Как только счетчик дошел до конца - обнуляем все счетчики. Выбор произведен.
		local return_value = tmp_tbl[call_count] == true
		tmp_tbl = {}
		call_count, max_count = 0,0
		return return_value
	end
	abort("Dialog manager error: unexpected programm point. Trade Info")
end
function precondition_can_trade_info(npc, actor)
	return table.getn(show_tbl) > 0
end
function precondition_cannot_trade_info(npc, actor)
	return table.getn(show_tbl) == 0
end
function action_transfer_money(actor, npc, p1, p2)
	printf("TRADE TRANSFER MONEY [%s] [%s] [%s] [%s]", actor:name(), npc:name(), tostring(p1), tostring(p2))
	dialogs.relocate_money(npc, trade_info_price[p2], "out")
end

selected_phrase_by_id = {
	intro = {},
	cool_info = {},
	action_info = {}
}

function phrase_action_intro(npc, actor, p1, p2)
	phrase_action(npc, actor, selected_phrase_by_id.intro, p2)
end
function phrase_action_cool_info(npc, actor, p1, p2)
	phrase_action(npc, actor, selected_phrase_by_id.cool_info, p2)
end
function phrase_action_action_info(npc, actor, p1, p2)	
	phrase_action(npc, actor, selected_phrase_by_id.action_info, p2)
end

function phrase_action(npc, actor, sel_tbl, p2)
	sel_tbl[npc:id()] = p2
end


function precondition_intro(npc, actor)
	return precondition(npc, actor, phrase.intro, selected_phrase_by_id.intro)
end
function precondition_cool_info(npc, actor)
	return precondition(npc, actor, phrase.cool_info, selected_phrase_by_id.cool_info)
end
function precondition_action_info(npc, actor)
	return precondition(npc, actor, phrase.action_info, selected_phrase_by_id.action_info)
end
function precondition_help_thanks(npc, actor)
	return precondition(npc, actor, phrase.help_thanks)
end

function precondition(npc, actor, tbl, sel_tbl)
	local k,v = 0,0
	--' При первом вызове прекондишна пробегаемся по таблице предикатов и определяем количество предикатов,
	--' которые возвращают TRUE. Определяется из них фраза, охватывающая самую узкую ситуацию (по количеству
	--' проверяемых функций в условии. Ее порядковый номер запоминается.
	if call_count == 0 then
		local value, number, max_number = 0,0,0
		
		--' Надо проверить доступна ли запомненная фраза
		if sel_tbl ~= nil and sel_tbl[npc:id()] ~= nil then
			for k,v in pairs(tbl) do
				if sel_tbl[npc:id()] == v.phr_id then
					value, number = calculate_predicate(npc, v)	
					--' Если запомненная фраза недоступна - необходимо забыть ее
					if value == false then
						printf("*** restore memory phrase")
						sel_tbl[npc:id()] = nil
						break
					end
				end
			end		
		end	
	
		for k,v in pairs(tbl) do
			value, number = calculate_predicate(npc, v)			
			max_count = max_count + 1
			printf("*** count = %s value = %s number = %s phr_id = %s", max_count, tostring(value), number, v.name)

			--' Проверка на повторяемость фраз.
			if sel_tbl ~= nil and sel_tbl[npc:id()] ~= nil then
				--' Если проверяется запомненная фраза
				if sel_tbl[npc:id()] ~= v.phr_id then
					printf("*** not memory phrase [%s] ~= [%s]", sel_tbl[npc:id()], v.phr_id)
					value = false
				end		
			end	

			if value == true then
				if number > max_number then
					max_number = number
					tmp_tbl = {}
				end
				if number == max_number then
					tmp_tbl[max_count] = true
				end								
			end
		end
	end
	
	call_count = call_count + 1
	return_value = tmp_tbl[call_count] == true
	
	printf("  callcount = %s value = %s", call_count, tostring(return_value))
	if call_count < max_count then
		--' При повторном вызове прекондишна (счетчик вызовов не равен количеству сработанных предикатов) 
		--' всегда возвращаем FALSE, кроме случая, что счетчик равен ранее запомненному порядковому номеру вызова.
		return return_value
	elseif call_count == max_count then
		--' Как только счетчик дошел до конца - обнуляем все счетчики. Выбор произведен.
		tmp_tbl = {}
		call_count, max_count = 0,0
		return return_value
	end
	abort("Dialog manager error: unexpected programm point")
end

function calculate_predicate(npc, tbl, settings)
	local property_num = 0
	local k,v = 0,0
	if tbl.community ~= nil then
		if tbl.community ~= db.actor:character_community() then return false,0 end
		property_num = property_num + 1		
	end
	if tbl.npc_community ~= nil then
		if tbl.npc_community ~= npc:character_community() then return false,0 end
		property_num = property_num + 1		
	end
	if tbl.relation ~= nil then
		if (tbl.relation == "friend" and npc:relation(db.actor) ~= game_object.friend) or
		   (tbl.relation == "neutral" and npc:relation(db.actor) ~= game_object.neutral) or
		   (tbl.relation == "enemy" and npc:relation(db.actor) ~= game_object.enemy)
		then 
			return false,0 
		end
		property_num = property_num + 1		
	end
	if tbl.npc_rank ~= nil then
		if tbl.npc_rank > npc:character_rank() then return false,0 end
		property_num = property_num + 1		
	end
	if tbl.level ~= nil then
		if tbl.level ~= level.name() then return false,0 end
		property_num = property_num + 1		
	end
	if tbl.condlist ~= nil then
		if xr_logic.pick_section_from_condlist(db.actor, db.actor, tbl.condlist) ~= "true" then return false,0 end
		property_num = property_num + table.getn(tbl.condlist.infop_check)
	end
	if tbl.smart_terrain ~= nil then
		if tbl.smart_terrain ~= xr_gulag.isUnderFraction(npc) then return false,0 end
		property_num = property_num + 1		
	end
	if tbl.wounded ~= nil then
		if tbl.wounded == "true" and not
		   (xr_wounded.is_wounded(npc) or
		    xr_wounded.is_heavy_wounded_by_id(npc:id()) or
		    xr_wounded.is_psy_wounded_by_id(npc:id()))
		then
			return false,0
		end
		if tbl.wounded == "false" and
		   (xr_wounded.is_wounded(npc) or
		    xr_wounded.is_heavy_wounded_by_id(npc:id()) or
		    xr_wounded.is_psy_wounded_by_id(npc:id()))
		then
			return false,0
		end
		property_num = property_num + 1		
	end
	if tbl.price ~= nil then
		if (db.actor:money() < tbl.price) and
		   (settings == nil or settings.no_price ~= true) 
		then
			return false,0 
		end
		
		if tbl.article_info ~= nil then
			for k,v in pairs(tbl.article_info) do
				if db.actor:has_info(v) then
					return false,0
				end
			end				
		end
	end
	
	return true, property_num
end
		

function precondition_info_global(actor, npc)
	if xr_wounded.is_wounded(npc) or
	   xr_wounded.is_heavy_wounded_by_id(npc:id()) or
	   xr_wounded.is_psy_wounded_by_id(npc:id())
	then
		return false
	end
	return true
end


	
--' Сохранение информации о выбранных фразах
function save(npc, p)
	if selected_phrase_by_id.intro[npc:id()] == nil then
		p:w_s32(-1)
	else
		p:w_s32(selected_phrase_by_id.intro[npc:id()])
	end
	if selected_phrase_by_id.cool_info[npc:id()] == nil then
		p:w_s32(-1)
	else
		p:w_s32(selected_phrase_by_id.cool_info[npc:id()])
	end
	if selected_phrase_by_id.action_info[npc:id()] == nil then
		p:w_s32(-1)
	else
		p:w_s32(selected_phrase_by_id.action_info[npc:id()])
	end	
end
function load(npc, reader)
	if selected_phrase_by_id == nil then
		selected_phrase_by_id = {
			intro = {},
			cool_info = {},
			action_info = {}
		}
	end
	local flag = reader:r_s32()
	if flag ~= -1 then
		selected_phrase_by_id.intro[npc:id()] = flag
	else
		selected_phrase_by_id.intro[npc:id()] = nil
	end
	flag = reader:r_s32()
	if flag ~= -1 then
		selected_phrase_by_id.cool_info[npc:id()] = flag
	else
		selected_phrase_by_id.cool_info[npc:id()] = nil
	end
	flag = reader:r_s32()
	if flag ~= -1 then
		selected_phrase_by_id.action_info[npc:id()] = flag
	else
		selected_phrase_by_id.action_info[npc:id()] = nil
	end
end



-- Функция рандомной загрузки информации на продажу.
-- Загружает в чувака на выбор 3-5 различных информаций из доступных ему.
function load_trade_info(npc)
end