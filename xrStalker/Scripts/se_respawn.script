--[[------------------------------------------------------------------------------------------------------------------
Respawner. Схема обновления популяции всего всего всего в симуляции.
by Stohe (Диденко Руслан)
--------------------------------------------------------------------------------------------------------------------]]

local section_name = "respawn"
local i,k,v = 0,0,0

local respawn_ini = system_ini()

-- Таблица ограничений на спаун: всего в симуляции не должно быть больше, чем указано.
local simMaxCount = {
	stalker_novice = 43, stalker_regular = 48, stalker_veteran = 27, stalker_master = 20,
	monolith_novice = 0, monolith_regular = 26, monolith_veteran = 34, monolith_master = 26,
	military_novice = 0, military_regular = 32, military_veteran = 22, military_master = 0,
	killer_novice = 0, killer_regular = 15, killer_veteran = 15, killer_master = 10,
	ecolog_novice = 0, ecolog_regular = 0, ecolog_veteran = 0, ecolog_master = 0,
	dolg_novice = 0, dolg_regular = 24, dolg_veteran = 36, dolg_master = 17,
	freedom_novice = 50, freedom_regular = 20, freedom_veteran = 26, freedom_master = 21,
	bandit_novice = 40, bandit_regular = 50, bandit_veteran = 15, bandit_master = 10,
	zombied_novice = 12, zombied_regular = 15, zombied_veteran = 10, zombied_master = 6,
	
	rat_weak = 0,	
	tushkano_weak = 40,
	flesh_weak = 5, flesh_normal = 5, flesh_strong = 5,
	boar_weak = 52, boar_normal = 38, boar_strong = 27,
	dog_weak = 48, dog_normal = 126, dog_strong = 45,
	pseudodog_weak = 59, pseudodog_normal = 80, pseudodog_strong = 40,
	psy_dog_weak = 5, psy_dog_normal = 5, psy_dog_strong = 5,
	zombie_weak = 5, zombie_normal = 5, zombie_strong = 5,
	snork_weak = 50, snork_normal = 61, snork_strong = 0,
	poltergeist_weak = 8,
	pseudo_gigant_weak = 18,
	controller_weak = 17,
	burer_weak = 10,
	bloodsucker_weak = 7, bloodsucker_normal = 14, bloodsucker_strong = 8	
}

-- Таблица для кеширования свойств секций респавна.
local sectSpawnProps = {}

----------------------------------------------------------------------------------------------------------------------
-- Разные полезные функции
----------------------------------------------------------------------------------------------------------------------
function r_bool( spawn_ini, section, line, default )
	if spawn_ini:line_exist( section, line ) then
		return spawn_ini:r_bool( section, line )
	else
		return default
	end
end

function r_str( spawn_ini, section, line, default )
	if spawn_ini:line_exist( section, line ) then
		return spawn_ini:r_string( section, line )
	else
		return default
	end
end

function r_num( spawn_ini, section, line, default )
	if spawn_ini:line_exist( section, line ) then
		return spawn_ini:r_float( section, line )
	else
		return default
	end
end

function r_2nums( spawn_ini, section, line, def1, def2 )
	if spawn_ini:line_exist( section, line ) then
		-- если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
		local t = parse_nums( spawn_ini:r_string( section, line ) )
		local n = table.getn( t )

		if n == 0 then
			return def1, def2
		elseif n == 1 then
			return t[1], def2
		else
			return t[1], t[2]
		end
	else
		return def1, def2
	end
end

function parse_names( s )
    local t = {}
    for name in string.gfind( s, "([%w_.\\]+)%p*" ) do
        table.insert( t, name )
    end
    return t
end

function r_spawns( spawn_ini, section, line)
	if spawn_ini:line_exist( section, line ) then
		-- если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
		local t = parse_names( spawn_ini:r_string( section, line ) )
		local n = table.getn( t )
		
		local ret_table = {}
		local k = 1
		while k <= n do
			local spawn = {}
			spawn.section = t[k]
			-- Проверяем что это не последняя запись
			if t[k+1] ~= nil then
				local p = tonumber(t[k+1])
				-- проверяем что вторым числом задана вероятность, а не другая секция спавну
				if p then
					-- забиваем число
					spawn.prob = p
					k = k + 2
				else
					-- забиваем дефолт 1
					spawn.prob = 1
					k = k + 1
				end
			else
				spawn.prob = 1
				k = k + 1
			end
			table.insert(ret_table, spawn)
	
			-- Вычитываем настройки секций респавна и кешируем их.
			if sectSpawnProps[spawn.section] == nil then
				local community = r_str(respawn_ini, spawn.section, "community", "nil")
				local rank = r_str(respawn_ini, spawn.section, "spec_rank", "nil")
				sectSpawnProps[spawn.section] = {community = community, rank = rank}
			end
						
		end
		return ret_table
	end
	return nil
end
----------------------------------------------------------------------------------------------------------------------
-- Серверный объект спавнера
----------------------------------------------------------------------------------------------------------------------
class "se_respawn" ( cse_alife_smart_zone )
function se_respawn:__init( section ) super( section )
	self.spawned_obj = {}

	self.proxy_initialized = false
end
-- сохранение
function se_respawn:STATE_Write( packet )
	cse_alife_smart_zone.STATE_Write( self, packet )

	local table_size = table.getn(self.spawned_obj)
--	printf("SPAWNER SAVE table_size[%d]", table_size)
--	print_table(self.spawned_obj)
	
	packet:w_u8(table_size)
	for i=1,table_size do
		packet:w_u16(self.spawned_obj[i])
	end
end
-- восстановление
function se_respawn:STATE_Read( packet, size )
	cse_alife_smart_zone.STATE_Read( self, packet, size )
	
	if editor() then
		return
	end

	local table_size = packet:r_u8()
	for i=1,table_size do
		table.insert(self.spawned_obj, packet:r_u16())
	end

--	printf("SPAWNER READ table_size[%d]", table_size)
--	print_table(self.spawned_obj)	
end
-- инициализация объекта.
-- вызывается симулятором.
function se_respawn:on_register()
	cse_alife_smart_zone.on_register( self )
	printf("RESPAWN: [%s] se_respawn on_register", tostring(self:name()))

	-- Вычитываем настройки спауна
	local ini = self:spawn_ini()
	if not ini:section_exist(section_name) then
		return	
	end
	
	self.respawn_section = r_spawns(ini, section_name, "respawn_section")
	print_table(self.respawn_section)
	if self.respawn_section == nil then
		abort("RESPAWN: [%s] field 'respawn_section' doesn't exist.", self:name())
	end

	self.min_count = r_num(ini, section_name, "min_count", 0)
	self.max_count = r_num(ini, section_name, "max_count", -1)
	if self.min_count > self.max_count and
	   self.max_count ~= -1 
	then
		abort("RESPAWN: [%s] min_count > max_count", self:name())
	end
	
	self.max_spawn = r_num(ini, section_name, "max_spawn", 1)
	self.idle_spawn_min, self.idle_spawn_max = r_2nums(ini, section_name, "idle_spawn")
	if self.idle_spawn_min == nil then
		abort("RESPAWN: [%s] field 'idle_spawn' doesn't exist.", self:name())
	end
	if self.idle_spawn_max == nil then
		self.idle_spawn_max = self.idle_spawn_min
	end
	self.conditions = xr_logic.parse_condlist(self, section_name, "conditions", r_str(ini, section_name, "conditions", 100))
	self.respawn_online = r_bool(ini, section_name, "respawn_online", false)
	
	self.respawn_radius = r_num(ini, section_name, "respawn_radius", 150)
	
	-- производим первичную инициализацию
	self.respawn_time = game.CTime()
end
-- Создаем объект
function se_respawn:create(prob)
	if tostring(prob) == "nil" then		
		print_table(self.conditions)
		abort("RESPAWN[%s]spawn probability doesn't set", tostring(self:name()))
		prob = 0
	end
	
	if math.random(100) <= tonumber(prob) then
		local spawn_section = ""
		local sum = 0
		-- Производим рандомную взвешенную выборку
		-- с учетом уже заспавленного количества человек.
		for k,v in pairs(self.respawn_section) do
			local tt = sectSpawnProps[v.section]
			local community_rank = tt.community.."_"..tt.rank
			local s_count = simMaxCount[community_rank]
			if s_count == nil then
				s_count = 0
			end
			if sim_statistic.simNpcCount(tt.community, tt.rank) < s_count then	
				sum = sum + v.prob
			end
		end
		sum = math.random(0, sum)
		for k,v in pairs(self.respawn_section) do
			local tt = sectSpawnProps[v.section]
			local community_rank = tt.community.."_"..tt.rank
			local s_count = simMaxCount[community_rank]
			if s_count == nil then
				s_count = 0
			end			
			if sim_statistic.simNpcCount(tt.community, tt.rank) < s_count then	
				sum = sum - v.prob			
				if sum <= 0 then
					spawn_section = v.section
					break
				end
			end
		end
		
		if spawn_section == "" then
			printf("SPAWNING [%s], CANT SPAWN, SIMULATION POPULATION EXCEED", tostring(self:name()))
			return false
		end
		
		local obj = alife():create(spawn_section,	
						self.position,
						self.m_level_vertex_id,	
						self.m_game_vertex_id)

		obj:brain():update()						
		local smart_terrain_id = obj:smart_terrain_id()
		if smart_terrain_id ~= 65535 then
			table.insert(self.spawned_obj ,obj.id)
			local pos = obj.position
			printf("SPAWNING [%s] -> [%s], position [%s][%s][%s]", tostring(self:name()), spawn_section, pos.x, pos.y, pos.z)
			return true
		else
			alife():release(obj, true)
			printf("SPAWNING [%s] -> [%s], CANT SPAWN. NO SMART_TERRAIN AVAILABLE!!!", tostring(self:name()), spawn_section)
			return false
		end																		
	end
end
-- Попытка спаунить объекты. Анализируется сколько уже заспавнено и выбирается один из механизмов - либо 
-- мы доспавниваем до минимального количества, либо спавним с заданной вероятностью
function se_respawn:spawn()
	printf("RESPAWN: [%s] spawn execute", tostring(self:name()))
	
	-- Пробегаемся по списку уже заспавненных объектов и удаляем из них мертвые либо уничтоженные.
	for k,v in pairs(self.spawned_obj) do
		local obj = level.object_by_id(v)
		if obj == nil then
			obj = alife():object(v)
		end
		
		if obj ~= nil then
			if obj:alive() ~= true then
				table.remove(self.spawned_obj, k)
			end
		else
			table.remove(self.spawned_obj, k)
		end
	end	

	if xr_logic.pick_section_from_condlist(db.actor_proxy, self, self.conditions) == "0" then
		return
	end
	
	-- экстренный спаун минимального количества объектов
	if table.getn(self.spawned_obj) < self.min_count then	
		while table.getn(self.spawned_obj) < self.min_count do
			if self:create(100) == false then
				return
			end
		end
		return
	end
	
	-- делаем несколько попыток заспаунить объект.
	for i=1,self.max_spawn do		
		if table.getn(self.spawned_obj) >= self.max_count then
			return
		end		
		if self:create(xr_logic.pick_section_from_condlist(db.actor_proxy, self, self.conditions)) == false then
			return
		end
	end		
end
-- Обновление респавнера. В зависимости от настроек обновляется либо только в офлайне, либо и там и там.
function se_respawn:execute()
	--printf("RESPAWN: [%s] se_respawn execute", tostring(self:name()))
	
	if self.respawn_time < game.get_game_time() then
		if not self.proxy_initialized then
			db.actor_proxy:init()
			self.proxy_initialized = true
		end

		local idle_time = game.CTime()
		idle_time:setHMSms( 0, 0, 0, math.random(self.idle_spawn_min, self.idle_spawn_max)*1000)
		self.respawn_time = game.get_game_time() + idle_time
		-- Производим попытку заспаунить объекты		
		self:spawn()
		
		printf("spawn_count = %s", table.getn(self.spawned_obj))
	end
end
-- Обновление в офлайне
function se_respawn:update()
	cse_alife_smart_zone.update( self )
	--printf("RESPAWN: [%s] se_respawn update_offline", tostring(self:name()))
	self:execute()
end
-- Обновление в онлайне
function se_respawn:update_online()
	cse_alife_smart_zone.update( self )
	--printf("RESPAWN: [%s] se_respawn update_online", tostring(self:name()))
	if db.actor:position():distance_to (self.position) >= self.respawn_radius then
		self:execute()
	end
end