--[[------------------------------------------------------------------------------------------------------------------
Smart Terrain (места, где сталкеры могут оседать на некоторое время и заниматься чем-то)
Чугай Саша
!без симуляции не работает!

Сделать:
	- разные умолчания для разных типов гулагов
	- критерии checkNpc в custom_data
	- роспуск гулага по infoprtions
	+ npc community в offline
	+ флажок в custom data "offline=true/false"
	- сталкеры должны ходить в офлайн/онлайн под гулагом
	- проверка умерших в offline
	+ переделать gulag на id и client_spawn_manager
	+ switch_offline, move_offline
	+ затычка gulag для офлайна
	+ доделать и переименовать онлайновую часть
	+ printf
	+ передача параметров offline->online
	+ передача параметров online->offline
	+ [zone] перерименовать [smart_terrain], "зона" -> "smart terrain"
	+ spawn_ini у серверного сталкера
	+ установка squad, group у серверного
	+ сохранение и восстановление серверного объекта
	+ the_actor при reload
	- script_version

	- монстры

Идеи:
	- дополнительные условия начала, конца smart_terrain. Например, ночь и день
	- дополнительные условия ухода сталкеров
	- специальные диалоги

--------------------------------------------------------------------------------------------------------------------]]

local h2ms = 60 * 60 * 1000

local check_period, CTime_0

if not editor() then
	check_period = game.CTime()
	check_period:setHMSms( 0, 0, 0, 50000 )

	CTime_0 = game.CTime()
end

local the_actor, n, ini, sect, g, gi, ggi, o, oT, o_id, sim, t

----------------------------------------------------------------------------------------------------------------------
-- Разные полезные функции
----------------------------------------------------------------------------------------------------------------------
function printf(fmt,...)
	log(string.format(fmt,unpack(arg)))
end

-- парсит строку вида "ааа, ббб, ввв..." в таблицу { "ааа", "ббб", "ввв", ... }
-- Чугай
function parse_names( s )
	local t = {}

	for name in string.gfind( s, "([%w_\\]+)%p*" ) do
		table.insert( t, name )
	end

	return t
end

-- парсит строку вида "n1, n2, n3..." в таблицу { n1, n2, n3, ... } где n1, n2, n3... - дробные числа
-- Чугай
function parse_nums( s )
	local t = {}

	for entry in string.gfind( s, "([%d%.]+)%,*" ) do
		table.insert( t, tonumber( entry ) )
	end

	return t
end

-------------- помощники для чтения ini (custom data) -------------------
function r_str( spawn_ini, section, line, default )
	if spawn_ini:line_exist( section, line ) then
		return spawn_ini:r_string( section, line )
	else
		return default
	end
end

function r_num( spawn_ini, section, line, default )
	if spawn_ini:line_exist( section, line ) then
		return spawn_ini:r_float( section, line )
	else
		return default
	end
end

function r_nums( spawn_ini, section, line, ... )
	if spawn_ini:line_exist( section, line ) then
		-- если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
		local t = parse_nums( spawn_ini:r_string( section, line ) )
		local n = table.getn( t )

		if n == 0 then
			return unpack( arg )
		end

		while table.getn( t ) < arg.n do
			table.insert( t, t[n] )
		end

		return unpack( t )
	else
		return unpack( arg )
	end
end

-- запись CTime в пакет. если t=nil, то запишет один нулевой байт
function w_CTime( p, t )
	if t and not (t == CTime_0) then
		local Y, M, D, h, m, s, ms = 0, 0, 0, 0, 0, 0, 0
		Y, M, D, h, m, s, ms = t:get( Y, M, D, h, m, s, ms )

		p:w_u8 ( Y - 2000 )
		p:w_u8 ( M )
		p:w_u8 ( D )
		p:w_u8 ( h )
		p:w_u8 ( m )
		p:w_u8 ( s )
		p:w_u16( ms )
	else
		p:w_u8 ( 0 )
	end
end

-- чтение CTime из пакета
function r_CTime( p )
	local Y = p:r_u8()

	if Y ~= 0 then
		local t = game.CTime()
		t:set( Y + 2000, p:r_u8(), p:r_u8(), p:r_u8(), p:r_u8(), p:r_u8(), p:r_u16() )
		return t
	else
		return CTime_0
	end
end

----------------------------------------------------------------------------------------------------------------------
-- Класс "se_smart_terrain". Обеспечивает поддержку smart terrain в ОФЛАЙНЕ.
-- Унаследован от скриптовой зоны.
----------------------------------------------------------------------------------------------------------------------
class "se_smart_terrain" ( cse_alife_smart_zone )

function se_smart_terrain:update()
--	log( "se_smart_terrain::update called!" )
	cse_alife_smart_zone.update( self )
	update( self )
end

function se_smart_terrain:detect_probability()
--	log( "se_smart_terrain::detect_probability called!" )
	-- если есть активный гулаг, то вероятность будет зависеть от него, иначе вероятность 100%
	return ( self.gulag and self.gparams.probability ) or 1
--	return 1.0
end

function se_smart_terrain:smart_touch( monster )
	log( "se_smart_terrain::smart_touch called!" )
	cse_alife_smart_zone.smart_touch( self, monster )
	on_touch( self, monster )
end

function se_smart_terrain:__init( section ) super( section )
--	log( "se_smart_terrain::se_smart_terrain called!" )
end

function se_smart_terrain:__finalize()
--	log( "se_smart_terrain::~se_smart_terrain called!" )
end

function se_smart_terrain:print()
	printf( "Stalkers:" )
	if self.stalkers then
		for id, v in self.stalkers do
			printf( "    %d", id )
		end
	end
end

-- сохранение
function se_smart_terrain:STATE_Write( packet )
	log( "se_smart_terrain::STATE_Write called!" )
	cse_alife_smart_zone.STATE_Write( self, packet )

	self:print()

	packet:w_u8  ( self.gulagN or 0 )

--	packet:w_u32 ( if_then_else( self.duration_end,  )
--	packet:w_u32 ( self.idle_end or 0 )
	w_CTime( packet, self.duration_end )
	w_CTime( packet, self.idle_end )

	-- список сталкеров
	n = 0
	if self.stalkers then
		for id, v in self.stalkers do
			n = n + 1
		end

		packet:w_u8( n )

		for id, v in self.stalkers do
			packet:w_u16  ( id )
			packet:w_u8   ( v.group )
			packet:w_u8   ( v.squad )
			packet:w_bool ( v.move_offline )
			packet:w_bool ( v.switch_offline )
--			packet:w_u32  ( v.stay_end )
			w_CTime( packet, v.stay_end )
		end
	else
		packet:w_u8( n )
	end
end

-- восстановление
function se_smart_terrain:STATE_Read( packet, size )
	log( "se_smart_terrain::STATE_Read called!" )
	cse_alife_smart_zone.STATE_Read( self, packet, size )

--	printf( "before read" )
--	self:print()

	read_ini( self ) -- прочитать custom_data

	if editor() then
		return
	end

	self.gulagN = packet:r_u8()
	if self.gulagN == 0 then
		self.gulagN = nil
	end

--	self.duration_end = packet:r_u32()
--	self.idle_end     = packet:r_u32()
	self.duration_end = r_CTime( packet )
	self.idle_end     = r_CTime( packet )

	n = packet:r_u8()

	for i = 1, n do
		o_id = packet:r_u16()
		self.stalkers[o_id] = {}
		o = self.stalkers[o_id]

		o.group          = packet:r_u8()
		o.squad          = packet:r_u8()
		o.move_offline   = packet:r_bool()
		o.switch_offline = packet:r_bool()
--		o.stay_end       = packet:r_u32()
		o.stay_end       = r_CTime( packet )
	end

	-- если гулаг был, то заполнить переменные-заглушки
	if self.gulagN then
		self.gparams = self.gulags[self.gulagN]
		self.gulag   = self:setGulag()
	else
		self.gparams = nil
		self.gulag   = nil
	end

--	printf( "after read" )
--	self:print()
end

function se_smart_terrain:FillProps( pref, items )
	log( "se_smart_terrain::FillProps called!" )
	cse_alife_smart_zone.FillProps( self, pref, items )

--	local prefix = pref .. "\\" .. self.section_name .. "\\smart terrain\\"
end

-- установка имитации гулага
function se_smart_terrain:setGulag()
	-- сам этот класс и будет якобы гулагом
	self.Object     = self.stalkers
	self.check_time = CTime_0
	return self
end

-- создание гулага
function se_smart_terrain:createGulag()
	-- если выбранный тип гулага может образоваться в offline
	if self.gparams.offline then
		return self:setGulag()
	else
		return nil
	end
end

function se_smart_terrain:destroyGulag()
end

function se_smart_terrain:free_stalker( obj_id )
	return true
end

function se_smart_terrain:obj_id( obj )
	return obj.id
end

function se_smart_terrain:get_population()
	n = 0
	for k, v in self.stalkers do
		n = n + 1
	end

	return n
end

function se_smart_terrain:addObject()
end

function se_smart_terrain:calculate()
	self:print()
end

----------------------------------------------------------------------------------------------------------------------
-- Класс "cl_smart_terrain". Обеспечивает поддержку smart terrain в ОНЛАЙНЕ.
-- Подключается zone_binder-ом
----------------------------------------------------------------------------------------------------------------------
class "cl_smart_terrain"

function cl_smart_terrain:__init( se_obj, ini )
	-- взять свойства из серверного объекта
	self.id                 = se_obj.id
	self.stalkers           = se_obj.stalkers
	self.gulags             = se_obj.gulags
	self.gulagN             = se_obj.gulagN
	self.gparams            = se_obj.gulags[se_obj.gulagN]
	self._name              = se_obj:name()
	self.idle_end           = se_obj.idle_end
	self.duration_end       = se_obj.duration_end

--	printf( utils.to_str( self.gulagN ) )
--	printf( if_then_else( self.gulags, "GULAGS", "GULAGS=NIL" ) )
--	printf( if_then_else( self.gparams, "GPARAMS", "GPARAMS=NIL" ) )

	-- если в офлайне был гулаг-затычка, то создать настоящий такого же типа
	if se_obj.gulag then
		self.gulag = self:createGulag()

		for id, v in self.stalkers do
			self.gulag:addObjectID( id )
		end
	end
end

function cl_smart_terrain:destroy()
--	printf( "smart terrain client destroy" )
	self:destroyGulag()
end

-- сохранение клиентского объекта, обновляем серверный
function cl_smart_terrain:save()
	printf( "smart terrain client save" )
	sim = alife()
	o   = sim:object( self.id )

	o.stalkers     = self.stalkers
	o.idle_end     = self.idle_end
	o.duration_end = self.duration_end
	o.gulagN       = self.gulagN

	if self.gulag then
		o.gparams = o.gulags[self.gulagN]
		o.gulag   = o:setGulag()
	else
		o.gparams = nil
	end

	o:print()
--	printf( "//smart terrain client save" )
end

function cl_smart_terrain:name()
	return self._name
end

-- callback на вход в зону smart_terrain
function cl_smart_terrain:on_enter( obj )
	-- если есть активный гулаг, то вероятность будет зависеть от него, иначе вероятность 100%
	-- И если не входит уже в какой-то гулаг
	if ( not self.gulag or ( math.random( 100 ) <= self.gparams.probability ) ) and
	   not xr_gulag.isUnderFraction( obj )
	then
		on_touch( self, obj )
	end
end

-- обновление
function cl_smart_terrain:update()
	update( self )
end

function cl_smart_terrain:createGulag()
	self.check_time = CTime_0
	return xr_gulag.createGulag( self.id, self:name(), self.gparams.type, self.gparams.squad, self.gparams.groups )
end

function cl_smart_terrain:destroyGulag()
	xr_gulag.destroyGulag( self:name() )
end

function cl_smart_terrain:free_stalker( obj_id )
	o = self.gulag.Object[obj_id]
	n = type( o )
	-- если объект уже порождён в онлайн, то вернуть его изначальные параметры.
	if n == "userdata" then
		self.gulag:removeObject( obj_id )

--		n = self.stalkers[obj_id]
--		o:change_team( o:team(), n.squad, n.group )
		return true
	-- если объекта в гулаге уже нету, значит он мёртв и его можно удалять
	elseif n == "nil" then
		return true
	-- если гулаг всё ещё ожидает порождения объекта в онлайн, то мы не можем его освободить
	else
		return false
	end
end

function cl_smart_terrain:obj_id( obj )
	return obj:id()
end

----------------------------------------------------------------------------------------------------------------------
-- Единая для офлайна и онлайна логика smart_terrain.
----------------------------------------------------------------------------------------------------------------------
-- чтение custom data. ТОЛЬКО ДЛЯ СЕРВЕРНОГО ОБЪЕКТА!
function read_ini( self )
	self.stalkers        = {}          -- group и squad для каждого сталкера
	self.gulags          = {}          -- настройки гулагов, возможных в этом smart_terrain
	self.gulag           = nil         -- экземпляр текущего гулага

	-- прочитать настройки всех возможных гулагов
	g  = self.gulags
	gi = 1

	repeat
		ini = self:spawn_ini()
		sect = "gulag"..gi

		if not ini:section_exist( sect ) then
			break
		end

		table.insert( g, {} )
		ggi = g[gi]

		if ini:line_exist( sect, "type" ) then
			ggi.type                            = ini:r_string( sect, "type" )
			ggi.idle_min, ggi.idle_max          = r_nums( ini, sect, "idle",       12,     24 )
			ggi.duration_min, ggi.duration_max  = r_nums( ini, sect, "duration",   10000, 10001 )
			ggi.capacity                        = r_num ( ini, sect, "capacity",   100 )
			ggi.probability                     = r_num ( ini, sect, "p",          100 )
			ggi.squad                           = r_num ( ini, sect, "squad" )
			ggi.groups                          = r_str ( ini, sect, "groups" )
			ggi.preconditions                   = r_str ( ini, sect, "preconditions" )

			if ini:line_exist( sect, "offline" ) then
				ggi.offline                     = ini:r_string( sect, "offline" )
			else
				ggi.offline                     = true
			end

			if ggi.type == "heli_hunt" then
				ggi.stay_min, ggi.stay_max      = r_nums( ini, sect, "stay",       0.00415 * 10, 0.0083 * 10 )
			else
				ggi.stay_min, ggi.stay_max      = r_nums( ini, sect, "stay",       10000, 10001 )
			end
		else
			table.remove( g, gi )
			break
		end

		if ggi.preconditions then
			ggi.preconditions = parse_names( ggi.preconditions )
		end

		if ggi.groups then
			ggi.groups = parse_nums( ggi.groups )
		end

		gi = gi + 1
	until false

	if gi <= 1 then
		printf( "[smart_terrain %s] no gulags in custom_data", self:name() )
	else
		self.ini_ok = true
	end
end

-- добавить сталкера в гулаг
function add_stalker( self, obj )
	-- если в гулаге есть свободные места и он подходит гулагу, то добавить
	n = self.gulag:get_population()
	if n < self.gparams.capacity then
		o_id = self:obj_id( obj )

		sim = alife()
		o = sim:object( o_id )

		oT = cast_alife_object_to_trader_abstract( o )
		printf( "comm=%s", oT:community() )

		if xr_gulag.checkNpc( oT:community(), self.gparams.type ) then
			o  = cast_alife_object_to_creature( o )

			self.stalkers[o_id] = {
				group          = o:g_group(),
				squad          = o:g_squad(),
				move_offline   = o:move_offline(),
				switch_offline = o:can_switch_offline(),
				stay_end       = game.CTime()
			}

			--printf( "squad=%s group=%s", utils.to_str ( self.stalkers[o_id].squad ), utils.to_str ( self.stalkers[o_id].group ) )

			t = self.stalkers[o_id].stay_end
			t:setHMSms( 0, 0, 0, math.random( self.gparams.stay_min * h2ms, self.gparams.stay_max * h2ms ) )
			t:add( game.get_game_time() )

			o:move_offline( false )
			sim:set_switch_offline( o_id, false )

			self.gulag:addObject( obj )

			printf( "[smart_terrain %s] adding %s to gulag type=%s", self:name(), o:name(), self.gparams.type )
		end
	end
end

-- отпустить сталкера
function free_stalker( self, obj_id )
	if self:free_stalker( obj_id ) then
		sim = alife()
		o = sim:object( obj_id )

		n = self.stalkers[obj_id]
		o:move_offline( n.move_offline )
		sim:set_switch_offline( obj_id, n.switch_offline )
		o.squad = n.squad
		o.group = n.group

		self.stalkers[obj_id] = nil

		printf( "[smart_terrain %s] removing %s from gulag type=%s", self:name(), o:name(), self.gparams.type )

		return true
	else
		return false
	end
end

-- может ли данный гулаг создаться в данный момент?
function is_gulag_available( gulag_params )
	if gulag_params.preconditions then
		for i, v in gulag_params.preconditions do
			if the_actor:dont_has_info( v ) then
				return false
			end
		end
	end

	return true
end

-- создание нового гулага по конфигурации для данного smart_terrain
function create_gulag( self )
	the_actor = level.actor()

	-- выбор гулагов, которые могут быть созданы
	local avail = {}
	for i, v in self.gulags do
		if is_gulag_available( v ) then
			table.insert( avail, i )
		end
	end

	if table.getn( avail ) > 0 then
		-- создание
		self.gulagN  = avail[math.random( 1, table.getn( avail ) )]
		self.gparams = self.gulags[self.gulagN]  -- ссылка на настройки текущего гулага

		self.duration_end = game.CTime()
		self.duration_end:setHMSms( 0, 0, 0, math.random( self.gparams.duration_min * h2ms, self.gparams.duration_max * h2ms ) )
		self.duration_end:add( game.get_game_time() )

		self.gulag = self:createGulag()

		if self.gulag then
			printf( "[smart_terrain %s] creating gulag of type %s", self:name(), self.gparams.type )

			return true
		else
			self.gulag    = nil
			self.gulagN   = nil
			self.gparams  = nil

			return false
		end
	else
		return false
	end
end

-- всех освободить, убить гулаг
function remove_gulag( self )
	o = true
	-- освободить всех, кто ещё жив в гулаге
	for id, v in self.gulag.Object do
		o = free_stalker( self, id ) and o
	end

	-- если все успешно освобождены, то можно уничтожать гулаг
	if o then
		self.idle_end = game.CTime()
		self.idle_end:setHMSms( 0, 0, 0, math.random( self.gparams.idle_min * h2ms, self.gparams.idle_max * h2ms ) )
		self.idle_end:add( game.get_game_time() )

		self:destroyGulag()

		printf( "[smart_terrain %s] removing gulag type=%s", self:name(), self.gparams.type )

		self.gulag    = nil
		self.gulagN   = nil
		self.gparams  = nil
	end
end

-- обработка входа сталкера в smart terrain
function on_touch( self, obj )
	if obj:clsid() == clsid.stalker then
		ini = obj:spawn_ini()

		if ini and not ini:section_exist( "no_smart" ) then
			if self.gulag then
				add_stalker( self, obj )
			else
				if not self.idle_end or self.idle_end < game.get_game_time() then
					if create_gulag( self ) then
						add_stalker( self, obj )
					end
				end
			end
		end
	end
end

-- обновление
function update( self )
	if self.gulag then
--		if self.duration_end < game.time() then
--			self:remove_gulag()
--		else
			if self.check_time < game.get_game_time() then
				self.check_time = game.get_game_time() + check_period

				-- проверять, не собрался ли кто-то к этому времени уже уходить
				sn = 0
				for id, v in self.gulag.Object do
					if self.stalkers[id].stay_end < game.get_game_time() then
						-- попытка освободить сталкера. если неудачно, то он всё ещё числится
						if not free_stalker( self, id ) then
							sn = sn + 1
						end
					else
						sn = sn + 1
					end
				end

				-- если мужиков в гулаге больше не осталось, убрать гулаг
				if sn == 0 then
					remove_gulag( self )
				else
					self.gulag:calculate()
				end
			end
--		end
	end
end
