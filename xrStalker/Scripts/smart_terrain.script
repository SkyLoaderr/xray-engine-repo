--[[------------------------------------------------------------------------------------------------------------------
Smart Terrain (механизм, организовывающий всех сталкеров и некоторых монстров в сцены)
Чугай Александр
!без симуляции не работает!
--------------------------------------------------------------------------------------------------------------------]]

--local h2ms = 60 * 60 * 1000

--function printf()
--end

local check_period

if not editor() then
	check_period = game.CTime()
	check_period:setHMSms( 0, 0, 0, 50000 )

	CTime_0 = game.CTime()
end

local monster_classes

local disagreed, agreed, agreed_exclusive = 0, 1, 2

local smart_section = "smart_terrains"

exclusives = {}

--[[ список всех серверных объектов смартов, которые зарегистрированы в симуляторе
Формат:
	smart_terrains = {
		level_name = { id=obj, id=obj, ... },
		level_name = { id=obj, id=obj, ... },
		...
	}
]]
local smart_terrains = {}

----------------------------------------------------------------------------------------------------------------------
-- Разные полезные функции
----------------------------------------------------------------------------------------------------------------------
-------------- помощники для чтения ini (custom data) -------------------
-- TODO убрать их
function r_str( spawn_ini, section, line, default )
	if spawn_ini:line_exist( section, line ) then
		return spawn_ini:r_string( section, line )
	else
		return default
	end
end

function r_num( spawn_ini, section, line, default )
	if spawn_ini:line_exist( section, line ) then
		return spawn_ini:r_float( section, line )
	else
		return default
	end
end

function r_2nums( spawn_ini, section, line, def1, def2 )
	if spawn_ini:line_exist( section, line ) then
		-- если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
		local t = parse_nums( spawn_ini:r_string( section, line ) )
		local n = table.getn( t )

		if n == 0 then
			return def1, def2
		elseif n == 1 then
			return t[1], def2
		else
			return t[1], t[2]
		end
	else
		return def1, def2
	end
end

----------------------------------------------------------------------------------------------------------------------
-- Класс "se_smart_terrain". Обеспечивает поддержку smart terrain в ОФЛАЙНЕ.
-- Унаследован от скриптовой зоны.
----------------------------------------------------------------------------------------------------------------------
class "se_smart_terrain" ( cse_alife_smart_zone )

function se_smart_terrain:__init( section ) super( section )
--	log( "se_smart_terrain::se_smart_terrain called!" )

	self.initialized = false
end

function se_smart_terrain:detect_probability()
--	log( "se_smart_terrain::detect_probability called!" )
	return 0
end

function se_smart_terrain:print()
	printf( "NPCs:" )
	if self.npc_info then
		for id, v in pairs( self.npc_info ) do
			printf( "    %d %s", id, v.name )
		end
	end
end

-- сохранение
function se_smart_terrain:STATE_Write( packet )
--	log( "se_smart_terrain::STATE_Write called!" )
	cse_alife_smart_zone.STATE_Write( self, packet )

--	self:print()

	utils.w_CTime( packet, self.duration_end )
	utils.w_CTime( packet, self.idle_end )

	if self.gulag_working then
		packet:w_bool( true )

		self.gulag:save_common( packet )

		local n = 0

		for id, v in pairs( self.npc_info ) do
			n = n + 1
		end

		packet:w_u8( n )

		for id, v in pairs( self.npc_info ) do
			packet:w_u16  ( id )
			packet:w_u8   ( v.o_group )
			packet:w_u8   ( v.o_squad )
			packet:w_bool ( v.exclusive )
			utils.w_CTime ( packet, v.stay_end )

			self.gulag:save_obj( packet, id )
		end

		packet:w_bool ( self.population_locked )
	else
		packet:w_bool( false )
	end
end

-- восстановление
function se_smart_terrain:STATE_Read( packet, size )
--	log( "se_smart_terrain::STATE_Read called!" )
	cse_alife_smart_zone.STATE_Read( self, packet, size )

--	printf( "before read" )
--	self:print()

	self:read_params()

	-- под LevelEditor не пытаться читать из пакета ничего
	if editor() then
		return
	end

--	printf( "name=%s, script_version=%d", self:name(), self.script_version )

	self.duration_end = utils.r_CTime( packet )
	self.idle_end     = utils.r_CTime( packet )

	self.gulag_working = packet:r_bool()

	-- если есть работающий гулаг
	if self.gulag_working then
		self.check_time = CTime_0

		self.gulag:load_common( packet )

		local n = packet:r_u8()
		local o_id, o

--		printf( "npc_info=%s", to_str( n ) )

		for i = 1, n do
			o_id = packet:r_u16()
			self.npc_info[o_id] = {}
			o = self.npc_info[o_id]

			o.o_group   = packet:r_u8()
			o.o_squad   = packet:r_u8()
			o.exclusive = packet:r_bool()
			o.stay_end  = utils.r_CTime( packet )

			self.gulag:load_obj( packet, o_id )
		end

		self.population_locked = packet:r_bool()
	end

--	printf( "after read" )
--	self:print()
end

-- инициализировать работу смарт террейна.
-- после этой функции смарт ПОЛНОСТЬЮ работоспособен.
-- вызывается из всех мест, которые могут вызвать другие объекты:
--   se_smart_terrain:enabled()
--   se_smart_terrain:update()
--   xr_gulag.setup_gulag_and_logic_on_spawn()
--   xr_gulag.get_npc_gulag()
--   xr_gulag.get_gulag_by_name()
--   xr_gulag.get_gulag_by_sid()
function se_smart_terrain:initialize_if_needed()
	if not self.initialized then
		db.actor_proxy:init()

		sim_statistic.update()

		self:get_se_objs()

		self:preserve_exclusives()

		self.initialized = true
	end
end

-- зарезервировать места для эксклюзивных персонажей
function se_smart_terrain:preserve_exclusives()
	local e = exclusives[self:name()]

	if e then
		printf( "[smart_terrain %s] exclusives=%d", self:name(), e )

		self.exclusives = e
		self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive - e

		exclusives[self:name()] = nil
	else
		self.exclusives = 0
	end
end

-- получить серверные объекты персонажей
function se_smart_terrain:get_se_objs()
	local sim = alife()
	local obj

	for id, v in pairs( self.npc_info ) do
		obj = sim:object( id )

		if not obj then
			abort( "[smart_terrain %s] can't get server object id=%d", self:name(), id )
		end

		sim_statistic.add( obj )

		self:fill_npc_info( obj, v )
	end
end

-- заполнить информацию о персонаже
-- у монстров нету метода profile_name()
-- TODO передавать в предикаты не npc_info, а объект
function se_smart_terrain:fill_npc_info( obj, npc_info )
	if not npc_info then
		npc_info = {}
	end

	npc_info.se_obj       = obj

	npc_info.class_id     = obj:clsid()
	npc_info.section_name = obj:section_name()
	npc_info.name         = obj:name()
	npc_info.story_id     = obj.m_story_id
	npc_info.community    = self:get_obj_community( obj )
	npc_info.profile_name = obj.profile_name and obj:profile_name()
	npc_info.rank         = obj:rank()

	npc_info.group        = obj:g_group()
	npc_info.squad        = obj:g_squad()
	npc_info.team         = obj:g_team()

	if npc_info.profile_name then
		npc_info.is_sniper = string.find( npc_info.profile_name, "sniper" ) ~= nil
	end

	local t               = obj:get_smart_terrain_conditions()
	if t then
		t = t[self:name()]
	end

	npc_info.cond         = t
	return npc_info
end

-- возвращает:
-- а) если сталкер: группировку сталкера и true
-- б) если монстр:  вид монстра и false
function se_smart_terrain:get_obj_community( obj )
	local cls = obj:clsid()

	if cls == clsid.script_stalker then
		return obj:community(), true
	else
		return monster_classes[cls], false
	end
end

-- инициализация.
-- чтение custom data.
-- TODO вызывать из on_register
function se_smart_terrain:read_params()
	local ini  = self:spawn_ini()
	local sect = "smart_terrain"

	if not ini:section_exist( sect ) then
		sect = "gulag1"

		if not ini:section_exist( sect ) then
--			abort( "[smart_terrain %s] no configuration!", self:name() )
			printf( "[smart_terrain %s] no configuration!", self:name() )
			self.disabled = true
			return
		end
	end

	if not ini:line_exist( sect, "type" ) then
		abort( "[smart_terrain %s] type is not specified", self:name() )
	end

	local gp       = {}

	self.npc_info  = {}          -- group и squad для каждого npc
	self.gparams   = gp          -- настройки гулага

	gp.type        = ini:r_string( sect, "type" )
	gp.preset_name = r_str ( ini, sect, "preset" )
	gp.capacity    = r_num ( ini, sect, "capacity", 100 ) -- ёмкость. а настоящая ёмкость = min(эта_ёмкость, ёмкость гулага)
	gp.squad       = r_num ( ini, sect, "squad" )

	gp.idle_min,     gp.idle_max      = r_2nums( ini, sect, "idle",       0,     0 )
	gp.duration_min, gp.duration_max  = r_2nums( ini, sect, "duration",   10000, 10001 )
	gp.stay_min,     gp.stay_max      = smart_terrain_params.get_stay_time_interval( r_str( ini, sect, "stay", "default" ) )

--	printf( "gp.stay_min=%d, gp.stay_max=%d", gp.stay_min * h2ms, gp.stay_max * h2ms )

	gp.cond        = r_str( ini, sect, "cond" )
	if gp.cond then
		gp.cond = xr_logic.parse_condlist( nil, sect, "cond", gp.cond )
	end

	gp.groups      = r_str( ini, sect, "groups" )
	if gp.groups then
		gp.groups = parse_nums( gp.groups )
	end

	self.accepted_communities = nil

	local t = r_str( ini, sect, "communities" )
	if t then
		t = parse_names( t )

		self.accepted_communities = {}

		for i, v in ipairs( t ) do
			self.accepted_communities[v] = true
		end
	end

	local ltx = system_ini()

	self.rank_inc_min = ltx:r_string( "smart_terrain_rank_change", "min" )
	self.rank_inc_max = ltx:r_string( "smart_terrain_rank_change", "max" )

	self.population_locked = false

	self.gulag = xr_gulag.gulag( self, self.gparams.type, self.gparams.squad, self.gparams.groups, self.npc_info, self.gparams.capacity )

	self.gulag_working = false
end

-- подходит ли персонаж по предустановкам.
-- если такой предустановки нету, то он всегда подходит.
function se_smart_terrain:check_preset( npc_community, npc_rank, preset_name )
	local preset = smart_terrain_params.get_preset( preset_name )

	if preset == false then
		return true
	else
		local t = preset[npc_community]

--		printf( "preset_name=%s ranks=[%d,%d] npc_rank=%d", preset_name, t[1], t[2], npc_rank )

		if t and ( npc_rank >= t[1] and npc_rank <= t[2] ) then
			return true
		else
			return false
		end
	end
end

--[[ подходит ли объект гулагу?
1) если объект не согласен сюда идти, то smart terrain его не возьмёт
2) если объект согласен идти куда угодно, то проверить, есть ли ещё места, подходит ли он гулагу,
   подходит ли он хоть на одну работу
3) если объект согласен идти только в этот смарт, то принимаем даже если нету места (он вытеснит кого-то), проверить,
   подходит ли он гулагу, подходит ли он хоть на одну работу
]]
function se_smart_terrain:smart_terrain_accepts_obj( obj, obj_agreement )
	if self:name() == "rad_entrance" then
		printf( "[smart_terrain %s] smart_terrain_accepts_obj called obj=%s", self:name(), obj:name() )
	end

	if obj_agreement == disagreed then
		return false
	end

	if obj_agreement == agreed_exclusive or
	   self.gulag:get_non_exclusive_population() < self.gulag.capacity_non_exclusive
	then
		local community, is_stalker = self:get_obj_community( obj )

		if self:name() == "rad_entrance" then
			printf( "comm=%s is_stalker=%s", community, tostring( is_stalker ) )
		end

		if self.accepted_communities and not self.accepted_communities[community] then
			return false
		end

		if obj:name() == "yantar_semenov" then
			printf( "profile=%s rank=%d reputation=%d", obj:profile_name(), obj:rank(), obj:reputation() )
		end

		if not self:check_preset( community, obj:rank(), self.gparams.preset_name ) then
			return false
		end

		if obj:name() == "yantar_semenov" then
			printf( "check_preset ok" )
		end

		if not xr_gulag.checkNpc( community, is_stalker, self.gparams.type, obj:rank(), obj ) then
			return false
		end

		if obj:name() == "yantar_semenov" then
			printf( "checkNpc ok" )
		end

		return self.gulag:is_there_any_suitable_job( self:fill_npc_info( obj ), obj_agreement == agreed_exclusive )
	else
		return false
	end
end

--[[ подходит ли гулаг объекту?
у объекта в custom data прописаны условия для некоторых smart_terrains:
	<smart_terrain_name1> = <condlist1>
	<smart_terrain_name2> = <condlist2>
	...
Если для какого-то smart_terrain условие выполнилось, он называется эксклюзивным.
Если у объекта появился хоть один эксклюзивный smart terrain, то он будет согласен идти только в него.
Если не появилось ни одного эксклюзивного, то он согласен идти в любой.
]]
-- TODO а если в начале эксклюзивный, а потом в любой?
-- вариант: any=condlist
function se_smart_terrain:obj_accepts_smart_terrain( obj )
	if obj:get_smart_terrain_conditions() then
		local any_exclusive = false
		local s

		for name, condlist in pairs( obj:get_smart_terrain_conditions() ) do
			s = xr_logic.pick_section_from_condlist( db.actor_proxy, obj, condlist )

			if s ~= nil then
			 	if name == self:name() then
					return agreed_exclusive
				else
					any_exclusive = true
				end
			end
		end

		if any_exclusive then
			return disagreed
		end
	end

	return agreed
end

-- может ли объект быть добавлен в smart terrain?
-- вызывается симулятором при поиске задания для объекта/группы.
-- если объект - группа, то вернёт true только если все объекты в группе вернут true
function se_smart_terrain:enabled( obj )
	if obj:name() == "yantar_semenov" then
		printf( "[smart_terrain %s] enabled called obj=%s", self:name(), obj:name() )
	end

	-- DEBUG
	if self.disabled then
		return false
	end
	--------

	self:initialize_if_needed()

	if self:is_gulag_available() and not self.population_locked then
--		if obj:clsid() == clsid.GROUP then -- TODO
			-- TODO проитерировать группу
--		else
--			return self:smart_terrain_accepts_obj( obj, self:obj_accepts_smart_terrain( obj ) )
			local b1 = self:obj_accepts_smart_terrain( obj )
			local b2 = self:smart_terrain_accepts_obj( obj, b1 )

			if self:name() == "rad_entrance" or
			   obj:name()  == "yantar_semenov"
			then
				printf( "obj_accepts_smart_terrain=%d smart_terrain_accepts_obj=%s", b1, tostring( b2 ) )
			end

			return b2
--		end
	else
		return false
	end
end

-- возвращает меру подходящести персонажа смарттерейну.
-- вызывается для всех смарттерейнов, которые вернули true из enabled
-- для того, чтобы выбрать тот единственный, в который персонаж всё-таки пойдёт.
-- критерии:
--   1) если объект уже бывал в других смартах, то чем больше свободных работ на уровне этого смарта, тем лучше
--   2) иначе ближе - лучше
-- TODO Оптимизировать
function se_smart_terrain:suitable( obj )
	if obj.was_in_smart_terrain then
		local v = 0

		for id, strn in pairs( smart_terrains[self:get_level_name()] ) do
			if strn:is_gulag_available() then
				v = v + strn.gulag.capacity - strn.gulag:get_population()
			end
		end

--[[		printf( "[smart_terrain %s] obj=%s suitable=%d was_in_smart_terrain=%s",
		        self:name(),
		        obj:name(),
		        1000000 - v,
		        tostring(obj.was_in_smart_terrain) )]]

		return 1000000 - v
	else
		local self_gv = game_graph():vertex( self.m_game_vertex_id )
		local obj_gv  = game_graph():vertex( obj.m_game_vertex_id )

--[[		printf( "[smart_terrain %s] obj=%s suitable=%d was_in_smart_terrain=%s",
		        self:name(),
		        obj:name(),
		        1000000 - obj_gv:game_point():distance_to( self_gv:game_point() ),
		        tostring(obj.was_in_smart_terrain) )]]

		return 1000000 - obj_gv:game_point():distance_to( self_gv:game_point() )
	end
end

-- добавить npc в smart terrain.
-- если места нету или нету свободных подходящих работ, то
-- вытолкнуть из этого smart terrain с подходящей работы объект, который попал в него не эксклюзивно.
function se_smart_terrain:register_npc( obj )
	printf( "[smart_terrain %s] register called obj=%s gulag_type=%s", self:name(), obj:name(), self.gparams.type )

	local npc_info = {
		-- старые squad и group
		o_group        = obj:g_group(),
		o_squad        = obj:g_squad(),

		exclusive      = self:obj_accepts_smart_terrain( obj ) == agreed_exclusive,

--		move_offline   = o:move_offline(),
		stay_end       = game.CTime()
	}

	self:fill_npc_info( obj, npc_info )

	if self.gulag_working and
--	   ( self.gulag:get_population() == self.gulag.capacity or
	   not self.gulag:is_there_any_suitable_job( npc_info, false ) --)
	then
--		printf( "get_population=%d capacity=%d", self.gulag:get_population(), self.gulag.capacity )
--		printf( "is_there_any_suitable_job=%s", tostring( self.gulag:is_there_any_suitable_job( npc_info, false ) ) )
--		print_table( self.npc_info )
		self:kick_someone_non_exclusive( npc_info )
	end

	self:update_obj_rank( obj )

	obj.was_in_smart_terrain = true

	self.npc_info[obj.id] = npc_info

	t = self.npc_info[obj.id].stay_end
--	t:setHMSms( 0, 0, 0, math.random( self.gparams.stay_min * h2ms, self.gparams.stay_max * h2ms ) )
	t:setHMSms( math.random( self.gparams.stay_min, self.gparams.stay_max ), 0, 0, 0 )
	t:add( game.get_game_time() )

--	o:move_offline( false )

	if not self.gulag_working then
		self:create_gulag()
	end

	self.gulag:addObject( obj.id )

	self.gulag:update()

	sim_statistic.add( obj )

	printf( "[smart_terrain %s] added %s to gulag type=%s", self:name(), obj:name(), self.gparams.type )
end

-- отпустить npc
-- TODO а если такого объекта уже нету?
function se_smart_terrain:unregister_npc( obj )
	local n = self.npc_info[obj.id]

	if not n then
		printf( "self.npc_info[obj.id] = nil !!! obj.id=%d", obj.id )
		self:print()
		self.gulag:print()
	end

	self.gulag:removeObject( obj.id )

--	o:move_offline( n.move_offline )
	obj.squad = n.o_squad
	obj.group = n.o_group

	self.npc_info[obj.id] = nil

	obj:clear_smart_terrain()

	sim_statistic.remove( obj )

	printf( "[smart_terrain %s] removing %s from gulag type=%s", self:name(), obj:name() or "<<<nil>>>", self.gparams.type )
end

-- изменть ранг сталкера при регистрации в смарт
function se_smart_terrain:update_obj_rank( obj )
	local community, is_stalker = self:get_obj_community( obj )

	if is_stalker then
		local old_rank = obj:rank()

		obj:set_rank( old_rank + math.random( self.rank_inc_min, self.rank_inc_max ) )

		printf( "[smart_terrain %s] obj=%s rank %d -> %d", self:name(), obj:name(), old_rank, obj:rank() )
	end
end

-- выгнать из-под смарттеррейна первого попавшегося неэксклюзивного персонажа,
-- который занимает работу, подходящую новому персонажу.
-- TODO а если я выгоню кого-то, а его работа не подойдёт по idle ?
function se_smart_terrain:kick_someone_non_exclusive( new_npc_info )
	for obj_id, npc_info in pairs( self.npc_info ) do
		if not npc_info.exclusive and self.gulag:obj1_job_suits_obj2( obj_id, new_npc_info ) then
			self:unregister_npc( npc_info.se_obj )
			return
		end
	end

	abort( "[smart_terrain %s] can't add npc, all are exclusive or there are no suitable jobs", self:name() )
end

-- выдать объекту задание.
function se_smart_terrain:task( obj )
	local path_name = self.gulag:get_obj_job_path_name( obj.id )
	if not path_name then
		abort( "[smart_terrain %s] task: obj=%s job_path=nil", self:name(), obj:name() )
	end

--	printf( "[smart_terrain %s] task: obj=%s job_path=%s", self:name(), obj:name(), path_name )

	return CALifeSmartTerrainTask( path_name )
end

-- может ли данный гулаг создаться в данный момент?
function se_smart_terrain:is_gulag_available()
	if self.gparams.cond then
		return xr_logic.pick_section_from_condlist( db.actor_proxy, self, self.gparams.cond ) ~= nil
	else
		return true
	end
end

-- установка/снятие блокировки приёма персонажей
function se_smart_terrain:lock_population( need_lock )
	self.population_locked = need_lock
end

-- в гулаг поступил первый персонаж и он начинает работать
function se_smart_terrain:create_gulag()
	self.duration_end = game.CTime()
--	self.duration_end:setHMSms( 0, 0, 0, math.random( self.gparams.duration_min * h2ms, self.gparams.duration_max * h2ms ) )
	self.duration_end:setHMSms( math.random( self.gparams.duration_min, self.gparams.duration_max ), 0, 0, 0 )
	self.duration_end:add( game.get_game_time() )

	self.check_time = CTime_0

	self.gulag:initialize()

	self.gulag_working = true
end

-- всех освободить, убить гулаг,
-- создать новый нерабочий гулаг, зарезервировать в нём места для эксклюзивных
function se_smart_terrain:remove_gulag( disable )
	-- DEBUG
	self.disabled = disable
	--------

	if not self.gulag_working then
		return
	end

	-- освободить всех персонажей
	for id, npc_info in pairs( self.npc_info ) do
		self:unregister_npc( npc_info.se_obj )
	end

	if self.gparams.idle_max > 0 then
		self.idle_end = game.CTime()
--		self.idle_end:setHMSms( 0, 0, 0, math.random( self.gparams.idle_min * h2ms, self.gparams.idle_max * h2ms ) )
		self.idle_end:setHMSms( math.random( self.gparams.idle_min, self.gparams.idle_max ), 0, 0, 0 )
		self.idle_end:add( game.get_game_time() )
	else
		self.idle_end = nil
	end

	self.gulag = xr_gulag.gulag( self, self.gparams.type, self.gparams.squad, self.gparams.groups, self.npc_info, self.gparams.capacity )
	self.gulag:load_jobs()

	self.gulag_working = false

	self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive - self.exclusives

	printf( "[smart_terrain %s] removed gulag type=%s", self:name(), self.gparams.type )
end

-- заполняет таблицу monster_classes
function se_smart_terrain:fill_monster_classes()
	if not monster_classes then
		monster_classes = {
			[clsid.bloodsucker_s ] = "bloodsucker",
			[clsid.boar_s        ] = "boar",
			[clsid.burer_s       ] = "burer",
			[clsid.cat_s         ] = "cat",
			[clsid.chimera_s     ] = "chimera",
			[clsid.controller_s  ] = "controller",
			[clsid.pseudodog_s   ] = "pseudodog",
			[clsid.psy_dog_s     ] = "psy_dog",
			[clsid.dog_s         ] = "dog",
			[clsid.flesh_s       ] = "flesh",
			[clsid.fracture_s    ] = "fracture",
			[clsid.poltergeist_s ] = "poltergeist",
			[clsid.gigant_s      ] = "pseudo_gigant",
			[clsid.snork_s       ] = "snork",
			[clsid.tushkano_s    ] = "tushkano",
			[clsid.zombie_s      ] = "zombie"
		}
	end
end

-- возвращает название уровня, на котором находится smart terrain
function se_smart_terrain:get_level_name()
--	return "chugai_test"

--	printf( "[smart_terrain %s] is on level %s", self:name(), alife():level_name( game_graph():vertex( self.m_game_vertex_id ):level_id() ) )

	return alife():level_name( game_graph():vertex( self.m_game_vertex_id ):level_id() )
end

-- регистрация объекта симуляторе.
-- вызывается симулятором.
function se_smart_terrain:on_register()
--	printf( "[smart_terrain %s] on_register called", self:name() )
	cse_alife_smart_zone.on_register( self )

	-- DEBUG
	if self.disabled then
		return
	end

	self:fill_monster_classes()

	local level_name = self:get_level_name()

	if not self.gparams.preset_name then
		self.gparams.preset_name = level_name
	end

	if not smart_terrains[level_name] then
		smart_terrains[level_name] = {}
	end

	smart_terrains[level_name][self.id] = self

	self.gulag:load_jobs()

	if self.gulag_working then
		self.gulag:initialize()
	end

	sim_statistic.reinit()

	-- Регистрация в таскменеджере
	task_manager.register_target(self)
end

-- дерегистрация объекта симуляторе.
-- вызывается симулятором.
function se_smart_terrain:on_unregister()
	cse_alife_smart_zone.on_unregister( self )

	smart_terrains[self:get_level_name()][self.id] = nil
end

-- возвращает строку с принимаемыми группировками и рангами
function se_smart_terrain:stat_get_accepted_communities()
	local comms = {}

	-- from preset
	local ltx         = ini_file( "misc\\" .. self.gparams.type .. ".ltx" )
	local preset_name = self.gparams.preset_name

	if ltx and ltx:section_exist( preset_name ) then
		local result, field, str
		local n = ltx:line_count( preset_name )

		for i = 0, n-1 do
			result, field, str = ltx:r_line( preset_name, i, "", "" )

			if not self.accepted_communities or self.accepted_communities[field] then
				comms[field] = str
			end
		end
	end

	-- from custom data
	if self.accepted_communities then
		for comm, v in pairs( self.accepted_communities ) do
			if not comms[comm] then
				comms[comm] = "all"
			end
		end
	end

	-- prepare return
	local s = ""

	for comm, ranks in pairs( comms ) do
		s = s .. comm .. "(" .. ranks .. "),"
	end

	return s
end

-- вывод статистики смарта
function se_smart_terrain:stat()
	local s = self:get_level_name() .. " " .. self:name()

	local pop   = self.gulag:get_population()
	local cap   = self.gulag.capacity
	local avail = self:is_gulag_available()

	if avail then
		s = s .. " enabled "
	else
		s = s .. " disabled "
	end

	s = s .. pop .. " " .. cap .. " " .. self:stat_get_accepted_communities()

	printf( s )

--	for id, npc_info in pairs( self.npc_info ) do
--		printf( "    %s", npc_info.name )
--	end

	return avail, pop, cap
end

-- Обновление. В онлайне вызывается через binder.
-- Если мужиков в гулаге больше не осталось или условия существования гулага не выполняются, то убрать гулаг.
function se_smart_terrain:update()
--	log( "se_smart_terrain::update called!" )
	cse_alife_smart_zone.update( self )

	if not self.gulag_working then
		return
	end

	self:initialize_if_needed()

--	if self.duration_end < game.time() then
--		self:remove_gulag()
--	else
	if self:is_gulag_available() then
		if self.check_time < game.get_game_time() then
			self.check_time = game.get_game_time() + check_period

			-- проверять, не собрался ли кто-то к этому времени уже уходить
			local sn   = 0
			local time = game.get_game_time()

			for id, npc_info in pairs( self.npc_info ) do
				if npc_info.stay_end < time or
				   ( npc_info.cond and xr_logic.pick_section_from_condlist( db.actor_proxy, npc_info.se_obj, npc_info.cond ) == nil )
				then
					self:unregister_npc( npc_info.se_obj )
				else
					sn = sn + 1
				end
			end

			if sn == 0 then
				self:remove_gulag()
			else
				self.gulag:update()
			end
		end
	else
		self:remove_gulag()
	end
--	end
end

--------------------
function on_death( obj_id )
--	printf( "on_death obj_id=%d", obj_id )

	local sim = alife()

	if sim then
		local obj     = sim:object( obj_id )
		local strn_id = obj:smart_terrain_id()

		if strn_id ~= 65535 then
			sim:object( strn_id ).gulag:update_objs()
		end
	end
end

--------------------
-- прочитать секцию [smart_terrains]
-- вызывается объектами, которые могут ходить под smart terrain
function read_smart_terrain_conditions( self )
	if self.ini and self.ini:section_exist( smart_section ) then
		local conds = {}
		local accepts = false
		local result, field, str
		local n = self.ini:line_count( smart_section )

		if n > 0 then
			for i = 0, n-1 do
				result, field, str = self.ini:r_line( smart_section, i, "", "" )

				conds[field] = xr_logic.parse_condlist(self, smart_section, field, str)
			end

			return conds
		end
	end

	return nil
end

-- получить распарсеную секцию [smart_terrains]
-- вызывается объектами, которые могут ходить под smart terrain
function get_smart_terrain_conditions( self )
	self:get_ini()

	if not self.smart_terrain_conditions_initialized then
		self.smart_terrain_conditions             = self:read_smart_terrain_conditions()
		self.smart_terrain_conditions_initialized = true
	end

	return self.smart_terrain_conditions
end

--------------------
-- Вывод статистики по всем смартам в симуляции
function stat()
	printf( "--------------- Smart terrains statistics START ----------------------" )

	local jobs, jobs_in_avail, occupied
	local level_stats = {}

	for level_name, t in pairs( smart_terrains ) do
		jobs, jobs_in_avail, occupied = 0, 0, 0

		for id, strn in pairs( t ) do
			local avail, pop, cap = strn:stat()

			jobs       = jobs     + cap
			occupied   = occupied + pop

			if avail then
				jobs_in_avail = jobs_in_avail + cap
			end
		end

		local l = {}
		level_stats[level_name] = l

		l.jobs          = jobs
		l.occupied      = occupied
		l.jobs_in_avail = jobs_in_avail
	end

	jobs, jobs_in_avail, occupied = 0, 0, 0

	printf("")

	for level_name, l in pairs( level_stats ) do
		printf( "Level %s :", level_name )
		printf( "    Jobs in all smart terrains : %d",       l.jobs )
		printf( "    Jobs in available smart terrains : %d", l.jobs_in_avail )
		printf( "    Occupied jobs : %d",                    l.occupied )

		jobs          = jobs          + l.jobs
		jobs_in_avail = jobs_in_avail + l.jobs_in_avail
		occupied      = occupied      + l.occupied
	end

	printf( "All levels:" )
	printf( "    Jobs in all smart terrains : %d",       jobs )
	printf( "    Jobs in available smart terrains : %d", jobs_in_avail )
	printf( "    Occupied jobs : %d",                    occupied )

	printf( "--------------- Smart terrains statistics END ------------------------" )
end
