----------------------------------------------------------------------------------------------------------------------
--  Общая схема принятия решений
--  автор: Диденко Руслан (Stohe)
--  TODO:
----------------------------------------------------------------------------------------------------------------------
storage = {}
memtsg = {} --' временная таблица

----------------------------------------------------------------------------------------------------------------------
--Motivator binder
----------------------------------------------------------------------------------------------------------------------
class "motivator_binder" (object_binder)
----------------------------------------------------------------------------------------------------------------------
function motivator_binder:__init (obj) super(obj)
end
----------------------------------------------------------------------------------------------------------------------
function motivator_binder:reinit()
	object_binder.reinit(self)
	self.object:set_pda_callback(pda_callback)

	self.object:set_hear_callback(hear_callback)

end
----------------------------------------------------------------------------------------------------------------------
function motivator_binder:net_destroy()
    object_binder.net_destroy(self)
end
----------------------------------------------------------------------------------------------------------------------
function motivator_binder:update(delta)
    object_binder.update(self, delta)
    --' вызов апдейта у управления группировками
    local nn = xr_gulag.isUnderFraction(self.object)

    if nn ~= nil then
        xr_gulag.fraction[nn]:calculate()
    end

    --' вызов апдейта у управления бандюками
    local nn = xr_bandit.isBandit(self.object)

    if nn ~= nil then
        xr_bandit.bandits[nn]:update()
    end

--' Проверка ТИМ СКВАД ГРУП
if false then
  if memtsg[self.object:id()] == nil then
    printf("[TSG] Object: %s t:%d s:%d g:%d", self.object:name(),
                          self.object:team(),
                          self.object:squad(),
                          self.object:group())
    memtsg[self.object:id()] = self.object:id()
  end
end

end
----------------------------------------------------------------------------------------------------------------------
function motivator_binder:reload (section)
    object_binder.reload(self, section)

    local char_ini = self.object:spawn_ini()

    --' Bind other scripts
    printf("Base evaluator ID %d", stalker_ids.property_script)
    printf("Base action ID %d", stalker_ids.action_script)
    self.object:disable_talk()

    --' загрузка озвучки
    xr_sounds.load_sounds (self.object)
----------------------------------------------------------------------------------------------------------------------
-- Общие скрипты
----------------------------------------------------------------------------------------------------------------------
	xr_sound.load_sound(self.object)
    xr_motivator.storage[self.object:id()] = {  followers = {} }
    --' Положения тела
    xr_motivator.storage[self.object:id()].state = {
            body_state = 0,
            target_state = 0,
            position = nil,
            dist = 1,
            anim = xr_state.anims(self.object)
        }
    xr_state.add_to_binder(self.object)
    --' Настройка схемы реакции
	xr_motivator.storage[self.object:id()].reactions = {
		enabled = true,
		time_wait = 5*60*1000,
		evn = xr_reactions.events(self.object),
		obj = {position = nil,
				id = nil,
				type = nil,
				time = nil,
				visibility = nil
			},
		rules = {}
    }
    xr_reactions.add_to_binder(self.object, char_ini)
    --' схема привязки к позиции
    xr_position.add_to_binder(self.object)
    --' удар в морду
    xr_punch.add_to_binder (self.object)   
    --' Настройка встречи
    xr_motivator.storage[self.object:id()].meet = {
			Buyer = nil,
            Seller = self.object,
            begin_wait_to_see = { time = 300,
                                begin = nil },
            enabled = false,
            over = false,
            actor = nil,
            noweap = false,			--' игнорируем наличие оружия у актора
            distance = 15,			--' расстояние, в пределах которого мы реагируем
            shoot_distance = 5		--' расстояние, в пределах которого мы стреляем
        }  
    xr_meet.add_to_binder(self.object, char_ini)

	--' Помощник
    xr_motivator.storage[self.object:id()].helper = {
			position,
			enabled = false
        }
----------------------------------------------------------------------------------------------------------------------
-- Модели поведения
----------------------------------------------------------------------------------------------------------------------
    -- Грабители
    xr_motivator.storage[self.object:id()].robber = { }
    xr_robbers.add_to_binder(self.object, char_ini)

    -- Поводырь/грабитель
    xr_motivator.storage[self.object:id()].guide = { }
    xr_guide.add_to_binder(self.object, char_ini)

    -- Охранник на входе в логово бандитов
    xr_motivator.storage[self.object:id()].robber_guard = { }
    xr_robber_guard.add_to_binder(self.object, char_ini)

    -- лагерь у костра
    xr_motivator.storage[self.object:id()].kamp = {
            -- Будет ли работать схема? если нет, то он не будет пытаться инициализировать камп
            enabled = false,
            -- Патрульный путь из 1 вэйпоинта, который указывает на центр лагеря.
            center_point = nil,
            -- максимальный радиус, в котором рассаживаются люди вокруг центра лагеря
            max_rad = 2,
            -- Идентификатор следующего действия.
            -- 0 - нет действия
            -- 1 - пойти обойти территорию
            action = 0,
            -- Последний выполненный нами экшн, чтобы не повторяться
            last_action = 0,
            -- Патрульные пути, по которым будут сталкеры обходить лагерь
            patrol_path = {},
            -- ID позиции, в которую он сядет
            pos_id = -1,
            -- Положение тела. 0 - стоит, остальное - разные варианты сидения
            body_state = 0,
            -- Время между повторением действий
            timer = { act1 = {begin = nil, time = 120},
                          act4 = {begin = nil, time = 60}}
        }
xr_kamp.add_to_binder(self.object, char_ini)
    -- спящий
    xr_motivator.storage[self.object:id()].sleeper = {
            enabled = false,
                path_main = nil
        }
xr_sleeper.add_to_binder(self.object, char_ini)

    -- Часовые
    xr_motivator.storage[self.object:id()].guard = {
            enabled = false,
            action = nil,
            path_main = nil,
            path_hideout = nil
        }
xr_guard.add_to_binder(self.object, char_ini)

    -- Сталкер, который ходит (версия часовых на новой схеме)
    xr_motivator.storage[self.object:id()].walker = { }
    xr_walker.add_to_binder(self.object, char_ini)

    xr_motivator.storage[self.object:id()].bodyguard = {
            enabled = false,
            action = nil,
            path_main = nil,
            path_side = nil,
      path_guard = nil,
      path_guard_radius = 0,
      path_center = nil
        }
xr_bodyguard.add_to_binder(self.object, char_ini)
    -- схема командира
    xr_motivator.storage[self.object:id()].commander = {
            enabled = false,
            soldiers = {}
    }
xr_commander.add_to_binder(self.object, char_ini)
    -- Настройка патруля
    xr_motivator.storage[self.object:id()].patrol = {
        enabled = false,
            patrol_path = nil,
            escape_path = nil,
            raid_enabled = false,
            raid_path = nil,
            raid_process = false,
            npc_id = -1,
            first_init = false,
            patrol_end = false
    }
xr_patrol.add_to_binder(self.object, char_ini)
    -- Настройка follower
    xr_motivator.storage[self.object:id()].follower = {
            enabled = false,
            leader_name = nil,
            leader = nil,
            escape_path = nil,
            raid_enabled = false,
            raid_path = nil,
            mental_state = anim.free,
            direction = vector():set(0,0,1),
            distance = 2,
            state = 0,
            leader_command = 0,
            npc = self.object,
            look_dir = vector():set(0,0,0),
            npc_id = -1
        }
xr_follower.add_to_binder(self.object, char_ini)
        --chaser
        xr_motivator.storage[self.object:id()].chaser = {
                enabled = false,        --enabled or disabled
                npc = nil,              --sacrifice game_object
                ret_vertex = -1         --level vertex id for return
        }
xr_chaser.add_to_binder (self.object, char_ini)
  -- бандиты в засаде
  xr_motivator.storage[self.object:id()].ambush = {
    enabled = false,
    path = nil,
    dist_sqr = 0
  }
    --‘ Снайпер
	xr_motivator.storage[self.object:id()].sniper =
		{
        enabled  	= false,
        rest_path 	= nil,
        point_path	= nil,
        camper_path = nil,
		enemy		= nil,
        zone		= nil,
        enter       = false,
        monster		= nil
		}
	xr_sniper.add_to_binder(self.object, char_ini)
  
xr_ambush.add_to_binder(self.object, char_ini)
  -- построение солдат на плацу
    if char_ini:section_exist("formation") == true then
		xr_formation.add_to_binder(self.object)
	end

    --Привязка к организации
    if char_ini:section_exist ("fraction") == true then
        if char_ini:line_exist("fraction", "name") == true then
            xr_gulag.addMember(char_ini:r_string("fraction", "name"), self.object, char_ini)
        end
    end
    --Привязка к бандюкам
    if char_ini:section_exist ("bandit") == true then
        if char_ini:line_exist("bandit", "name") == true then
            xr_bandit.addMember(char_ini:r_string("bandit", "name"), self.object, char_ini)
        end
    end

    xr_storyline.set_storyline(self.object, char_ini)
    xr_rest.add_to_binder (self.object, stalker_ids.action_puzzle_solver)

-- помощник, мля !!!
xr_motivator.storage[self.object:id ()].sos =
    {
    enabled = false,
    npc = nil,
    initialized = false,
    code = 0,
  need_follow = false
    }
xr_sos.add_to_binder (self.object, char_ini)

-- раненый.
xr_motivator.storage[self.object:id ()].wounded =
    {
    enabled = false,
    threshold = 0.2,
    sit = false,
    cover = false,
    npc = nil,
    ignore_time = 0,
    final = true,
    immediate = false
    }
xr_wounded.add_to_binder (self.object, char_ini)

end
----------------------------------------------------------------------------------------------------------------------
function pda_callback(recepient, who, msg_type)
    printf("pda prishlo")
    recepient:answer_pda ()
    printf("pda ushlo")
end
----------------------------------------------------------------------------------------------------------------------
function hear_callback(self, who, sound_type, sound_position, sound_power)
--    printf("SOUNDCHECK")
end
----------------------------------------------------------------------------------------------------------------------
function AddToMotivator(npc)
    npc:bind_object(this.motivator_binder(npc))
end
----------------------------------------------------------------------------------------------------------------------
function checkStorage(npc)
    -- FIXME: Zmey: надо бы вынести общую часть кода в отдельную функцию
    local count = 0
    for k,v in xr_motivator.storage[npc:id()] do
        if	k == "sleeper" or
			k == "follower" or
			k == "patrol" or
			k == "guard" or
			k == "walker" or
			k == "bodyguard" or
			k == "commander" or
			k == "ambush" or
			k == "bodyguard" or
			k == "sniper" or
			k == "kamp"
        then
            if v.enabled == true then
                count = count + 1
            end
        end
    end
    if count > 1 then
        printf("ERROR: there is too many active script")
        for k,v in xr_motivator.storage[npc:id()] do
            if	k == "sleeper" or
				k == "follower" or
				k == "patrol" or
				k == "guard" or
				k == "walker" or
				k == "bodyguard" or
				k == "commander" or
				k == "ambush" or
				k == "bodyguard" or
				k == "sniper" or
				k == "kamp"
            then
                if v.enabled == true then
                    printf("ERROR: %s", k)
                end
            end
        end
    end
end