----------------------------------------------------------------------------------------------------------------------
--  Общая схема принятия решений
--  автор: Диденко Руслан (Stohe)
--  TODO:
----------------------------------------------------------------------------------------------------------------------
storage = {}
trade_arhive = {}

class "motivation_action1" (motivation_action)
function motivation_action1:__init(value) super(value)
end

class "action_base1" (action_base)
function action_base1:__init(value) super(value)
end

----------------------------------------------------------------------------------------------------------------------
-- Evaluators
----------------------------------------------------------------------------------------------------------------------
class "evaluator_script" (property_evaluator)
function evaluator_script:__init() super()
end
function evaluator_script:evaluate()
    return false
end

----------------------------------------------------------------------------------------------------------------------
--Motivations
----------------------------------------------------------------------------------------------------------------------
--Alive
class "motivation_alive"    (motivation)
function motivation_alive:__init(motivations, storage, trade_arhive) super()
    self.motivations    = motivations
    self.a          = storage
    self.b          = trade_arhive
end
function motivation_alive:evaluate(motivation_id)
    if self.motivations["normal"] == motivation_id then
        if self.b:best_trader() == nil then
            return 1.0
        else
            return 0.0
        end
    end
    if self.motivations["trade_init"] == motivation_id then
        if self.b:best_trader() ~= nil then
            return 1.0
        else
            return 0.0
        end
    end
    return 0.0
end

----------------------------------------------------------------------------------------------------------------------
--Motivator binder
----------------------------------------------------------------------------------------------------------------------
class "motivator_binder" (object_binder)
----------------------------------------------------------------------------------------------------------------------
function motivator_binder:__init (obj) super(obj)
end
----------------------------------------------------------------------------------------------------------------------
function motivator_binder:reinit()
    object_binder.reinit(self)
    self.object:set_pda_callback(this.pda_call_back)
end
----------------------------------------------------------------------------------------------------------------------
function motivator_binder:net_destroy()
    object_binder.net_destroy(self)
end
----------------------------------------------------------------------------------------------------------------------
function motivator_binder:update(delta)
    object_binder.update(self, delta)
    -- вызов апдейта у управления группировками
    local nn = xr_gulag.isUnderFraction(self.object)

    if nn ~= nil then
        xr_gulag.fraction[nn]:calculate()
    end

    -- вызов апдейта у управления бандюками
    local nn = xr_bandit.isBandit(self.object)

    if nn ~= nil then
        xr_bandit.bandits[nn]:update()
    end

end
----------------------------------------------------------------------------------------------------------------------
function motivator_binder:reload (section)
    object_binder.reload(self, section)

    local char_ini = self.object:spawn_ini()

    local motivations = {}
    local operators = {}
    local properties = {}
    local manager = self.object:motivation_action_manager()
    local goal = world_state()

    motivations["solve_zone_puzzle"]= stalker_ids.motivation_solve_zone_puzzle

    motivations["normal"]       = stalker_ids.motivation_script + 1
    motivations["trade_init"]   = stalker_ids.motivation_script + 2

    properties["alive"]     = stalker_ids.property_alive
    properties["dead"]      = stalker_ids.property_already_dead
    properties["solved"]        = stalker_ids.property_puzzle_solved
    properties["trade_init"]    = xr_evaluators_id.final_trade_init

    -- Bind other scripts
    self.object:disable_talk()

    --загрузка озвучки
    xr_sounds.load_sounds (self.object)

----------------------------------------------------------------------------------------------------------------------
-- Общие скрипты
----------------------------------------------------------------------------------------------------------------------
    xr_motivator.trade_arhive[self.object:id()] = xr_motivator.pda_storage()
    xr_motivator.storage[self.object:id()] = {  followers = {} }
    -- Положения тела 
    xr_motivator.storage[self.object:id()].state = {
            body_state = 0,
            target_state = 0,
            position = nil,
            dist = 2,
            anim = xr_state.anims(self.object)
        }
    xr_state.add_to_binder(self.object)
    -- Настройка схемы реакции
        xr_motivator.storage[self.object:id()].reactions = {
            enabled = true,
            time_wait = 30000, -- 15 секунд ждем повтора
            evn = xr_reactions.events(self.object),
        -- объект раздражения
        obj = { -- позицию раздражителя
                position = nil,
                -- id раздражителя
                id = nil,
                -- как реагировать
                type = nil,
                -- время раздражителя
                time = nil,
            -- видимость
            visibility = nil
        },
        -- правила для обнаружений (какие типы объектов мы игнорим)
            rules = {}
        }
    xr_reactions.add_to_binder(self.object, char_ini)    
    -- схема привязки к позиции
    xr_position.add_to_binder(self.object)
    -- Ответ на PDA сообщение
    xr_motivator.storage[self.object:id()].tradeseller = {   
        Buyer = nil,
            Seller = self.object,
            -- Задается время ожидания в секундах
            begin_wait_to_see = { time = 300,
                                begin = nil },
            -- Будет ли работать схема? если нет, то он всегда будет отказываться от торговли.
            enabled = false
        }
    xr_meet.add_to_binder_pda(self.object, char_ini)

    --Motivations
    manager:remove_motivation (motivations["solve_zone_puzzle"])

    manager:add_motivation (motivations["solve_zone_puzzle"], this.motivation_alive(motivations,
                                        xr_motivator.storage[self.object:id()].tradeseller,
                                        xr_motivator.trade_arhive[self.object:id()]))

    goal:clear ()
    goal:add_property (world_property(properties["solved"], true))
    manager:add_motivation (motivations["normal"], this.motivation_action1(goal))

    goal:clear ()
    goal:add_property (world_property(properties["trade_init"], true))
    manager:add_motivation (motivations["trade_init"], this.motivation_action1(goal))

    -- Connections
    manager:add_connection (motivations["solve_zone_puzzle"], motivations["normal"])
    manager:add_connection (motivations["solve_zone_puzzle"], motivations["trade_init"])

----------------------------------------------------------------------------------------------------------------------
-- Модели поведения
----------------------------------------------------------------------------------------------------------------------
    -- Настройка встречи
    xr_motivator.storage[self.object:id()].meet = {
            enabled = false,
            actor = nil,
            noweap = false, -- игнорируем наличие оружия у актора
            distance = 15, -- расстояние, в пределах которого мы реагируем
            shoot_distance = 5 -- расстояние, в пределах которого мы стреляем
        }
xr_meet.add_to_binder(self.object, char_ini)
    -- лагерь у костра
    xr_motivator.storage[self.object:id()].kamp = {
            -- Будет ли работать схема? если нет, то он не будет пытаться инициализировать камп
            enabled = false,
            -- Патрульный путь из 1 вэйпоинта, который указывает на центр лагеря.
            center_point = nil,
            -- максимальный радиус, в котором рассаживаются люди вокруг центра лагеря
            max_rad = 2,
            -- Идентификатор следующего действия.
            -- 0 - нет действия
            -- 1 - пойти обойти территорию
            action = 0,
            -- Последний выполненный нами экшн, чтобы не повторяться
            last_action = 0,
            -- Патрульные пути, по которым будут сталкеры обходить лагерь
            patrol_path = {},
            -- ID позиции, в которую он сядет
            pos_id = -1,
            -- Положение тела. 0 - стоит, остальное - разные варианты сидения
            body_state = 0,
            -- Время между повторением действий
            timer = { act1 = {begin = nil, time = 120},
                          act4 = {begin = nil, time = 60}}
        }
xr_kamp.add_to_binder(self.object, char_ini)
    -- спящий
    xr_motivator.storage[self.object:id()].sleeper = {
            enabled = false,
                path_main = nil
        }
xr_sleeper.add_to_binder(self.object, char_ini)
    -- часовые
    xr_motivator.storage[self.object:id()].guard = {
            enabled = false,
            action = nil,
            path_main = nil,
            path_hideout = nil
        }
xr_guard.add_to_binder(self.object, char_ini)
    xr_motivator.storage[self.object:id()].bodyguard = {
            enabled = false,
            action = nil,
            path_main = nil,
            path_side = nil,
			path_guard = nil,
			path_guard_radius = 0
        }
xr_bodyguard.add_to_binder(self.object, char_ini)
    -- схема командира
    xr_motivator.storage[self.object:id()].commander = {
            enabled = false,
            soldiers = {}
    }
xr_commander.add_to_binder(self.object, char_ini)
    -- Настройка патруля
    xr_motivator.storage[self.object:id()].patrol = {
        enabled = false,
            patrol_path = nil,
            escape_path = nil,
            raid_enabled = false,
            raid_path = nil,
            raid_process = false,
            npc_id = -1,
            first_init = false,
            patrol_end = false
    }
xr_patrol.add_to_binder(self.object, char_ini)
    -- Настройка follower
    xr_motivator.storage[self.object:id()].follower = {
            enabled = false,
            leader_name = nil,
            leader = nil,
            escape_path = nil,
            raid_enabled = false,
            raid_path = nil,
            mental_state = anim.free,
            direction = vector():set(0,0,1),
            distance = 2,
            state = 0,
            leader_command = 0,
            npc = self.object,
            look_dir = vector():set(0,0,0),
            npc_id = -1
        }
xr_follower.add_to_binder(self.object, char_ini)
        --chaser
        xr_motivator.storage[self.object:id()].chaser = {
                enabled = false,        --enabled or disabled 
                npc = nil,              --sacrifice game_object
                ret_vertex = -1         --level vertex id for return
        }
xr_chaser.add_to_binder (self.object, char_ini)            

    xr_motivator.storage[self.object:id()].ambush = {}
xr_ambush.add_to_binder(self.object, char_ini)

    --Привязка к организации
    if char_ini:section_exist ("fraction") == true then
        if char_ini:line_exist("fraction", "name") == true then
            xr_gulag.addMember(char_ini:r_string("fraction", "name"), self.object, char_ini)
        end
    end
    --Привязка к бандюкам
    if char_ini:section_exist ("bandit") == true then
        if char_ini:line_exist("bandit", "name") == true then
            xr_bandit.addMember(char_ini:r_string("bandit", "name"), self.object, char_ini)
        end
    end

    xr_storyline.set_storyline(self.object, char_ini)
    xr_rest.add_to_binder (self.object, stalker_ids.action_puzzle_solver)
end
----------------------------------------------------------------------------------------------------------------------
function pda_call_back(recepient, who, msg, info_index)
    if msg == game_object.trade_pda_msg then
        xr_motivator.trade_arhive[recepient:id()]:save(who)
    else
        recepient:send_pda_message(4, who)
    end
end
----------------------------------------------------------------------------------------------------------------------
function AddToMotivator(npc)
    npc:bind_object(this.motivator_binder(npc))
end
----------------------------------------------------------------------------------------------------------------------
function checkStorage(npc)
    local count = 0
    for k,v in xr_motivator.storage[npc:id()] do
        if k == "sleeper" or
           k == "follower" or
           k == "patrol" or
           k == "guard" or
           k == "bodyguard" or
           k == "commander"
        then
            if v.enabled == true then
                count = count + 1
            end
        end
    end
    if count > 1 then
        printf("ERROR: there is too many active script")
        for k,v in xr_motivator.storage[npc:id()] do
            if k == "sleeper" or
               k == "follower" or
               k == "patrol" or
               k == "guard" or
           	   k == "bodyguard" or
               k == "commander"
            then
                if v.enabled == true then
                    printf("ERROR: %s", k)
                end
            end
        end
    end
end
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
class "pda_storage"
function pda_storage:__init()
    self.arhive = {}
end
--сохраняет запрос на торговлю в таблицу. Передается тип, который послал запрос
--сохраняются только последние запросы от каждого игрока
function pda_storage:save(npc)
    local tt = { who = npc,
             time = device():time_global()/1000 }

    --удаляем все старые запросы от этого актора
    for a = 1, table.getn(self.arhive), 1 do
        if self.arhive[a].who:id() == npc:id() then
            table.remove(self.arhive, a)
        end
    end

    --добавляем новый
    table.insert(self.arhive, tt)

    self:remove_old()
end
--проверяет на наличие устаревших запросов и удаляет их.
function pda_storage:remove_old()
    local old = 3000 --удаляются все старше 3000 секунд

    for a = 1, table.getn(self.arhive), 1 do
        if device():time_global()/1000 - self.arhive[a].time > old then
            table.remove(self.arhive, a)
        end
    end
end
--Удаляет запрос выбранного чудика
function pda_storage:remove(npc)
    for a = 1, table.getn(self.arhive), 1 do
        if self.arhive[a].who:id() == npc:id() then
            table.remove(self.arhive, a)
        end
    end
end
--возвращает лучшего торговца. Возвращает торговца, запрос которого пришел последним.
function pda_storage:best_trader()
    self:remove_old()
    local tt = nil

    for a = 1, table.getn(self.arhive), 1 do
        if tt == nil or self.arhive[a].time < tt.time then
                tt = self.arhive[a]
        end
    end

    if tt == nil then return nil end

    return tt.who
end