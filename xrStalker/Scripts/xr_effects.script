
-- Кто-то из участников сценки вступил в бой - теперь нужно пообижать всех на всех
function gar_dm_bandits_fight(actor, npc)
	local novice = utils.obj_by_sid(304)
	if not novice or not novice:alive() then
		return
	end

	local ignore_actor = distance_between(actor, novice) > 10

	local bandit1 = utils.obj_by_sid(301)
	if bandit1 then
		novice:set_relation(game_object.enemy, bandit1)
		bandit1:set_relation(game_object.enemy, novice)
		if not ignore_actor then
			bandit1:set_relation(game_object.enemy, actor)
		end
	end

	local bandit2 = level.object("gar_dramscene_bandit2")
	if bandit2 then
		novice:set_relation(game_object.enemy, bandit2)
		bandit2:set_relation(game_object.enemy, novice)
		if not ignore_actor then
			bandit2:set_relation(game_object.enemy, actor)
		end
	end

	local bandit3 = level.object("gar_dramscene_bandit3")
	if bandit3 then
		novice:set_relation(game_object.enemy, bandit3)
		bandit3:set_relation(game_object.enemy, novice)
		if not ignore_actor then
			bandit3:set_relation(game_object.enemy, actor)
		end
	end
end

function gar_dm_bandit_demand(actor, npc)
	printf("_bp: gar_dm_bandit_demand: actor=%s", actor:name())

	if actor:has_info("gar_dm_bandit1_demand") or
	   actor:has_info("gar_dm_bandit2_demand") or
	   actor:has_info("gar_dm_bandit3_demand") then
		return
	end
	local r = math.random(3)
	if r == 1 then
		actor:give_info_portion("gar_dm_bandit1_demand")
	elseif r == 2 then
		actor:give_info_portion("gar_dm_bandit2_demand")
	else
		actor:give_info_portion("gar_dm_bandit3_demand")
	end
end
	
function actor_friend(actor, npc)
	printf("_bp: xr_effects: actor_friend(): npc='%s': time=%d", npc:name(), device():time_global())
	npc:set_relation(game_object.friend, actor)
end

-- Вызов этой функции отключит обработчик [combat] боя для персонажа.
-- Используется в случаях, когда все необходимые действия, такие как переключение на другую секцию,
-- уже выполнены, и повторно выполнять их во время боя нельзя (а условия секции [combat] проверяются на каждом
-- апдейте, когда персонаж в бою, если, конечно, не отключены вызовом этой функции).
function disable_combat_handler(actor, npc)
	if db.storage[npc:id()].combat then
		db.storage[npc:id()].combat.enabled = false
	end
	
	if db.storage[npc:id()].mob_combat then
		db.storage[npc:id()].mob_combat.enabled = false
	end
end

-- Вызов этой функции отключит обработчик [combat_ignore] перехвата боя для персонажа.
function disable_combat_ignore_handler(actor, npc)
	if db.storage[npc:id()].combat_ignore then
		db.storage[npc:id()].combat_ignore.enabled = false
	end
end

function log_bp1(actor, npc)
	printf("xr_effects: log_bp1 (actor='%s', npc='%s'", actor:name(), npc:name())
end

-- FIXME: ЭТО НЕ СОХРАНЯЕТСЯ !!!
local counter = 0
local need_monsters = 0
function garbage_monster_death (actor, npc)
    printf ("Monster %s killed...", npc:name ())
    
    local st = db.storage[npc:id ()]
    if st.death.killer == -1 then return end
    
    -- remove from spawner 
    xr_spawner.remove_from_list (npc:id ())
    
    -- no actor kill monster - simple remove
    if actor == nil or actor:id () ~= st.death.killer then 
       return 
    end
    
    printf ("Monster %s killed by actor", npc:name ())
    
    counter = counter + 1
    printf ("Monsters killed by actor %d", counter)
    need_monsters = need_monsters + 1
    
    -- check for set gulag to normal mode
    if need_monsters > 10 then
       -- set gulag to normal state
       if actor:has_info ("gar_monsters_rush_wave1") then
          actor:disable_info_portion ("gar_monsters_rush_wave1") 
          printf ("Return GULAG to start state")
       end   
    end
    if counter >= 10 then
       actor:give_info_portion ("gar_dolg_help_kill_rush")
       actor:give_info_portion ("gar_dolg_access_rostok")
    end   
    if counter >= 20 then
       actor:give_info_portion ("gar_dolg_help_kill_rush_good")
       xr_gulag.setGulagRelation ("gar_dolg", game_object.friend, actor)
    end   
    if counter >= 30 then
       actor:give_info_portion ("gar_dolg_help_kill_rush_perfect")
    end    
    
end

-- При смерти кровососа дать ему небольшой пинок в сторону вейпоинта, чтобы он упал
-- с обрыва
function val_bs_victim_dead(actor, npc)
	printf("_bp: val_bs_victim_dead: npc='%s'", npc:name())
	local h = hit()
	h.power = 100
	h.direction = utils.vector_copy_by_val(patrol("val_bs_hit_direction"):point(0)):sub(npc:position())
	h.bone = "bip01_spine1"
	h.draftsman = npc 
	h.impulse = 2000
	h.type = hit.wound
	npc:hit(h)
end

-- При смерти пленного дать ему небольшой пинок в сторону вейпоинта, чтобы он упал
-- в пропасть
function val_sacrifice_victim_dead(actor, npc)
	printf("_bp: val_sacrifice_victim_dead: npc='%s'", npc:name())
	local h = hit()
	h.power = 100
	h.direction = utils.vector_copy_by_val(patrol("val_sacrifice_fall_direction"):point(0)):sub(npc:position())
	h.bone = "bip01_spine1"
	h.draftsman = npc 
	h.impulse = 2000
	h.type = hit.wound
	npc:hit(h)
end

function val_suicide_kill_self(actor, npc)
	printf("_bp: val_suicide_kill_self: npc='%s'", npc:name())
	local h = hit()
	h.power = 10000
	h.direction = npc:direction()
	h.bone = "bip01_head"
	h.draftsman = npc 
	h.impulse = 2000
	h.type = hit.wound
	npc:hit(h)
end

function test_hit_in_actor_dir(actor, npc)
--
	-- TODO: реагировать только на смерть от пули (last hit = пуля)
	-- TODO: сделать общей схемой с настройкой через пути
	local actor_pos = utils.vector_copy_by_val(actor:position())
	local npc_pos = npc:position()

	if actor_pos.y >= npc_pos.y - 3.0 then
		-- Если игрок несущественно ниже, или выше - не давать толчек
		return
	end

	printf("_bp: test_hit_in_actor_dir")
	local h = hit()
	h.power = 100
	actor_pos.y = npc_pos.y + 1.0
	h.direction = actor_pos:sub(npc_pos)
	h.bone = "bip01_spine1"
	h.draftsman = npc 
	h.impulse = 2000
	h.type = hit.wound
	npc:hit(h)
--]]
	
--[[
	local actor_pos = utils.vector_copy_by_val(actor:position())
	local npc_pos = npc:position()

	--if actor_pos.y >= npc_pos.y - 3.0 then
		-- Если игрок несущественно ниже, или выше - не давать толчек
	--	return
	--end
	actor_pos.y = npc_pos.y + 1.0
	local pshell = npc:get_physics_shell()
	local dir = actor_pos:sub(npc_pos)
	local constant = 20000
	pshell:apply_force (constant * dir.x, constant * dir.y, constant * dir.z)
--]]
end

function military_sniper_dead (actor, npc)

    local st = db.storage[npc:id ()]
    if st.death.killer == -1 then return end
    if actor == nil or actor:id () ~= st.death.killer then 
       return 
    end
    
    db.actor:give_info_portion ("mil_sniper_dead")
    if db.actor:has_info ("mil_sniper_get_job") then
       db.actor:set_task_state (task.completed, "mil_kill_sniper", 1)
    end   
       
end

function military_dolg_dead (actor, npc)
    -- если нет актера, то вылетаем с грохотом и треском
    if db.actor == nil then return end
    -- если данные не существуют, то создадим
    if db.storage[db.actor:id ()] == nil then
       db.storage[db.actor:id ()] = {}
    end    
    
    if db.storage[db.actor:id ()].mil_dolg == nil then
       db.storage[db.actor:id ()].mil_dolg = {}
       db.storage[db.actor:id ()].mil_dolg["killed"] = 0
       db.storage[db.actor:id ()].mil_dolg["killed_by_actor"] = false
    end    
    -- проапдейтим количество мертвых долговцев
    db.storage[db.actor:id ()].mil_dolg["killed"] = db.storage[db.actor:id ()].mil_dolg["killed"] + 1

    -- взведем флажок, что мужика замочили мы (нужно для Свободы) 
    local st = db.storage[npc:id ()]
    if st.death.killer == -1 then return end
    if actor:id () == st.death.killer then 
       db.storage[db.actor:id ()].mil_dolg["killed_by_actor"] = true
    end
    
    -- если все умерли и была задача мочить снайпера, но сообщать не кому, то
    -- ставим задачу, как не выполненую
    if db.storage[db.actor:id ()].mil_dolg["killed"] == 1 then
       if db.actor:has_info ("mil_sniper_get_job") then 
          db.actor:set_task_state (task.fail, "mil_kill_sniper", 0)
          db.actor:set_task_state (task.fail, "mil_kill_sniper", 2)
          db.actor:disable_info_portion ("mil_sniper_get_job")
       end
       if db.actor:has_info ("mil_lukash_get_job") then
          if db.storage[db.actor:id ()].mil_dolg["killed_by_actor"] == true then
             db.actor:give_info_portion ("mil_lukash_job_complete")
             db.actor:set_task_state (task.completed, "mil_lukash_job", 2)
          else
             --failed
          end
       end        
    end   
    
end
