--[[------------------------------------------------------------------------------------------------------------------
—хема " омандир блокпоста"
„угай —аша

—делать:
    - оттестить звуки во сне
    - водка (ƒима)
    - при сне и водке смотреть не на точку, а в направлении
    - переделать звуки под set_sound
    - звуки внутренней тревоги
--------------------------------------------------------------------------------------------------------------------]]

local prop_commander = xr_evaluators_id.commander_commander

local act_commander  = xr_actions_id.commander_commander

-- состо€ни€ (действи€) автомата в "action_commander"
local walk_inside  = 0
local walk_outside = 1
local look_map     = 2
local look_outside = 3
local outside_talk = 4
local look_box     = 5
local radio_talk   = 6
local drink_vodka  = 7
local sleep        = 8

local snd_base           = xr_sounds_id.chugai_commander_base
local snd_singing        = snd_base + 0
local snd_look_outside   = snd_base + 1
local snd_talk_outside   = snd_base + 2
local snd_enemy_stalker  = snd_base + 3
local snd_enemy_monster  = snd_base + 4
local snd_walking        = snd_base + 5
local snd_lost_box       = snd_base + 6
local snd_lost_box_drunk = snd_base + 7
local snd_drunk          = snd_base + 8
local snd_sleep          = snd_base + 9

local radio_noise        = snd_base + 10
local radio_voice        = snd_base + 11
local radio_on           = snd_base + 12
local radio_off          = snd_base + 13
local radio_commander    = snd_base + 14

local h2ms = 60 * 60 * 1000

---------------------------------------------------------------------------------------------------------------------
-- Ёвалуатор свойства "схема командира активна"
---------------------------------------------------------------------------------------------------------------------
class "evaluator_commander" (property_evaluator)

function evaluator_commander:__init( name, storage ) super ()
    self.a = storage
end

function evaluator_commander:evaluate ()
    --printf( "s1" )
    local b = self.a.enabled == true
--    if b then sb = "true" else sb = "false" end
--    printf( "s2 "..sb )
    return b
end

----------------------------------------------------------------------------------------------------------------------
-- √лавное ƒействие. ѕредставл€ет из себ€ конечный автомат.
----------------------------------------------------------------------------------------------------------------------
class "action_commander" ( action_base )

function action_commander:__init( name, storage )  super ( nil, name )
    self.a = storage
--    self.drunk = true
    self.decision = true
    self.box_alarm = false

    self.sounds_sleeping = {
        idle    = 0,
        maxidle = 2,
        sumidle = 3,
        rnd     = 100,
        sounds  = { { pack = snd_sleep, id = 0 },
                    { pack = snd_sleep, id = 1 } }
    }
end

function action_commander:initialize()
    action_base.initialize( self )
    
    --self.object:set_item( object.idle, self.object:best_weapon() )
--    self.object:set_item( object.idle, nil )

    self.object:set_callback( self, "move_callback", game_object.movement )

--    printf( "action_commander initialized" )
end

function action_commander:finalize()
    action_base.finalize( self )

    self.object:clear_callback( game_object.movement )

    self.object:set_sound_mask( -1 )
    self.object:set_sound_mask( 0 )

    local enemy = self.object:best_enemy()

    if enemy and is_object_online( enemy:id() ) then
        xr_gulag.setFractionState( "blockpost", 1 )

        if enemy:clsid() == clsid.stalker or enemy:clsid() == clsid.actor then
            self.object:play_sound( snd_enemy_stalker, 1, 0 )
        else
            self.object:play_sound( snd_enemy_monster, 1, 0 )
        end
    end
end

function action_commander:walk_to_pos( way, waypoint )
    -- waypoint может быть как индексом, так и именем
    if type( waypoint ) == "string" then
        waypoint = way:index( waypoint )
    end
    
--    printf( "%d", waypoint )

    self.pos = way:point( waypoint )

    self.object:set_node_evaluator      ()
    self.object:set_path_evaluator      ()
    self.object:set_desired_direction   ()
    self.object:set_sight               ( look.danger, nil, 0 )
    --self.object:set_item                ( object.idle, self.object:best_weapon() )
    self.object:set_item                ( object.idle, nil )
    self.object:set_body_state          ( move.standing )
    self.object:set_movement_type       ( move.walk )
    self.object:set_mental_state        ( anim.free )
    self.object:set_path_type           ( game_object.level_path )
    self.object:set_detail_path_type    ( move.line )
    self.object:set_dest_level_vertex_id( way:level_vertex_id( waypoint ) )
    self.object:set_desired_position    ( self.pos )
end

function action_commander:stop()
--    self.object:set_sight               ( look.path_dir, nil, 0 )
    self.object:set_sight               ( look.danger, nil, 0 )
    self.object:set_body_state          ( move.standing )
    self.object:set_movement_type       ( move.stand )
    self.object:set_mental_state        ( anim.free )
end

function action_commander:in_pos()
    return self.pos:distance_to_sqr( self.object:position() ) < 0.25
end

function action_commander:execute()
    action_base.execute( self )

    if self.decision then
        self.decision = false
        self.sub_act  = false
        self.pos      = nil

        self.last_act = self.act

        if day_time() > 7 * h2ms and day_time() < 23 * h2ms then
            repeat
                if not self.drunk then
                    self.act = random_choice_weighted{
                                   [walk_inside]  = 40,
                                   [walk_outside] = 20,
                                   [look_map]     = 10,
                                   [look_outside] = 10,
                                   [radio_talk]   = 20,
                                   [drink_vodka]  = 10 }
                else
                    self.act = random_choice_weighted{
                                   [walk_inside]  = 60,
                                   [walk_outside] = 10,
                                   [look_outside] = 10,
                                   [drink_vodka]  = 20 }
                end
            until self.act == walk_inside or self.act ~= self.last_act
        else
            self.act = random_choice_weighted{
                           [look_outside] = 10,
                           [sleep]        = 90 }
                           --[drink_vodka]  = 90 }
        end

        if self.act == walk_inside and self.last_act ~= walk_inside then
            self.looked_at_box = false
            self.last_inside_point = nil
        end
--        printf( "decision: act=%d last_act=%d", self.act, self.last_act or -1 )
    end

    if self.act == walk_inside then
        self:exec_walk_inside()

    elseif self.act == walk_outside then
        self:exec_walk_outside()

    elseif self.act == look_map then
        self:exec_look_map()

    elseif self.act == look_outside then
        self:exec_look_outside()

    elseif self.act == outside_talk then
        self:exec_outside_talk()

    elseif self.act == look_box then
        self:exec_look_box()

    elseif self.act == radio_talk then
        self:exec_radio_talk()

    elseif self.act == drink_vodka then
        self:exec_drink_vodka()

    elseif self.act == sleep then
        self:exec_sleep()

    else
        self.decision = true
    end
end

-- анимации дл€ сто€ни€ в домике
function action_commander:add_inside_animations( n )
    if self.drunk then
        for i = 1, math.random( n ) * 5 do
            self.object:add_animation( "drunk_idle_0", true )
        end
    else
        for i = 1, math.random( n ) do
            self.object:add_animation(
                random_choice_weighted{
                    ["komandir_4"] = 40,
                    ["komandir_2"] = 40,
                    ["komandir_3"] = 20 },
                true )
        end

        -- чтоб не было дЄрга при переходе в разговор по рации
        self.object:add_animation( "komandir_4", true )
    end
end

function action_commander:exec_walk_inside()
    if self.pos then
        if self:in_pos() then
            if self.sub_act then
                if self.object:animation_count() == 1 then
                    self.decision = true
                end
            else
                self:stop()

                self.sub_act = true

                if self.look_at_box then
                    self.act = look_box
                    printf( "looking for a box" )
                else
                    self:add_inside_animations( 2 )
                end
            end
        else
            -- если сдвинулс€ с позиции, то уйти
            if self.sub_act then
                --self.object:clear_animations()
                self.decision = true
            end
        end
    else
        if not xr_state.change_state( self.object, 0 ) then
            local i

            repeat
                i = math.random( 0, self.a.way_inside:count() - 1 )
            until i ~= self.last_inside_point

            self.last_inside_point = i
            self:walk_to_pos( self.a.way_inside, i )

            self.look_at_box = not self.looked_at_box and self.a.way_inside:flag( i, 0 ) and not self.box_alarm

            local rnd = math.random( 100 )

            if self.drunk then
                if rnd < 60 then
                    self.object:play_sound( snd_drunk, 1, 0 )
                elseif rnd < 90 then
                    self.object:play_sound( snd_singing, 1, 0 )
                end
            else
                if rnd < 40 then
                    self.object:play_sound( snd_walking, 1, 0 )
                elseif rnd < 60 then
                    self.object:play_sound( snd_singing, 1, 0 )
                end
            end

            self.object:clear_animations()

            printf( "[commander] : walk_inside" )
        end
    end
end

function action_commander:exec_look_box()
    if not self.box then
        self.box = level.object( "blockpost_box" )
    end

    if self.box then
        if self.time_end then
            if self.time_end <= device():time_global() then
                if not self.object:see( self.box ) then
                    printf( "[commander] : ящик украли! “ревога!!!" )

                    self.object:set_sound_mask( -1 )
                    self.object:set_sound_mask( 0 )

                    if self.drunk then
                        self.object:play_sound( snd_lost_box_drunk, 1, 0 )
                    else
                        self.object:play_sound( snd_lost_box, 1, 0 )
                    end

                    xr_gulag.setFractionState( "blockpost", 2 )

                    self.box_alarm = true
                else
                    printf( "[commander] : ящик на месте" )
                    self:add_inside_animations( 2 )
                end

                self.look_at_box   = false
                self.looked_at_box = true

                self.time_end = nil

                self.act = walk_inside
            end
        else
            self.object:set_sight( look.point, self.a.way:point( self.a.way:index( "box" ) ):add( vector():set( 0, 1.5, 0 ) ), 0 )
            --self.object:set_sight( look.direction, vector():set( 1, 0, 0 ), 0 )
            self.object:set_mental_state( anim.free )

            self.time_end = device():time_global() + 3000
        end
    else
        self.look_at_box = false
        self.act = walk_inside
        self:add_inside_animations( 2 )
    end
end

function action_commander:exec_walk_outside()
    if not self.sub_act then
        if not xr_state.change_state( self.object, 0 ) then
            self.object:clear_animations()

            self.object:set_node_evaluator    ()
            self.object:set_path_evaluator    ()
            self.object:set_desired_position  ()
            self.object:set_desired_direction ()
            self.object:set_sight             ( look.danger, nil, 0 )
            self.object:set_path_type         ( game_object.patrol_path )
            self.object:set_patrol_path       ( self.a.way_outside, patrol.nearest, patrol.continue, true )
            self.object:set_detail_path_type  ( move.line )
            self.object:set_body_state        ( move.standing )
            self.object:set_movement_type     ( move.walk )
            self.object:set_mental_state      ( anim.free )
            --self.object:set_item              ( object.idle, self.object:best_weapon() )
            self.object:set_item              ( object.idle, nil )

            self.sub_act = true
            self.a.near_door_visited = false

            printf( "[commander] : walk_outside" )
        end
    end
end

function action_commander:exec_look_map()
    if self.pos then
        if self:in_pos() then
            if self.time_end then
                if not self.sub_act then
                    if self.time_end <= device():time_global() then
                        self.object:add_animation( "komandir_"..random_choice( 0, 1 ), true )
                        self.sub_act = true
                    end
                else
                    if self.object:animation_count() == 0 then
                        self.decision = true
                        self.time_end = nil
                    end
                end
            else
                self:stop()

                self.object:set_sight( look.direction, vector():set( 1, 0, 0 ), 0 )
                self.object:set_item ( object.idle, nil )

                self.time_end = device():time_global() + 2000
            end
        else
            -- если сдвинулс€ с позиции, то уйти
            if self.time_end then
                --self.object:clear_animations()
                self.decision = true
                self.time_end = nil
            end
        end
    else
        if not xr_state.change_state( self.object, 0 ) then
            self.object:clear_animations()
            self:walk_to_pos( self.a.way, "level_map" )
            printf( "[commander] : look_map" )
        end
    end
end

function action_commander:exec_look_outside()
    if self.pos then
        if self:in_pos() then
            if self.sub_act then
                if self.object:animation_count() == 0 then
                    self.decision = true
                end
            else
                self:stop()

                self.object:set_item( object.idle, nil )

                self.object:add_animation( "komandir_3", true )
                self.object:add_animation( "komandir_2", true )

                self.object:play_sound( snd_look_outside, 1, 0 )

                self.sub_act = true
            end
        else
            -- если сдвинулс€ с позиции, то уйти
            if self.time_end then
                --self.object:clear_animations()
                self.decision = true
            end
        end
    else
        if not xr_state.change_state( self.object, 0 ) then
            self.object:clear_animations()
            self:walk_to_pos( self.a.way, "near_door" )
            printf( "[commander] : look_outside" )
        end
    end
end

function action_commander:exec_outside_talk()
    if self.time_end then
        if self.time_end <= device():time_global() then
            self.object:set_movement_type ( move.walk )
            self.object:set_sight         ( look.danger, nil, 0 )

            self.act = walk_outside
            self.time_end = nil
        end
    else
        self.object:set_movement_type ( move.stand )
        self.object:set_sight         ( look.point, self.soldier_to_look_at:position():add( vector():set( 0, 1.5, 0 ) ), 0 )

        self.object:play_sound( snd_talk_outside, 1, 0 )

        self.time_end = device():time_global() + 2000
    end
end

function action_commander:exec_radio_talk()
    if self.sub_act then
        if self:process_radio() then
            self.time_end = nil
            self.decision = true
        end
    else
        self.object:clear_animations()
        self:stop()

        self:radio()

        self.object:set_item( object.idle, nil )
        self.object:set_sight( look.direction, self.object:direction(), 0 ) -- против глюка

        self.sub_act = true

        printf( "[commander] : radio_talk" )
    end
end

function action_commander:radio ()
    self.object:add_animation ("raciya_komandir_0", true)
    self.object:add_animation ("raciya_komandir_1", true)
    self.object:add_animation ("raciya_komandir_2", true)
    self.sub_stage = 0
    self.current_phrase = 1

    self.phrases = {}

    table.insert (self.phrases, {namespace = radio_on,        phrase = 0})
    table.insert (self.phrases, {namespace = radio_commander, phrase = random_choice (0, 13)})
    table.insert (self.phrases, {namespace = radio_voice,     phrase = math.random (0, 2)})
    table.insert (self.phrases, {namespace = radio_commander, phrase = random_choice (12, 25)})
    table.insert (self.phrases, {namespace = radio_voice,     phrase = math.random (0, 2)})
    table.insert (self.phrases, {namespace = radio_commander, phrase = 8})

    if random_choice( true, false ) then
        table.insert (self.phrases, {namespace = radio_noise,     phrase = 0})
        table.insert (self.phrases, {namespace = radio_commander, phrase = 17})
    end
    
    table.insert (self.phrases, {namespace = radio_voice,     phrase = math.random (0, 2)})
    table.insert (self.phrases, {namespace = radio_commander, phrase = 25})
    table.insert (self.phrases, {namespace = radio_off,       phrase = 0})

    self.object:set_sound_mask (2147483647)
    self.object:set_sound_mask (0)
end

function action_commander:process_radio()
    local count = self.object:animation_count ()
    local t_size = table.getn (self.phrases)
    
    if self.sub_stage == 0 and count == 1 then
       self.sub_stage = 1 
       return false
    end    
    
    if self.sub_stage == 1 then
       if count == 1 and self.current_phrase < t_size then 
          self.object:add_animation ("raciya_komandir_2", true) 
       end
       if self.object:active_sound_count () == 0 then 
          if self.current_phrase > t_size then
             self.sub_stage = 2 
             self.object:clear_animations ()
             self.object:add_animation ("raciya_komandir_3", true)
             self.object:add_animation ("raciya_komandir_4", true)
             return false
          else
             self.object:play_sound (self.phrases[self.current_phrase].namespace, 1, 0, 1, 0, self.phrases[self.current_phrase].phrase)
             self.current_phrase = self.current_phrase + 1
          end
          return false
       end
    end      

    if count ~= 0 then 
       return false 
    end

    while table.getn (self.phrases) ~= 0 do
          table.remove (self.phrases, 1)
    end
    
    return true
end

--[[function action_commander:exec_drink_vodka()
    if self.pos then
        if self:in_pos() then
            if self.sub_act then
                if self.object:animation_count() == 0 then
                    self.decision = true
                elseif self.object:animation_count() == 6 and self.no_vodka then
                    self.object:set_item( object.activate, self.object:object( "vodka" ) )
                    self.no_vodka = false
                end
            else
                self:stop()

                self.object:set_sight( look.point, self.a.way:point( self.a.way:index( "mattress_dir" ) ):add( vector():set( 0, 0.5, 0 ) ), 0 )

                self.object:add_animation( "stalker_2_down", true )
                self.object:add_animation( "vodka_1", true )
                self.object:add_animation( "vodka_2", true )
                self.object:add_animation( "vodka_3", true )
                self.object:add_animation( "vodka_4", true )
                self.object:add_animation( "vodka_2", true )
                self.object:add_animation( "stalker_2_up", true )
               
                if day_time() > 14 * h2ms then
                    self.drunk = true
                end

                self.sub_act = true
                self.no_vodka = true
            end
        else
            -- если сдвинулс€ с позиции, то уйти
            if self.sub_act then
                self.decision = true
            end
        end
    else
        self.object:clear_animations()
        self:walk_to_pos( self.a.way, "mattress" )
        printf( "[commander] : drink_vodka" )
    end
end]]

function action_commander:exec_drink_vodka()
    if self.pos then
        if self:in_pos() then
            if self.sub_act then
                local dt = self.time_end - device():time_global()

                if dt < 0 then 
--                    if not xr_state.change_state( self.object, 0 ) then
                        self.decision = true
                        self.time_end = nil
--                    end
                elseif dt < 3000 then
                    if self.vodka_active then
                        self.object:set_item( object.deactivate, self.object:object( "vodka" ) )
                        self.vodka_active = false
                        printf( "[commander] : ”Ѕ»–јё ¬ќƒ ”" )
                    end
                elseif dt < 20000 then
                    if not self.vodka_active then
                        self.object:set_item( object.use, self.object:object( "vodka" ) )
                        self.vodka_active = true
                        printf( "[commander] : Ќј„»Ќјё ѕ»“№" )
                    end
                end
                
            else
                self:stop()
                self.object:set_sight( look.point, self.a.way:point( self.a.way:index( "mattress_dir" ) ):add( vector():set( 0, 0.5, 0 ) ), 0 )

                if xr_state.change_state( self.object, 2 ) then 
                    printf( "[commander] : Ќј„»Ќјё —јƒ»“№—я" )
                else
                    if day_time() > 14 * h2ms then
                        self.drunk = true
                    end

                    self.sub_act = true
                    self.time_end = device():time_global() + 20000
                    self.vodka_active = false
                    
                    printf( "[commander] : —≈Ћ" )
                end
            end
        else
            -- если сдвинулс€ с позиции, то уйти
            if self.sub_act then
                --self.object:clear_animations()
                self.decision = true
                self.time_end = nil
            end
        end
    else
        if self.last_act == sleep then
            self.pos = self.a.way:point( self.a.way:index( "mattress" ) )
            return
        end

        if not xr_state.change_state( self.object, 0 ) then
            self.object:clear_animations()
            self:walk_to_pos( self.a.way, "mattress" )
            printf( "[commander] : drink_vodka" )
        end
    end
end

function action_commander:exec_sleep()
    if self.pos then
        if self:in_pos() then
            if self.time_end then
                if self.time_end <= game.time() then
                    -- к 4 утра он протрезвеет
                    if self.time_end >= 4 * h2ms then
                        self.drunk = false
                    end

                    self.decision = true
                    self.time_end = nil
                end
            else
                self:stop()
                self.object:set_sight( look.point, self.a.way:point( self.a.way:index( "mattress_dir" ) ), 0 )
                self.object:set_item ( object.idle, nil )
                
                if not xr_state.change_state( self.object, 4 ) then 
                    -- через час он проснЄтс€ и примет новое решение
                    self.time_end = game.time() + h2ms
                end
            end

            globals.set_sound( self.object, self.sounds_sleeping )
        else
            -- если сдвинулс€ с позиции, то уйти
            if self.time_end then
                --self.object:clear_animations()
                self.decision = true
                self.time_end = nil
            end
        end
    else
        if self.last_act == sleep or self.last_act == drink_vodka then
            self.pos = self.a.way:point( self.a.way:index( "mattress" ) )
            return
        end

        if not xr_state.change_state( self.object, 0 ) then
            self.object:clear_animations()
            self:walk_to_pos( self.a.way, "mattress" )
            printf( "[commander] : sleep" )
        end
    end
end

function action_commander:move_callback( obj, action_type, index )
    --printf( "%d", index )

    if index == -1 then return end

    if index == self.a.near_door_index then
        if self.a.near_door_visited then
            self.decision = true
            return
        else
            self.a.near_door_visited = true
        end
    end

    if math.random( 100 ) <= 60 then
        local pos = self.object:position()

        for i, name in ipairs( self.a.soldiers ) do
            local soldier = level.object( name )

            if soldier and soldier:alive() and pos:distance_to_sqr( soldier:position() ) <= 64 then
                --and self.object:see( soldier ) then
                self.act = outside_talk
                self.soldier_to_look_at = soldier
                break
            end
        end
    else
        self.object:play_sound( snd_walking, 1, 0 )
    end
end

----------------------------------------------------------------------------------------------------------------------

function add_to_binder( npc )
    -- звуки
    npc:add_sound( "script_replics\\comandir_1\\drunk\\comandir_song_",         13, snd_type.talk, 2, 1, snd_singing )
    npc:add_sound( "script_replics\\comandir_1\\drunk\\comandir_outside_",      13, snd_type.talk, 2, 1, snd_look_outside )
    npc:add_sound( "script_replics\\comandir_1\\normal\\comandir_to_soldier_",  13, snd_type.talk, 2, 1, snd_talk_outside )
    npc:add_sound( "script_replics\\comandir_1\\drunk\\comandir_see_enemy_",    13, snd_type.talk, 2, 1, snd_enemy_stalker )
    npc:add_sound( "script_replics\\comandir_1\\normal\\comandir_alarm_",       13, snd_type.talk, 2, 1, snd_enemy_monster )
    npc:add_sound( "script_replics\\comandir_1\\normal\\comandir_walking_",     13, snd_type.talk, 2, 1, snd_walking )
    npc:add_sound( "script_replics\\comandir_1\\normal\\comandir_lostbox_",     13, snd_type.talk, 2, 1, snd_lost_box )
    npc:add_sound( "script_replics\\comandir_1\\drunk\\comandir_lostbox_",      13, snd_type.talk, 2, 1, snd_lost_box_drunk )
    npc:add_sound( "script_replics\\comandir_1\\drunk\\comandir_dronk_",        13, snd_type.talk, 2, 1, snd_drunk )
    npc:add_sound( "script_replics\\comandir_1\\drunk\\comandir_sleep_",        13, snd_type.talk, 2, 1, snd_sleep )

    npc:add_sound( "script_replics\\radio\\commander\\radio_commander_",        30, snd_type.talk, 2, 1, radio_commander )
    npc:add_sound( "script_replics\\radio\\message\\radio_noise_",               5, snd_type.talk, 2, 1, radio_noise )
    npc:add_sound( "script_replics\\radio\\message\\radio_voice_",               5, snd_type.talk, 2, 1, radio_voice )
    npc:add_sound( "script_replics\\radio\\message\\radio_turn_on_",             5, snd_type.talk, 2, 1, radio_on )
    npc:add_sound( "script_replics\\radio\\message\\radio_turn_off_",            5, snd_type.talk, 2, 1, radio_off )

    -- GOAP
    local a = xr_motivator.storage[npc:id()].commander

    local action = this.action_commander( "action_commander", a )

    local manager = npc:motivation_action_manager()

    manager:add_evaluator( prop_commander, this.evaluator_commander( "property_commander", a ) )

    action:add_precondition( world_property( stalker_ids.property_enemy,    false ) )
    action:add_precondition( world_property( xr_evaluators_id.state_change, true  ) )
    action:add_effect( world_property( prop_commander, false ) )
    manager:add_action( act_commander, action )

    action = manager:action( stalker_ids.action_puzzle_solver )
    action:add_precondition( world_property( prop_commander, false ) )
end

function init_commander( npc, a )
    local char_ini = npc:spawn_ini()

    if char_ini:section_exist("commander") then
        -- включен?
        if char_ini:line_exist("commander", "enabled") then     
            if not char_ini:r_bool("commander", "enabled") then
                return false
            end
        else
            return false
        end
        
        -- пути
        if char_ini:line_exist("commander", "way") and
           char_ini:line_exist("commander", "way_inside") and
           char_ini:line_exist("commander", "way_outside") then
            a.way         = patrol( char_ini:r_string( "commander", "way" ) )
            a.way_inside  = patrol( char_ini:r_string( "commander", "way_inside" ) )
            a.way_outside = char_ini:r_string( "commander", "way_outside" )

            a.near_door_index = patrol( a.way_outside ):index( "near_door" )
        else
            return false
        end

        -- солдаты
        if char_ini:line_exist("commander", "soldiers") then
            local soldiers = char_ini:r_string( "commander", "soldiers" )
            a.soldiers = parse_names( soldiers )
        end
    else
        --printf( "no section" )
        return false
    end

    return true
end

function set_commander( npc, enable )
    local a = xr_motivator.storage[npc:id()].commander

    if enable == nil then
        a.enabled = this.init_commander( npc, a )
    else
        a.enabled = enable and this.init_commander( npc, a )
    end
end
