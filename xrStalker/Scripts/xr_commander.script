--[[------------------------------------------------------------------------------------------------------------------
Схема "Командир" (Универсальная схема поведения командиров)
Чугай Саша

Сделать:
	- учесть одновременный доклад и втыкание на актёра
    - set_sound
    - рация по темам
    - конфигурация веса path_talk
    - отдельная точка тревоги для box_alarm при краже объекта
    - проверять не инвентарь игрока, а родительский объект ящика
    - переименовать near_door

    - звук и пауза при обнаружении кражи, а потом бегом поднимать тревогу
    - оттестить звуки во сне
    - водка (Дима)
    - звуки внутренней тревоги

--------------------------------------------------------------------------------------------------------------------]]

local prop_commander		= xr_evaluators_id.chugai_commander_base
local prop_dead_hook		= xr_evaluators_id.chugai_commander_base + 1
local prop_actor_is_close	= xr_evaluators_id.chugai_commander_base + 2

local act_commander		= xr_actions_id.chugai_commander_base
local act_dead_hook		= xr_actions_id.chugai_commander_base + 1
local act_look_at_actor	= xr_actions_id.chugai_commander_base + 2

-- состояния (действия) автомата в "action_commander"
local walk_random      = 0
local walk_path        = 1
local look_map         = 2
local stretch_himself  = 3
local path_talk        = 4
local look_after       = 5
local radio_talk       = 6
local drink_vodka      = 7
local sleep            = 8
local alarm_look_after = 9

local act_str2num = {
    walk_random      = walk_random,
    walk_path        = walk_path,
    look_map         = look_map,
    stretch_himself  = stretch_himself,
    path_talk        = path_talk,
    look_after       = look_after,
    radio_talk       = radio_talk,
    drink_vodka      = drink_vodka,
    sleep            = sleep,
    alarm_look_after = alarm_look_after
}

local snd_base            = 1
local snd_singing         = snd_base + 0
local snd_stretch_himself = snd_base + 1
local snd_talk_path       = snd_base + 2
local snd_enemy_stalker   = snd_base + 3
local snd_enemy_monster   = snd_base + 4
local snd_walking         = snd_base + 5
local snd_lost_box        = snd_base + 6
local snd_lost_box_drunk  = snd_base + 7
local snd_drunk           = snd_base + 8
local snd_sleep           = snd_base + 9

local radio_noise         = snd_base + 10
local radio_voice         = snd_base + 11
local radio_on            = snd_base + 12
local radio_off           = snd_base + 13
local radio_commander     = snd_base + 14

local h2ms = 60 * 60 * 1000

local the_actor

---------------------------------------------------------------------------------------------------------------------
-- Эвалуатор свойства "схема командира активна"
---------------------------------------------------------------------------------------------------------------------
class "evaluator_commander" (property_evaluator)

function evaluator_commander:__init( name, storage ) super ()
    self.a = storage
end

function evaluator_commander:evaluate ()
    --printf( "s1" )
    local b = self.a.enabled == true
--    if b then sb = "true" else sb = "false" end
--    printf( "s2 "..sb )
    return b
end

---------------------------------------------------------------------------------------------------------------------
-- Эвалуатор свойства "актёр близко"
---------------------------------------------------------------------------------------------------------------------
class "evaluator_actor_is_close" ( property_evaluator )

function evaluator_actor_is_close:__init( name, npc ) super()
    self.npc = npc
end

function evaluator_actor_is_close:evaluate()
    if not the_actor then
        the_actor = level.actor()
    end

    return false --the_actor ~= nil and the_actor:position():distance_to_sqr( self.npc:position() ) < 6.25
end

---------------------------------------------------------------------------------------------------------------------
-- Эвалуатор свойства "перехвачено ли уже событие смерти командира?"
---------------------------------------------------------------------------------------------------------------------
class "evaluator_dead_hook" ( property_evaluator )

function evaluator_dead_hook:__init( name, storage ) super()
    self.a = storage
end

function evaluator_dead_hook:evaluate()
    return self.a.dead_hook
end

----------------------------------------------------------------------------------------------------------------------
-- Главное Действие. Представляет из себя конечный автомат.
----------------------------------------------------------------------------------------------------------------------
class "action_commander" ( action_base )

function action_commander:__init( name, storage )  super ( nil, name )
    self.a = storage
--    self.drunk = true
    self.decision = true
    self.already_alarm = false

    self.sounds_sleeping = {
        idle    = 0,
        maxidle = 2,
        sumidle = 3,
        rnd     = 100,
        sounds  = { { pack = snd_sleep, id = 0 },
                    { pack = snd_sleep, id = 1 } }
    }
end

function action_commander:initialize()
    action_base.initialize( self )
    
--    self.object:set_item( object.idle, self.object:best_weapon() )
--    self.object:set_item( object.idle, nil )

    self.object:set_callback( self, "move_callback", game_object.movement )

    if not self.zone and self.a.zone_name then 
        self.zone = level.object( self.a.zone_name )
    end

    if self.zone then
        self.zone:set_callback( self, "zone_callback", true )
    end
--    printf( "action_commander initialized" )
end

function action_commander:finalize()
    action_base.finalize( self )

    self.object:clear_callback( game_object.movement )

    if self.zone then
        self.zone:clear_callback( true )
    end

    self.object:set_sound_mask( -1 )
    self.object:set_sound_mask( 0 )

    local enemy = self.object:best_enemy()

    if enemy and is_object_online( enemy:id() ) then
        xr_gulag.setFractionState( self.a.fraction, 1 )

        if get_clsid(enemy) == clsid.stalker or get_clsid(enemy) == clsid.actor then
            --self.object:play_sound( snd_enemy_stalker, 1, 0 )
            xr_sounds.play_sound( self.object, 0, self.a.snd_theme, 1, snd_enemy_stalker )
        else
            --self.object:play_sound( snd_enemy_monster, 1, 0 )
            xr_sounds.play_sound( self.object, 0, self.a.snd_theme, 1, snd_enemy_monster )
        end
    end
end

function action_commander:walk_to_pos( way, waypoint, run )
    -- waypoint может быть как индексом, так и именем
    if type( waypoint ) == "string" then
        waypoint = way:index( waypoint )
    end
    
--    printf( "%d", waypoint )

    self.pos = way:point( waypoint )

    self.object:set_node_evaluator      ()
    self.object:set_path_evaluator      ()
    self.object:set_desired_direction   ()
    self.object:set_sight               ( look.danger, nil, 0 )
    --self.object:set_item                ( object.idle, self.object:best_weapon() )
    self.object:set_item                ( object.idle, nil )
    self.object:set_body_state          ( move.standing )
    self.object:set_path_type           ( game_object.level_path )
    self.object:set_detail_path_type    ( move.line )
    self.object:set_dest_level_vertex_id( way:level_vertex_id( waypoint ) )
    self.object:set_desired_position    ( self.pos )

    if run then 
        self.object:set_mental_state    ( anim.danger )
        self.object:set_movement_type   ( move.run )
    else
        self.object:set_mental_state    ( anim.free )
        self.object:set_movement_type   ( move.walk )
    end
end

function action_commander:stop()
    self.object:set_sight               ( look.danger, nil, 0 )
    self.object:set_body_state          ( move.standing )
    self.object:set_movement_type       ( move.stand )
    self.object:set_mental_state        ( anim.free )
end

function action_commander:in_pos()
    return self.pos:distance_to_sqr( self.object:position() ) < 0.25
end

function action_commander:execute()
    action_base.execute( self )

    if not the_actor then
        the_actor = level.actor()
    end

    if the_actor and self.object:see( the_actor ) then
        local item = the_actor:active_item()

        if item and isWeapon( item ) then
            self.object:set_relation( game_object.enemy, the_actor )
            return
        end
    end

    if self.decision or self.a.continue_act then
        self.decision		= false
        self.sub_act		= false
        self.pos			= nil
        self.time_end		= nil	-- <<< !!!!!!!!!!! проверить, можно ли здесь это делать
        self.a.continue_act	= false

        self.last_act = self.act

        if day_time() > 7 * h2ms and day_time() < 23 * h2ms then
            repeat
                if not self.drunk then
                    self.act = random_choice_weighted( self.a.acts[1] )
                else
                    self.act = random_choice_weighted( self.a.acts[2])
                end                
            until self.act == walk_random or self.act ~= self.last_act
            --until self.act ~= self.last_act
        else
            self.act = random_choice_weighted( self.a.acts[3] )
        end

        if self.act == look_map        or
           self.act == sleep           or
           self.act == stretch_himself or
           self.act == drink_vodka     or
           self.act == walk_random
		then
            --self.object:play_sound( random_choice( snd_drunk, snd_walking, snd_singing ), 1, 0 )
--            xr_sounds.play_sound( self.object, math.random( 500 ), self.a.snd_theme, 1,
--                                  random_choice( snd_drunk, snd_walking, snd_singing ) )
			xr_sounds.play_sound( self.object, math.random( 500 ), self.a.snd_theme, 1,
                                  random_choice( snd_walking, snd_singing ) )
        end
--        printf( "decision: act=%d last_act=%d", self.act, self.last_act or -1 )
    end

    if self.act == walk_random then
        self:exec_walk_random()

    elseif self.act == walk_path then
        self:exec_walk_path()

    elseif self.act == look_map then
        self:exec_look_map()

    elseif self.act == stretch_himself then
        self:exec_stretch_himself()

    elseif self.act == path_talk then
        self:exec_path_talk()

    elseif self.act == look_after then
        self:exec_look_after()

    elseif self.act == radio_talk then
        self:exec_radio_talk()

    elseif self.act == drink_vodka then
        self:exec_drink_vodka()

    elseif self.act == sleep then
        self:exec_sleep()

    elseif self.act == alarm_look_after then
        self:exec_alarm_look_after()

    else
        self.decision = true
    end
end

-- анимации для стояния в домике
function action_commander:add_walk_random_animations( n )
    if self.drunk then
        for i = 1, math.random( n ) * 5 do
            self.object:add_animation( "drunk_idle_0", true )
        end
    else
        for i = 1, math.random( n ) do
            self.object:add_animation(
                random_choice_weighted{
                    ["komandir_4"] = 40,
                    ["komandir_2"] = 40,
                    ["komandir_3"] = 20 },
                true )
        end

        -- чтоб не было дёрга при переходе в разговор по рации
        self.object:add_animation( "komandir_4", true )
    end
end

function action_commander:exec_walk_random()
    if self.pos then
        if self:in_pos() then
            if self.time_end then
                if not self.sub_act then
                    if self.time_end <= device():time_global() then
                        self:add_walk_random_animations( 1 )
                        self.sub_act = true
                    end
                else    
                    if self.object:animation_count() == 1 then
                        self.decision = true
                        self.time_end = nil
                    end
                end
            else
                self:stop()

--                local look_point = self.a.way_random:point( self.last_walk_random_point + 1 ):add( vector():set( 0, 1.8, 0 ) )
--                self.object:set_sight( look.point, look_point, 0 )
                local dir = self.a.way_random:point( self.last_walk_random_point + 1 ):sub( self.object:position() )
                self.object:set_sight( look.direction, dir, 0 )

                self.time_end = device():time_global() + 2000
            end
        else
            -- если сдвинулся с позиции, то уйти
            if self.sub_act then
                self.decision = true
                self.time_end = nil
            end
        end
    else
        if not xr_state.change_state( self.object, 0 ) then
            local i

            repeat
                i = math.random( 0, self.a.way_random:count() * 0.5 - 1 ) * 2
            until i ~= self.last_walk_random_point

            self.last_walk_random_point = i
            self:walk_to_pos( self.a.way_random, i )

--[[            local rnd = math.random( 100 )

            if self.drunk then
                if rnd < 60 then
                    self.object:play_sound( snd_drunk, 1, 0 )
                elseif rnd < 90 then
                    self.object:play_sound( snd_singing, 1, 0 )
                end
            else
                if rnd < 40 then
                    self.object:play_sound( snd_walking, 1, 0 )
                elseif rnd < 60 then
                    self.object:play_sound( snd_singing, 1, 0 )
                end
            end]]
            
            self.object:clear_animations()

--            printf( "[commander] : walk_random" )
        end
    end
end

function action_commander:actor_has_box()
    if not the_actor then
        the_actor = level.actor()
    end

    return the_actor and the_actor:object( "quest_case_01" )
end

function action_commander:exec_look_after()
    if self.time_end then
        if self.time_end <= device():time_global() then
--            if not self.object:see( self.obj_look_after ) then
--            if self.object:position():distance_to_sqr( self.obj_look_after:position() ) > 25 then
            if self.object:position():distance_to_sqr( self.obj_look_after:position() ) > 25 or self:actor_has_box() then
--                printf( "[commander] : Ящик украли! Тревога!!!" )
                self.act = alarm_look_after
                self.already_alarm = true
            else
--                printf( "[commander] : Ящик на месте" )
                --self:add_walk_random_animations( 1 )
                --self.act = walk_random
                self.act = self.act_before_look_after
            end

            self.time_end = nil
            self.pos      = nil
            self.sub_act  = nil
        end
    else
        self:stop()
        self.object:set_sight( look.point, self.a.way:point( self.a.way:index( "look_after" ) ):add( vector():set( 0, 1.5, 0 ) ), 0 )
--        self.object:set_sight( look.point, self.a.way:point( self.a.way:index( "look_after" ) ), 0 )
--        self.object:set_sight( look.point, self.obj_look_after:position(), 0 )
        self.object:set_mental_state( anim.free )

        self.time_end = device():time_global() + 3000
    end
end

function action_commander:exec_alarm_look_after()
    if self.pos then
        if self:in_pos() then
            if self.sub_act then
                if self.object:animation_count() == 0 then
                    self.decision = true
                    self.object:set_item( object.idle, nil )
--                    self.object:play_sound( snd_walking, 1, 0, 1, 0, random_choice( 1, 2 ) )
                    xr_sounds.play_sound( self.object, 0, self.a.snd_theme, 1, snd_walking, random_choice( 1, 2 ) )
                end
            else
                self:stop()

                for i = 1, 6 do
                    self.object:add_animation( "poisk_idle_4", true )
                end

                self.object:set_sound_mask( -1 )
                self.object:set_sound_mask( 0 )

                if self.drunk then
                    --self.object:play_sound( snd_lost_box_drunk, 1, 0 )
                    xr_sounds.play_sound( self.object, 0, self.a.snd_theme, 1, snd_lost_box_drunk )
                else
                    --self.object:play_sound( snd_lost_box, 1, 0 )
                    xr_sounds.play_sound( self.object, 0, self.a.snd_theme, 1, snd_lost_box )
                end

                xr_gulag.setFractionState( self.a.fraction, 2 )

                self.sub_act = true
            end
        else
            -- если сдвинулся с позиции, то уйти
            if self.time_end then
                --self.object:clear_animations()
                self.decision = true
                self.object:set_item( object.idle, nil )
            end
        end
    else
        self.object:clear_animations()
        self:walk_to_pos( self.a.way, "near_door", true )
        self.object:set_item( object.activate, self.object:best_weapon() )
    end
end

function action_commander:exec_walk_path()
    if not self.sub_act then
        if not xr_state.change_state( self.object, 0 ) then
            self.object:clear_animations()

            self.object:set_node_evaluator    ()
            self.object:set_path_evaluator    ()
            self.object:set_desired_position  ()
            self.object:set_desired_direction ()
            self.object:set_sight             ( look.danger, nil, 0 )
            self.object:set_path_type         ( game_object.patrol_path )
            self.object:set_patrol_path       ( self.a.way_path, patrol.nearest, patrol.continue, true )
            self.object:set_detail_path_type  ( move.line )
            self.object:set_body_state        ( move.standing )
            self.object:set_movement_type     ( move.walk )
            self.object:set_mental_state      ( anim.free )
            --self.object:set_item              ( object.idle, self.object:best_weapon() )
            self.object:set_item              ( object.idle, nil )

            self.sub_act = true
            self.a.near_door_visited = false

--            printf( "[commander] : walk_path" )
        end
    end
end

function action_commander:exec_look_map()
    if self.pos then
        if self:in_pos() then
            if self.time_end then
                if not self.sub_act then
                    if self.time_end <= device():time_global() then
                        self.object:add_animation( "komandir_"..random_choice( 0, 1 ), true )
                        self.sub_act = true
                    end
                else
                    if self.object:animation_count() == 0 then
                        self.decision = true
                        self.time_end = nil
                    end
                end
            else
                self:stop()

                self.object:set_sight( look.direction, vector():set( 1, 0, 0 ), 0 )
                self.object:set_item ( object.idle, nil )

                self.time_end = device():time_global() + 2000
            end
        else
            -- если сдвинулся с позиции, то уйти
            if self.time_end then
                --self.object:clear_animations()
                self.decision = true
                self.time_end = nil
            end
        end
    else
        if not xr_state.change_state( self.object, 0 ) then
            self.object:clear_animations()
            self:walk_to_pos( self.a.way, "level_map" )
--            printf( "[commander] : look_map" )
        end
    end
end

function action_commander:exec_stretch_himself()
    if self.pos then
        if self:in_pos() then
            if self.sub_act then
                if self.object:animation_count() == 0 then
                    self.decision = true
                end
            else
                self:stop()

                self.object:set_item( object.idle, nil )

                self.object:add_animation( "komandir_3", true )
--                self.object:add_animation( "komandir_2", true )

                --self.object:play_sound( snd_stretch_himself, 1, 0 )
                xr_sounds.play_sound( self.object, 0, self.a.snd_theme, 1, snd_stretch_himself )

                self.sub_act = true
            end
        else
            -- если сдвинулся с позиции, то уйти
            if self.time_end then
                --self.object:clear_animations()
                self.decision = true
            end
        end
    else
        if not xr_state.change_state( self.object, 0 ) then
            self.object:clear_animations()
            self:walk_to_pos( self.a.way, "near_door" )
--            printf( "[commander] : stretch_himself" )
        end
    end
end

function action_commander:exec_path_talk()
    if self.time_end then
        if self.time_end <= device():time_global() then
            self.object:set_movement_type ( move.walk )
            self.object:set_sight         ( look.danger, nil, 0 )

            self.act = walk_path
            self.time_end = nil
        end
    else
        self.object:set_movement_type ( move.stand )
        self.object:set_sight         ( look.point, self.soldier_to_look_at:position():add( vector():set( 0, 1.5, 0 ) ), 0 )

        --self.object:play_sound( snd_talk_path, 1, 0 )
        xr_sounds.play_sound( self.object, 0, self.a.snd_theme, 1, snd_talk_path )

        self.time_end = device():time_global() + 2000
    end
end

function action_commander:exec_radio_talk()
    if self.sub_act then
        if self:process_radio() then
            self.time_end = nil
            self.decision = true
        end
    else
        self.object:set_item( object.idle, nil )
        self.object:set_sight( look.direction, self.object:direction(), 0 ) -- против глюка

        if not xr_state.change_state( self.object, 0 ) then
            self.object:clear_animations()

            if self.last_act == walk_path then
                self:stop()
            end

            self:radio()

            self.sub_act = true

--            printf( "[commander] : radio_talk" )
       end
    end
end

function action_commander:radio()
    self.object:add_animation ("raciya_komandir_0", true)
    self.object:add_animation ("raciya_komandir_1", true)
    self.object:add_animation ("raciya_komandir_2", true)
    self.sub_stage = 0
    self.current_phrase = 1

    self.phrases = {}

    table.insert (self.phrases, {namespace = radio_on,        phrase = 0})
    table.insert (self.phrases, {namespace = radio_commander, phrase = random_choice (0, 13)})
    table.insert (self.phrases, {namespace = radio_voice,     phrase = math.random (0, 2)})
    table.insert (self.phrases, {namespace = radio_commander, phrase = random_choice (12, 25)})
    table.insert (self.phrases, {namespace = radio_voice,     phrase = math.random (0, 2)})
    table.insert (self.phrases, {namespace = radio_commander, phrase = 8})

    if random_choice( true, false ) then
        table.insert (self.phrases, {namespace = radio_noise,     phrase = 0})
        table.insert (self.phrases, {namespace = radio_commander, phrase = 17})
    end
    
    table.insert (self.phrases, {namespace = radio_voice,     phrase = math.random (0, 2)})
    table.insert (self.phrases, {namespace = radio_commander, phrase = 25})
    table.insert (self.phrases, {namespace = radio_off,       phrase = 0})

    self.object:set_sound_mask (2147483647)
    self.object:set_sound_mask (0)
end

function action_commander:process_radio()
    local count = self.object:animation_count ()
    local t_size = table.getn (self.phrases)
    
    if self.sub_stage == 0 and count == 1 then
       self.sub_stage = 1 
       return false
    end    
    
    if self.sub_stage == 1 then
       if count == 1 and self.current_phrase < t_size then 
          self.object:add_animation ("raciya_komandir_2", true) 
       end
       if self.object:active_sound_count () == 0 then 
          if self.current_phrase > t_size then
             self.sub_stage = 2 
             self.object:clear_animations ()
             self.object:add_animation ("raciya_komandir_3", true)
             self.object:add_animation ("raciya_komandir_4", true)
             return false
          else
             --self.object:play_sound (self.phrases[self.current_phrase].namespace, 1, 0, 1, 0, self.phrases[self.current_phrase].phrase)
             xr_sounds.play_sound( self.object, 0, self.a.snd_theme, 1, self.phrases[self.current_phrase].namespace,
                                   self.phrases[self.current_phrase].phrase )

             self.current_phrase = self.current_phrase + 1
          end
          return false
       end
    end      

    if count ~= 0 then 
       return false 
    end

    while table.getn (self.phrases) ~= 0 do
          table.remove (self.phrases, 1)
    end
    
    return true
end

--[[function action_commander:exec_drink_vodka()
    if self.pos then
        if self:in_pos() then
            if self.sub_act then
                if self.object:animation_count() == 0 then
                    self.decision = true
                elseif self.object:animation_count() == 6 and self.no_vodka then
                    self.object:set_item( object.activate, self.object:object( "vodka" ) )
                    self.no_vodka = false
                end
            else
                self:stop()

                self.object:set_sight( look.point, self.a.way:point( self.a.way:index( "mattress_dir" ) ):add( vector():set( 0, 0.5, 0 ) ), 0 )

                self.object:add_animation( "stalker_2_down", true )
                self.object:add_animation( "vodka_1", true )
                self.object:add_animation( "vodka_2", true )
                self.object:add_animation( "vodka_3", true )
                self.object:add_animation( "vodka_4", true )
                self.object:add_animation( "vodka_2", true )
                self.object:add_animation( "stalker_2_up", true )
               
                if day_time() > 14 * h2ms then
                    self.drunk = true
                end

                self.sub_act = true
                self.no_vodka = true
            end
        else
            -- если сдвинулся с позиции, то уйти
            if self.sub_act then
                self.decision = true
            end
        end
    else
        self.object:clear_animations()
        self:walk_to_pos( self.a.way, "mattress" )
        printf( "[commander] : drink_vodka" )
    end
end]]

function action_commander:exec_drink_vodka()
    if self.pos then
        if self:in_pos() then
            if self.sub_act then
                local dt = self.time_end - device():time_global()

                if dt < 0 then 
--                    if not xr_state.change_state( self.object, 0 ) then
                        self.decision = true
                        self.time_end = nil
--                    end
                elseif dt < 3000 then
                    if self.vodka_active then
                        self.object:set_item( object.deactivate, self.object:object( "vodka" ) )
                        self.vodka_active = false
--                        printf( "[commander] : УБИРАЮ ВОДКУ" )
                    end
                elseif dt < 20000 then
                    if not self.vodka_active then
                        self.object:set_item( object.use, self.object:object( "vodka" ) )
                        self.vodka_active = true
--                        printf( "[commander] : НАЧИНАЮ ПИТЬ" )
                    end
                end
                
            else
                self:stop()
--                self.object:set_sight( look.point, self.a.way:point( self.a.way:index( "mattress_dir" ) ):add( vector():set( 0, 0.5, 0 ) ), 0 )
                local dir = self.a.way:point( self.a.way:index( "mattress_dir" ) ):sub( self.object:position() )
                self.object:set_sight( look.direction, dir, 0 )

                if xr_state.change_state( self.object, 2 ) then 
--                    printf( "[commander] : НАЧИНАЮ САДИТЬСЯ" )
                else
                    if day_time() > 14 * h2ms then
                        self.drunk = true
                    end

                    self.sub_act = true
                    self.time_end = device():time_global() + 20000
                    self.vodka_active = false
                    
--                    printf( "[commander] : СЕЛ" )
                end
            end
        else
            -- если сдвинулся с позиции, то уйти
            if self.sub_act then
                --self.object:clear_animations()
                self.decision = true
                self.time_end = nil
            end
        end
    else
        if self.last_act == sleep then
            self.pos = self.a.way:point( self.a.way:index( "mattress" ) )
            return
        end

        if not xr_state.change_state( self.object, 0 ) then
            self.object:clear_animations()
            self:walk_to_pos( self.a.way, "mattress" )
--            printf( "[commander] : drink_vodka" )
        end
    end
end

function action_commander:exec_sleep()
    if self.pos then
        if self:in_pos() then
            if self.time_end then
                if self.time_end <= game.time() then
                    -- к 4 утра он протрезвеет
                    if self.time_end >= 4 * h2ms then
                        self.drunk = false
                    end

                    self.decision = true
                    self.time_end = nil
                end
            else
                self:stop()
--                self.object:set_sight( look.point, self.a.way:point( self.a.way:index( "mattress_dir" ) ), 0 )
                local dir = self.a.way:point( self.a.way:index( "mattress_dir" ) ):sub( self.object:position() )
                self.object:set_sight( look.direction, dir, 0 )

                self.object:set_item ( object.idle, nil )
                
                if not xr_state.change_state( self.object, 4 ) then 
                    -- через час он проснётся и примет новое решение
                    self.time_end = game.time() + h2ms
                end
            end

            globals.set_sound( self.object, self.sounds_sleeping )
        else
            -- если сдвинулся с позиции, то уйти
            if self.time_end then
                self.decision = true
                self.time_end = nil
            end
        end
    else
        if self.last_act == sleep or self.last_act == drink_vodka then
            self.pos = self.a.way:point( self.a.way:index( "mattress" ) )
            return
        end

        if not xr_state.change_state( self.object, 0 ) then
            self.object:clear_animations()
            self:walk_to_pos( self.a.way, "mattress" )
--            printf( "[commander] : sleep" )
        end
    end
end

function action_commander:move_callback( obj, action_type, index )
    --printf( "%d", index )

    if index == -1 then return end

    if index == self.a.near_door_index then
        if self.a.near_door_visited then
            self.decision = true
            return
        else
            self.a.near_door_visited = true
        end
    end

    if math.random( 100 ) <= 60 then
        local pos = self.object:position()

        for i, name in ipairs( self.a.soldiers ) do
            local soldier = level.object( name )

            if soldier and soldier:alive() and pos:distance_to_sqr( soldier:position() ) <= 64 then
                --and self.object:see( soldier ) then
                self.act = path_talk
                self.soldier_to_look_at = soldier
                break
            end
        end
    else
        --self.object:play_sound( random_choice( snd_walking, snd_drunk ), 1, 0 )
        xr_sounds.play_sound( self.object, 0, self.a.snd_theme, 1, random_choice( snd_walking, snd_drunk ) )
    end
end

function action_commander:zone_callback( zone, obj )
    if not self.already_alarm and obj:id() == self.object:id() and self.act ~= look_after then
        if not self.obj_look_after then
            self.obj_look_after = level.object( self.a.obj_look_after_name )
        end

        if self.obj_look_after then
            self.act_before_look_after = self.act
            self.act = look_after
        end
    end
end

---------------------------------------------------------------------------------------------------------------------
-- Действие для перехвата смерти командира
---------------------------------------------------------------------------------------------------------------------
class "action_dead_hook" ( action_base )

function action_dead_hook:__init( name, storage ) super( nil, name )
    self.a = storage
end

function action_dead_hook:initialize()
    action_base.initialize( self )

    self.a.dead_hook = true
    xr_gulag.changeCasualities( self.a.fraction, 3 )

--    printf( "[commander] : dead" )
end

function action_dead_hook:execute()
    action_base.execute( self )
end

function action_dead_hook:finalize()
    action_base.finalize( self )
end

----------------------------------------------------------------------------------------------------------------------
-- Действие "втыкать на актёра"
----------------------------------------------------------------------------------------------------------------------
class "action_look_at_actor" ( action_base )

function action_look_at_actor:__init( name, a )  super ( nil, name )
	self.a = a
end

function action_look_at_actor:initialize()
    action_base.initialize( self )

    self.object:clear_animations()

    self.object:set_movement_type       ( move.stand )
    self.object:set_mental_state        ( anim.free )
    self.object:set_item                ( object.idle, nil )

    self.object:enable_talk()

	if self.a.dialog then
		self.object:set_start_dialog( self.a.dialog )
	end

    xr_sounds.play_sound( self.object, 0, "barman", 1, 2, 1 )
end

function action_look_at_actor:execute()
    action_base.execute( self )

    if self.object:see( the_actor ) then
        local item = the_actor:active_item()

        if item and isWeapon( item ) then
            self.object:set_relation( game_object.enemy, the_actor )
            return
        end
    end

    self.object:set_sight( look.direction, the_actor:position():sub( self.object:position() ), 0 )
end

function action_look_at_actor:finalize()
    action_base.finalize( self )

    self.object:disable_talk()

    self.a.continue_act = true
end

----------------------------------------------------------------------------------------------------------------------

function add_to_binder( npc, char_ini )
    if char_ini and not char_ini:section_exist( "commander" ) then
        return
    end

    local a = xr_motivator.storage[npc:id()].commander

    a.dead_hook = false

    local manager = npc:motivation_action_manager()

    manager:add_evaluator( prop_commander, this.evaluator_commander( "property_commander", a ) )
    manager:add_evaluator( prop_dead_hook, this.evaluator_dead_hook( "property_dead_hook", a ) )
    manager:add_evaluator( prop_actor_is_close, this.evaluator_actor_is_close( "property_actor_is_close", npc ) )
    
    local action = this.action_look_at_actor( "action_look_at_actor", a )
    action:add_precondition( world_property( stalker_ids.property_enemy,    false ) )
    action:add_effect( world_property( prop_actor_is_close, false ) )
    manager:add_action( act_look_at_actor, action )

    action = this.action_commander( "action_commander", a )
    action:add_precondition( world_property( stalker_ids.property_enemy,    false ) )
    action:add_precondition( world_property( xr_evaluators_id.state_change, true  ) )
    action:add_precondition( world_property( prop_actor_is_close, false ) )
    action:add_effect( world_property( prop_commander, false ) )
    manager:add_action( act_commander, action )

    action = manager:action( stalker_ids.action_puzzle_solver )
    action:add_precondition( world_property( prop_commander, false ) )

    action = this.action_dead_hook( "action_dead_hook", a )
    action:add_effect( world_property( prop_dead_hook, true ) )
    manager:add_action( act_dead_hook, action )

    action = manager:action( stalker_ids.action_death_planner )
    action:add_precondition( world_property( prop_dead_hook, true ) )

    xr_report.AddScheme( npc, act_commander )

    if char_ini then
        this.set_commander( npc )
    end
end

function init_commander( npc, a )
    function remove_acts( ... )
        for i = 1, 3 do
            for j = 1, arg.n do
                a.acts[i][arg[j]] = 0
            end
        end
    end

    local char_ini = npc:spawn_ini()

    if char_ini:section_exist( "commander" ) then
        -- включен?
        if char_ini:line_exist( "commander", "enabled" ) then     
            if not char_ini:r_bool( "commander", "enabled" ) then
                return false
            end
        else
            return false
        end

        a.acts = {}
        -- веса решений
        for i = 1, 3 do
            a.acts[i] = {}
        end
    
        for s, n in pairs( act_str2num ) do
            remove_acts( n )

            if char_ini:line_exist( "commander", s ) then
                local w = parse_names( char_ini:r_string( "commander", s ) )

                for i = 1, 3 do
                    if w[i] and w[i] ~= "" then
                        a.acts[i][n] = tonumber( w[i] )
                    end
                end
            end
        end
        
--        for s, n in pairs( act_str2num ) do
--            printf( "%s = %d", s, a.acts[1][n] )
--        end
        
        -- объект для присмотра и зона, в которой он оглядывается на этот объект
        if char_ini:line_exist( "commander", "look_after" ) then
            a.obj_look_after_name = char_ini:r_string( "commander", "look_after" )
        end

        if char_ini:line_exist("commander", "zone_look_after") and a.obj_look_after_name then
            a.zone_name = char_ini:r_string( "commander", "zone_look_after" )
        end

        -- пути --
        -- way
        if char_ini:line_exist( "commander", "way" ) then
            local name = char_ini:r_string( "commander", "way" )
            if level.patrol_path_exists( name ) then
                a.way = patrol( name )

                if a.way:index( "level_map" ) < 0 then
                    remove_acts( look_map )
                end

                if a.way:index( "near_door" ) < 0 then
                    remove_acts( stretch_himself )
                end

                if a.way:index( "look_after" ) < 0 then
                    a.zone_name = nil
                end

                if a.way:index( "mattress" ) < 0 or a.way:index( "mattress_dir" ) < 0 then
                    remove_acts( sleep, drink_vodka )
                end
            else
                remove_acts( look_map, stretch_himself, drink_vodka, sleep )
                printf( "ERR commander: path way=%s not found!", name )
            end
        else
            remove_acts( look_map, stretch_himself, drink_vodka, sleep )
        end

        -- way_random
        if char_ini:line_exist( "commander", "way_random" ) then
            local name = char_ini:r_string( "commander", "way_random" )
            if level.patrol_path_exists( name ) then
                a.way_random = patrol( name )
            else
                remove_acts( walk_random )
                printf( "ERR commander: path way_random=%s not found!", name )
            end
        else
            remove_acts( walk_random )
        end

        -- way_path
        if char_ini:line_exist( "commander", "way_path" ) then
            local name = char_ini:r_string( "commander", "way_path" )

            if level.patrol_path_exists( name ) then
                a.way_path = name

                a.near_door_index = patrol( name ):index( "near_door" )
                if a.near_door_index < 0 then
                    a.near_door_index = 0
                end
            else
                remove_acts( walk_path )
                printf( "ERR commander: path way_path=%s not found!", name )
            end
        else
            remove_acts( walk_path )
        end

        -- солдаты
        if char_ini:line_exist( "commander", "soldiers" ) then
            local soldiers = char_ini:r_string( "commander", "soldiers" )
            a.soldiers = parse_names( soldiers )
        end

        -- тема звуков
        if char_ini:line_exist( "commander", "sound_theme" ) then
            a.snd_theme = char_ini:r_string( "commander", "sound_theme" )
        end

        -- имя группировки (лагеря)
        if char_ini:line_exist( "commander", "fraction" ) then
            a.fraction = char_ini:r_string( "commander", "fraction" )
        end

        -- диалог
        if char_ini:line_exist( "commander", "dialog" ) then
            a.dialog = char_ini:r_string( "commander", "dialog" )
        end
    else
        --printf( "no section" )
        return false
    end

    return true
end

function set_commander( npc, enable )
    printf( "SET COMMANDER" )
    local a = xr_motivator.storage[npc:id()].commander

    if enable == nil then
        a.enabled = this.init_commander( npc, a )
    else
        a.enabled = enable and this.init_commander( npc, a )
    end

    xr_motivator.checkStorage( npc )
end
