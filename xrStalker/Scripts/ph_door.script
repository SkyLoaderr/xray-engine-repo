----------------------------------------------------------------------------------------------------
-- Physic door control
----------------------------------------------------------------------------------------------------
-- Исходный скрипт: Evgeniy Negrobov (Jon) jon@gsc-game.kiev.ua
-- Перевод на xr_logic: Andrey Fidrya (Zmey) af@svitonline.com
-- Доработка: Oleg Kreptul (Haron) haronk@ukr.net
----------------------------------------------------------------------------------------------------

class "action_door"

function action_door:__init(obj, storage)
	printf	("action_door::action_door() called")
	self.object = obj
	self.st = storage
	self.snd_obj = nil
end
function action_door:reset_scheme(loading)
	printf("_bp: action_door:reset_scheme: self.object:name()='%s'", self.object:name())
	self.initialized = false
	
	self:initialize(loading)
end

function action_door:initialize(loading)
	local ph_shell = self.object:get_physics_shell()
	if not ph_shell then
		return
	end
	self.joint = ph_shell:get_joint_by_bone_name("door")

	self.low_limits, self.hi_limits = 0, 0
	self.low_limits, self.hi_limits	= self.joint:get_limits(self.low_limits, self.hi_limits, 0)

	self.run = 0
	self.block = false
	self.soundless_block = false

	self.show_tips = self.st.show_tips

	local disable_snd
	-- Звук нужно отключить, только если скрипт двери для этого объекта используется
	-- впервые (т.е. после загрузки уровня или после загрузки сохраненной игры),
	-- иначе игрок услышит хлопок...
	if not self.st.script_used_more_than_once then
		disable_snd = true
		self.st.script_used_more_than_once = true
	end
	if self.st.closed then
		self:close_door()
	else
		self:open_door(disable_snd)
	end

	self.object:set_nonscript_usable(false)

	if self.st.snd_init then
		self:door_play_snd_from_set(self.st.snd_init)
	end
	
	self.initialized = true
end

function action_door:door_play_snd_from_set(sndset)
	local snd = mob_sound.pick_sound_from_set(self.object, sndset, {})
	if not snd then
		abort("physic object '%s': section '%s': sound set '%s' does not exist",
			self.object:name(), self.st.section, sndset)
	end
    
    if self.snd_obj ~= nil then
       self.snd_obj:stop ()
       self.snd_obj = nil 
    end
        	
	self.snd_obj = sound_object(snd)
	if not self.snd_obj then
		abort("object '%s': unable to create a sound object for sound '%s' (soundset '%s')",
			self.object:name(), snd, sndset)
	end
	self.snd_obj:play_at_pos(self.object, self.object:position())--, 0, sound_object.s2d) -- FIXME: don't use position()
end

function action_door:update(delta)
	--printf("_bp: action_door:update()", delta)
	if not self.initialized then
		abort("object '%s': door failed to initialize", self.object:name())
	end

	local actor = db.actor

	if xr_logic.try_switch_to_another_section(self.object, self.st, actor) then
		return
	end
end

function action_door:fastcall()
	if self:close_check() then
		self:close_action()
		--printf("_bp: action_door: fastcall(): return true")
		return true
	end
	--printf("_bp: action_door: fastcall(): return false")
	return false
end

function action_door:close_check()
	--printf("_bp: close_check(): %d", time_global())
	if not self.initialized then
		--printf("_bp: close_check(): not initialized")
		return false
	end

	if self.block then
		return self:is_closed()
	end
	--printf("_bp: close_check(): false")
	return false
end

function action_door:close_action()
	printf("_bp: close_action(): %d", time_global())

	printf("_bp: action_door:update(): door blocked")
	-- Закрыли до предела, будем блокировать
	printf("FORCE DIT [%s]", self.st.force_dir_id)
	if self.st.no_force == true then
		self.joint:set_max_force_and_velocity(0, 0, self.st.force_dir_id)
	else
		self.joint:set_max_force_and_velocity(10000, 1, self.st.force_dir_id)
	end
	self.block = false
	-- Отыграть звук когда дверь захлопнулась:
	if not self.soundless_block and self.st.snd_close_stop then
		self:door_play_snd_from_set(self.st.snd_close_stop)
	end
end

function action_door:open_door(disable_snd)
	printf("_bp: action_door:open_door()")
	if not disable_snd then
		if self.st.snd_open_start then
			self:door_play_snd_from_set(self.st.snd_open_start)
		end
	end
	
	if self.st.no_force == true then
		self.joint:set_max_force_and_velocity(0, 0, self.st.force_dir_id)
	else
		self.joint:set_max_force_and_velocity(200, -3, self.st.force_dir_id)
	end
	self.block = false

	if self.show_tips and self.st.tip_close then
		self.object:set_tip_text(self.st.tip_close)
	end
end

function action_door:is_closed()
	local angle = self.joint:get_axis_angle(90)
	printf("_bp: action_door:update(): angle %f limits %f, %f",
		angle, self.low_limits, self.hi_limits)
	if angle >= self.hi_limits then
		printf("_bp: close_check(): true")
		return true
	end
end

function action_door:close_door()
	local disable_snd = self:is_closed()
	if not disable_snd then
		if self.st.snd_close_start then
			self:door_play_snd_from_set(self.st.snd_close_start)
		end
	end

	-- Ставим коллбек для отлова окончания закрытия двери (чтобы заблокировать ее и проиграть звук, если нужно):
	printf("_bp: action_door: setting physics callback from close_door")
	--level.add_call(self, "close_check", "close_action") -- OK
	self.object:set_fastcall(self.fastcall,self)
	self.object:set_fastcall(self.fastcall,self)
	self.object:set_fastcall(self.fastcall,self)

	printf("_bp: action_door:close_door()")
	if self.st.no_force == true then
		self.joint:set_max_force_and_velocity(0, 0, self.st.force_dir_id)
	else
		self.joint:set_max_force_and_velocity(200, 3, self.st.force_dir_id)
	end
	self.block = true -- Закрываем и блокируем	
	self.soundless_block = disable_snd

	if self.show_tips and self.st.tip_open then
		self.object:set_tip_text(self.st.tip_open)
	end
end

function action_door:try_switch()
	printf("_bp: action_door: object '%s': try_switch", self.object:name())
	local st = db.storage[self.object:id()]
	if st.active_scheme and st.active_scheme == "ph_door" and self.st.on_use then
		--if xr_logic.try_switch_to_another_section(obj, self.st, db.actor) then
		if xr_logic.switch_to_section(self.object, self.st,
		   xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.on_use.condlist)) then
			return true
		end
	end
	return false
end

function action_door:use_callback(door, actor)
	if self:try_switch() then
		return
	end

	if self.st.locked then
		if self.st.snd_open_start then
			self:door_play_snd_from_set(self.st.snd_open_start)
		end
		return
	end

	local angle = self.joint:get_axis_angle(90)

	if angle - self.low_limits > self.hi_limits - angle then
		self:open_door(false)
	else
		self:close_door(false)
	end
end
function action_door:hit_callback(obj, amount, local_direction, who, bone_index)
	local who_name
	if who then
		who_name = who:name()
	else
		who_name = "nil"
	end

	printf("DOOR: hit_callback: obj='%s', amount=%d, who='%s', bone='%s'", obj:name(), amount, who_name, bone_index)
	print_table(self.st.hit_on_bone)
	if self.st.hit_on_bone[bone_index] ~= nil then
		local section = xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.hit_on_bone[bone_index].state)
		xr_logic.switch_to_section(obj, self.st, section)
		return
	end
end
function action_door:deactivate()
	self.object:set_tip_text("")
end

---------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
	printf("DEBUG: add_to_binder: scheme='%s', section='%s'", scheme, section)

	local new_action = action_door(npc, storage)

	-- Зарегистрировать все actions, в которых должен быть вызван метод reset_scheme при изменении настроек схемы:
	xr_logic.subscribe_action_for_events(npc, storage, new_action)
end

function set_scheme(npc, ini, scheme, section, gulag_name)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)

	st.logic     = xr_logic.cfg_get_switch_conditions(ini, section, npc)

	st.closed    = utils.cfg_get_bool(ini, section, "closed", npc, false, true)
	st.locked    = utils.cfg_get_bool(ini, section, "locked", npc, false)
	st.no_force  = utils.cfg_get_bool(ini, section, "no_force", npc, false, false)

	st.show_tips = utils.cfg_get_bool(ini, section, "show_tips", npc, false, true)
	if not st.locked then
		st.tip_open  = utils.cfg_get_string(ini, section, "tip_open", npc, false, "", "tip_door_open")
		st.tip_close = utils.cfg_get_string(ini, section, "tip_close", npc, false, "", "tip_door_close")
	else
		st.tip_open  = utils.cfg_get_string(ini, section, "tip_open", npc, false, "", "tip_door_locked")
	end
	st.force_dir_id   = utils.cfg_get_number(ini, section, "force_dir_id", npc, false, 1)
	st.snd_init        = utils.cfg_get_string(ini, section, "snd_init", npc, false, "")
	st.snd_open_start  = utils.cfg_get_string(ini, section, "snd_open_start", npc, false, "")
	st.snd_close_start = utils.cfg_get_string(ini, section, "snd_close_start", npc, false, "")
	st.snd_close_stop  = utils.cfg_get_string(ini, section, "snd_close_stop", npc, false, "")
	
	st.on_use    = xr_logic.cfg_get_condlist(ini, section, "on_use", npc)
	
		
	st.hit_on_bone = parse_data(npc, utils.cfg_get_string(ini, section, "hit_on_bone", npc, false, ""))
end


function parse_data(npc,s)
	local t = {}

    if s then
		for name in string.gfind( s, "(%|*%d+%|[^%|]+)%p*" ) do
--			printf("[%s]", utils.to_str(name))
			local dat = {	dist = nil,
							state = nil}	
			
			local t_pos = string.find( name, "|", 1, true )
						
			local dist = string.sub( name, 1, t_pos - 1 )
			local state	= string.sub( name, t_pos + 1)
		
--			printf("	[%s]=[%s][%s]", utils.to_str(dist), utils.to_str(state), utils.to_str(sound))
			dat.dist = tonumber(dist)
			if state then
				dat.state = xr_logic.parse_condlist(npc, dist, state, state)
			end
			t[tonumber(dist)] = dat
		end
	end
    return t
end
