local flesh_distance 	= 30


// Плоть которая бежит в аномалию при приближении актера

class "CDeadFlesh" (object_binder)

function CDeadFlesh:__init(obj) super(obj)
end 

function CDeadFlesh:reload(section)
	object_binder.reload(self, section)
	
	self.char_ini	= self.object:spawn_ini()
	
	self.rest_way	= utils.conf_get_string(self.char_ini, "gameplay", "path", nil, obj, true)
	self.dead_way	= utils.conf_get_string(self.char_ini, "gameplay", "dead_point", nil, obj, true)

	self.end_work	= false
	self.actor_near = false
end

function CDeadFlesh:update(delta)
	object_binder.update(self, delta)
	
	if(self.end_work) then return end
	
	if(self:test_to_dead()) then return end
	
	// Если еще не взяли под скрипт, то берем
	if(self.object:get_script() == false) then
		self.object:script(true, script_name())
	end
	
	if(self.actor_near == false and distance_between_safe(self.object, level.actor()) >flesh_distance) then
		// Актер далеко, ходит просто по маршруту
		if(self.object:action() == nil) then
			action(self.object, move(move.walk_fwd, patrol(self.rest_way)), sound(sound.idle), cond(cond.move_end))		
		end
	else
		// Актер рядом, бежит в аномалию
		if(self.actor_near == false) then
			reset_action(self.object, script_name())
			self.actor_near	= true
		end
		
		if(self.object:action() == nil) then
			action(self.object, move(move.run_fwd, patrol(self.dead_way)), sound(sound.panic), cond(cond.move_end))
		end
	end
end

// Проверяем, не умер ли монстр
function CDeadFlesh:test_to_dead()
	if(self.object:alive()) then return (false) end
	
	self.end_work		= true
	
	if(self.object:get_script()) then
		self.object:script(false, script_name())
	end
	
	return (true)
end

// Кабаны не escape. Буцают труп, при подходе игрока бегут в аномалию
// Часть скрипта скопирована из футбола. Так что немного тут есть лишнего

local boar_distance         = 30      // Расстояние, ближе которого кабаны бегут в аномалию
local max_distance       	= 10      // На каком расстояние от точки обитания, буду буцать трупп

class "CBoarPlayWithCorpse" (object_binder)
function CBoarPlayWithCorpse:__init(obj) super(obj)
end 

function CBoarPlayWithCorpse:reload(section)
	object_binder.reload(self, section)
	
	self.ini        = self.object:spawn_ini()

	self.path		= patrol(utils.conf_get_string(self.ini, "gameplay", "path", nil, self.object, true))
	self.corpse		= utils.conf_get_string(self.ini, "gameplay", "corpse", nil, self.object, true)
	self.end_work	= false
	self.actor_near = false
	
	self.ball		= level.object(self.corpse)
	if(self.ball) then
		self.shell	= self.ball:get_physics_shell()
	end
	self.state		= 0
	self.time_play	= 0
	self.temp		= false				// Временно, оббегаем ли мы мяч
end

function CBoarPlayWithCorpse:update(delta)
	object_binder.update(self, delta)
	
	if(self.end_work) then return end
	
	// Если еще не взяли под скрипт, то берем
	if(self.object:get_script() == false) then
		self.object:script(true, script_name())
	end

	if(self:test_to_dead()) then return end

	if(self.actor_near == false and distance_between_safe(self.object, level.actor()) >flesh_distance) then
		self:set_action()
	else
		// Актер рядом, бежит в аномалию
		if(self.actor_near == false) then
			reset_action(self.object, script_name())
			self.actor_near	= true
		end
		
		if(self.object:action() == nil) then
			action(self.object, move(move.run_fwd, self.path:point(1)), sound(sound.panic), cond(cond.move_end))
		end
	end
end

function CBoarPlayWithCorpse:set_action()
	if(self.ball == nil) then
		
		self.ball		= level.object(self.corpse)	
		self.shell		= self.ball:get_physics_shell()
		
		if(self.object:action() == nil and self.ball == nil) then
			// Если еще мяча почему-то нет
			action(self.object, anim(anim.sit_idle, 0), cond(cond.time_end, 3000))
			return
		end
	end
	
	if(self.state == 0 and self.object:action() == nil) then
		if(self.ball:position():distance_to(self.path:point(0)) > max_distance and
		   self.object:position():distance_to(self.path:point(0)) < self.ball:position():distance_to(self.path:point(0))
		) then
			// мяч забили сильно далеко, пытаемся его вернуть назад. Забегаем с другой стороны
			action(self.object, move(move.run_fwd, self:select_point(), 0.5), sound(sound.attack), cond(cond.move_end))
			self.temp	= true
			//action(self.object, move(move.run_fwd, self.ball), sound(sound.attack), cond(cond.time_end, 3000))
		else
			// Вносим елемент случайности
			if(math.random() < 0.8) then
				action(self.object, move(move.run_fwd, self.ball), sound(sound.attack), cond(cond.time_end, 3000))
			else
				action(self.object, move(move.run_fwd, self:select_point(), 0.5), sound(sound.attack), cond(cond.move_end))			
			end
			self.temp	= false
		end
	end

	if(device():time_global() > self.time_play) then
		if(distance_between(self.object, self.ball) < 2 and self.temp == false) then
			if(self.state == 0) then
				// Проигруем анимацию
				reset_action(self.object, script_name())
				action(self.object, look(look.point, self.ball:position()), anim(anim.turn, 0), cond(cond.look_end))
				self.state 		= 1
			elseif(self.state == 1 and self.object:action() == nil) then
				action(self.object, anim(anim.attack, 0), cond(cond.time_end, 600))
				self.temp_time 	= device():time_global() + 400
				self.state		= 2
			elseif(self.state == 2 and device():time_global() > self.temp_time) then
				// Бьем
				self:play()
				self.state		= 0
			end
		else
			self.state	= 0
		end
	end	
end 

local k 	= 400000

function CBoarPlayWithCorpse:play()   
	self.dir	= self.ball:position():sub(self.object:position()):normalize()
	self.dir.y	 = 0.6

	self.shell:apply_force(k * self.dir.x, k * self.dir.y, k * self.dir.z)	
end 

function CBoarPlayWithCorpse:select_point()
	// Выбираем точку, так, чтоб было похоже, что пытаемся оббежать
	
	self.id			= self.object:level_vertex_id()
	self.dir		= self.ball:position():sub(self.path:point(0))
	
	
	// Пытаемся съимитировать бег разбросанный
	if(math.random() > 0.5) then
		self.dir 	= vector_rotate_y(self.dir, 35)
	else
		self.dir 	= vector_rotate_y(self.dir, -35)
	end
	
	if(self.dir:magnitude() == 0) then
		// На всякий случай, вдруг получится, что |self.dir| = 0
		self.dir.x = 0.1
	end
	
	self.id		 	= level.vertex_in_direction(self.id, self.dir, 5)
	
	return	(level.vertex_position(self.id))
end

// Проверяем, не умер ли монстр
function CBoarPlayWithCorpse:test_to_dead()
	if(self.object:alive()) then return (false) end
	
	self.end_work		= true
	
	if(self.object:get_script()) then
		self.object:script(false, script_name())
	end
	
	return (true)
end

class "CDangerDogs"

function CDangerDogs:__init(obj) super(obj)
end 

function CDangerDogs:reload(section)
	object_binder.reload(self, section)
	
	self.char_ini	= self.object:spawn_ini()
	
	self.rest_way	= utils.conf_get_string(self.char_ini, "gameplay", "path", nil, obj, true)
	self.dead_way	= utils.conf_get_string(self.char_ini, "gameplay", "dead_point", nil, obj, true)

	self.end_work	= false
	self.actor_near = false
end

function CDangerDogs:update(delta)
	object_binder.update(self, delta)
	
	if(self.end_work) then return end
	
	if(self:test_to_dead()) then return end
	
	// Если еще не взяли под скрипт, то берем
	if(self.object:get_script() == false) then
		self.object:script(true, script_name())
	end
	
	self:set_action()
end

function CDangerDogs:set_action()
	if(dog_manager():attack_actor() == false) then
		self.attack	= true
		dog_manager():monster_attack(true)
		reset_action(self.object, script_name())
	end
end

// Проверяем, не умер ли монстр
function CDangerDogs:test_to_dead()
	if(self.object:alive()) then return (false) end
	
	self.end_work		= true
	
	// если атаковали актера, то сообщаем менеджеру, что уже больше не атакуем
	if(self.attack) then
		dog_manager():monster_attack(false)
		self.attack 	= false
	end
	
	if(self.object:get_script()) then
		self.object:script(false, script_name())
	end
	
	return (true)
end
