----------------------------------------------------------------------------------------------------
-- Apply directional force to the object
----------------------------------------------------------------------------------------------------
-- Исходный скрипт: Oleg Hryptul (Haron) haronk@ukr.net
----------------------------------------------------------------------------------------------------

class "action_impulse"

----------------------------------------------------------------------------------------------------
-- Constructor
----------------------------------------------------------------------------------------------------
function action_impulse:__init(obj, storage)
	self.object     = obj
	self.st         = storage
	self.start_time = 0
	self.joint      = nil
end

function action_impulse:reset_scheme()
	printf("_hr: action_impulse:reset_scheme: self.object:name()='%s'", self.object:name())
	
	if not self.joint then
		self.joint	= self.object:get_physics_shell():get_joint_by_bone_name(self.st.bone)
	end
	
	local p1 = patrol(self.st.dir_path):point(0)
	local p2 = self.object:position()
	local pt = utils.vector_copy_by_val(p1):sub(p2)
	pt:normalize()
	self.joint:set_max_force_and_velocity(self.st.force, pt.x * self.st.velocity, 0)
	self.joint:set_max_force_and_velocity(self.st.force, pt.y * self.st.velocity, 1)
	self.joint:set_max_force_and_velocity(self.st.force, pt.z * self.st.velocity, 2)
	
	self.start_time = device():time_global()
end

function action_impulse:update(delta)
	--printf("_hr: action_impulse:update()")

	--if not xr_logic.is_active(self.object, self.st) then
	--	return
	--end

	local actor = level.actor()
	if not actor then
		return
	end

	if xr_logic.try_switch_to_another_section(self.object, self.st, actor) then
		return
	end
	
	if device():time_global() > self.start_time + self.st.duration then
		self.joint:set_max_force_and_velocity(0, 0, 0)
		self.joint:set_max_force_and_velocity(0, 0, 1)
		self.joint:set_max_force_and_velocity(0, 0, 2)
	end
end

--[[
function action_impulse:hit_callback(door, actor)
	if self.st.locked then
		if self.st.snd_open_start then
			self:door_play_snd_from_set(self.st.snd_open_start)
		end
		return
	end

	local angle = self.joint:get_axis_angle(90)

	if angle - self.low_limits > self.hi_limits - angle then
		self:open_door()
	else
		self:close_door(false)
	end
end
--]]

---------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
	printf("DEBUG: add_to_binder: scheme='%s', section='%s'", scheme, section)

	local new_action = action_impulse(npc, storage)

	-- Зарегистрировать все actions, в которых должен быть вызван метод reset_scheme при изменении настроек схемы:
	xr_logic.subscribe_action_for_events(npc, storage, new_action)
end

function set_scheme(npc, ini, scheme, section, gulag_name)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)

	st.logic = xr_logic.cfg_get_switch_conditions(ini, section, npc)
	
	st.force     = utils.cfg_get_number(ini, section, "force", npc, false, 5)
	st.velocity  = utils.cfg_get_number(ini, section, "velocity", npc, false, 100)
	st.duration  = utils.cfg_get_number(ini, section, "duration", npc, false, 100)
	st.bone      = utils.cfg_get_string(ini, section, "bone", npc, true, "")
	st.dir_path  = utils.cfg_get_string(ini, section, "dir_path", npc, true, "")
end
