----------------------------------------------------------------------------------------------------
-- Remark
----------------------------------------------------------------------------------------------------
-- Разработчик: Andrey Fidrya (Zmey) af@svitonline.com
----------------------------------------------------------------------------------------------------

function printf() end

local state_none = 0
local state_initial = 1
local state_going_to_plr = 2
local state_standing = 4

local body_state_free = 0
local body_state_danger = 1

---------------------------------------------------------------------------------------------------------------------
class "evaluator_need_remark" (property_evaluator)

function evaluator_need_remark:__init(storage, name) super(nil, name)
  	self.st = storage
end

function evaluator_need_remark:evaluate()
  	return xr_logic.is_active(self.object, self.st)
end

----------------------------------------------------------------------------------------------------------------------
class "action_remark_activity" (action_base)

function action_remark_activity:__init (npc_name, action_name, storage) super(nil, action_name)
	self.st = storage
	self.was_reset = false
end

function action_remark_activity:initialize()
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()
end

function action_remark_activity:activate_scheme()
    self.st.signals = {}
    self.sound_end_signalled = false
    self.move_end_signalled = false
    self.action_end_signalled = false
    self.anim_end_signalled = false

	self.state = state_initial
	self.reset_time = time_global()
	self.snd_scheduled = false
	self.snd_start_time = nil
	self.snd_started = false
	
end

function action_remark_activity:get_target()
    if self.st.target_actor == true then
        return db.actor
    end

    if self.st.target_id then
        return level.object_by_id(self.st.target_id)
    end

    return nil
end

function action_remark_activity:signal_arrival()
	if not self.move_end_signalled then
		self.move_end_signalled = true
		self.st.signals["move_end"] = true
		self:signal_action_end()
	end
end

function action_remark_activity:activate_sound()
--	printf("REMARK activate_sound called [%s]", self.object:name())
	if self.snd_scheduled or not self.st.snd then
		return
	end

	self.snd_start_time = time_global()
	self.snd_scheduled = true				

	xr_sound.set_sound_play(self.object, self.st.snd)

end

function action_remark_activity:if_actor_far_go_to_actor()
	if not self.st.no_move then
	    local target = self:get_target()
		if target and distance_between(self.object, target) >= 4 then
			self:go_to_target()
			self.state = state_going_to_plr
		end
	end
end

function action_remark_activity:get_sug_body_state()
    local target = self:get_target()
	if self.st.no_danger or not target or 
	   not IsStalker(target) or				
	   self.object:relation(target) == game_object.friend  
	then
		return body_state_free --"guard"
	else
		return body_state_danger --"threat"
	end
end

function action_remark_activity:signal_action_end()
	if not self.action_end_signalled and
	   (self.st.no_move or self.move_end_signalled) and
	   (not self.st.snd or self.sound_end_signalled) and
	   (not self.st.anim or self.anim_end_signalled) then
		self.action_end_signalled = true
		self.st.signals["action_end"] = true
	end
end

function action_remark_activity:time_callback()
	self:activate_sound()
	if not self.anim_end_signalled then
		self.anim_end_signalled = true
		self.st.signals["anim_end"] = true
		if self.st.anim then
			self:signal_action_end()
		end
	end
end

function action_remark_activity:turn_end_callback()
	if self.st.snd then
		if not self.st.snd_anim_sync then
			self:activate_sound()
		end
	end
end

function action_remark_activity:stand_still()
	local sug_body_state = self:get_sug_body_state()
	local look_tbl
	if self.st.no_rotate then
		look_tbl = nil
	else
		look_tbl = { look_object = self:get_target() }
	end
	local cb = { obj = self, func = self.time_callback, turn_end_func = self.turn_end_callback }
	
	if self.st.anim then
		state_mgr.set_state(self.object, self.st.anim, cb, 0, look_tbl, { animation = true })
	else
		state_mgr.set_state(self.object,
			if_then_else(sug_body_state == body_state_free, "guard", "threat"),
			cb,
			0,
			look_tbl,
			{ animation = true }
		)
	end
end

function action_remark_activity:update_destination()
    local target = self:get_target()

    if target then
	    self.object:set_path_type(game_object.level_path)
	    self.object:set_dest_level_vertex_id(target:level_vertex_id())
	end
end

function action_remark_activity:go_to_target()
	local sug_body_state = self:get_sug_body_state()

	self:update_destination()
	state_mgr.set_state(self.object,
		if_then_else(sug_body_state == body_state_free, "run", "assault"),
		nil,
		nil,
		{ look_object = self:get_target()})
end
	
function action_remark_activity:step()
	-- Scheme finalization conditions:
	if not self.sound_end_signalled and self.snd_started and self.object:active_sound_count() == 0 then
		self.sound_end_signalled = true
		self.st.signals["sound_end"] = true
		self:signal_action_end()
	end

	-- Try to switch to another scheme:
	local actor = db.actor
	if xr_logic.try_switch_to_another_section(self.object, self.st, actor) then
		return
	end

    local target = self:get_target()

	if not target or not target:alive() then
		return
	end
--	printf("REMARK step [%s]", self.object:name())
	-- Начальное состояние
	if self.state == state_initial then
			self:stand_still()
			self.state = state_standing

	elseif self.state == state_standing then
		if self.st.snd then
			if not self.st.snd_anim_sync then
				self:activate_sound()
			end
		end
		self:if_actor_far_go_to_actor()
	end	

end
	
function action_remark_activity:execute()

	action_base.execute(self)
	local old_state
	repeat
		old_state = self.state
		self:step()
	until old_state == self.state

	--printf("remark <execute>: [%s], num_snd = %d", self.object:name(), self.object:active_sound_count())
	if self.snd_scheduled then -- запросили запуск звука на этом апдейте
		if time_global() - self.snd_start_time > 1000 then
			-- нужно, чтобы прошел как минимум 1 апдейт, но не меньше 1-й секунды, прежде чем считать, что звук
			-- стартовал и ждать его окончания
			self.snd_started = true
		end
	end
end

function action_remark_activity:finalize()

	xr_sound.set_sound(self.object, nil)
	action_base.finalize(self)
end

----------------------------------------------------------------------------------------------------------------------
--remark binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
		printf("DEBUG: add_to_binder [%s]: scheme='%s', section='%s'", npc:name(), scheme, section)
  		local operators	= {}
	  	local properties  = {}
		
	   	local manager = npc:motivation_action_manager()

		properties["event"]			= xr_evaluators_id.reaction
	 	properties["need_remark"]	= xr_evaluators_id.zmey_remark_base + 1
		
	 	operators["action_remark"] = xr_actions_id.zmey_remark_base + 1

	   	-- // evaluators
		manager:add_evaluator(properties["need_remark"], this.evaluator_need_remark(storage, "remark_need_remark"))

		local new_action = this.action_remark_activity(npc, "action_remark_activity", storage)
		new_action:add_precondition(world_property(stalker_ids.property_alive, true))
		new_action:add_precondition(world_property(stalker_ids.property_danger,false))
		new_action:add_precondition(world_property(stalker_ids.property_enemy, false))
		new_action:add_precondition(world_property(stalker_ids.property_anomaly,false))
		new_action:add_precondition(world_property(properties["need_remark"], true))
		xr_motivator.addCommonPrecondition(new_action)
	   	new_action:add_effect(world_property(properties["need_remark"], false))
		manager:add_action(operators["action_remark"], new_action)

		-- Зарегистрировать все actions, в которых должен быть вызван метод reset_scheme при изменении настроек схемы:
		xr_logic.subscribe_action_for_events(npc, storage, new_action)

	  	new_action = manager:action(xr_actions_id.alife)
	  	new_action:add_precondition(world_property(properties["need_remark"], false))
end

-- Включение схемы
-- 
-- enabled - включена ли схема
-- path_walk - основной путь, по которому ходит охранник
-- path_look [опционально] - путь, куда смотрит охранник
-- team [опционально] - команда для синхронизации
--
function set_scheme(npc, ini, scheme, section, gulag_name)
	printf("DEBUG: set_scheme: scheme='%s', section='%s'", scheme, section)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
	printf("DEBUG: set_scheme: storage assigned")

	st.logic     = xr_logic.cfg_get_switch_conditions(ini, section, npc)

	st.no_rotate = utils.cfg_get_bool         (ini, section,   "no_rotate",       npc, false)
	st.no_wpn = utils.cfg_get_bool            (ini, section,   "no_wpn",          npc, false)
	st.snd_anim_sync = utils.cfg_get_bool     (ini, section,   "snd_anim_sync",       npc, false)
	if st.no_wpn then
		abort("remark <abort>: object '%s', xr_remark.set_scheme: no_wpn field is deprecated", npc:name())
	end
	st.snd = utils.cfg_get_string             (ini, section,   "snd",             npc, false, "", nil)
	st.snd_dist = utils.cfg_get_number        (ini, section,   "snd_dist",        npc, false,     5)
	st.snd_timeout = utils.cfg_get_number     (ini, section,   "snd_timeout",     npc, false,     4000)
	st.arrival_timeout = utils.cfg_get_number (ini, section,   "arrival_timeout", npc, false,     5000)
	st.anim = utils.cfg_get_string            (ini, section,   "anim",            npc, false, "")
	if st.anim == "" or st.anim == "idle" then
		abort("remark <abort>: object '%s', xr_remark.set_scheme: anim field cannot be [nil] or [idle]", npc:name())
	end
	
	st.no_move = utils.cfg_get_bool           (ini, section,   "no_move",         npc, false,     st.anim ~= nil)
	st.no_danger = utils.cfg_get_bool         (ini, section,   "no_danger",       npc, false)

	local target = utils.cfg_get_string          (ini, section,   "target",          npc, false, "", "actor")
    if target and target ~= "nil" then
	    if target == "actor" then
		    st.target_actor = true
		    st.target_id = nil
	    else
			st.target_actor = false
	        local sid = tonumber(target)
	        if sid then
		        st.target_id = id_by_sid(sid)
		        if not st.target_id then
		            abort("remark <error>: Wrong story id [%s] for [%s] in section [%s].", target, npc:name(), section)
		        end
            else
                local gulag = xr_gulag.get_npc_gulag(npc)
                local params = parse_names(target)
                if params[2] then
                    gulag = xr_gulag.get_gulag_by_name(params[2])
                end
                if gulag then
                    st.target_id = gulag.idNPCOnJob(target)
                end
		        if not st.target_id then
		            abort("remark <error>: Wrong target objrct for [%s] in section [%s].", npc:name(), section)
		        end
            end
	    end
    end   
    	
	if not st.no_move and st.anim then
		abort("remark <abort>: object '%s', section '%s': anim field specified, when no_move is false",
			npc:name(), section)
	end
end

