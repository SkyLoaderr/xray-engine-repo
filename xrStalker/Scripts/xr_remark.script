----------------------------------------------------------------------------------------------------
-- Remark
----------------------------------------------------------------------------------------------------
-- Разработчик: Andrey Fidrya (Zmey) af@svitonline.com
----------------------------------------------------------------------------------------------------

local state_none = 0
local state_initial = 1
local state_going_to_plr = 2
local state_standing = 3

---------------------------------------------------------------------------------------------------------------------
class "evaluator_need_remark" (property_evaluator)

function evaluator_need_remark:__init(storage) super()
  	self.st = storage
end

function evaluator_need_remark:evaluate()
  	return xr_logic.is_active(self.object, self.st)
end

----------------------------------------------------------------------------------------------------------------------
class "action_remark_activity" (action_base)

function action_remark_activity:__init (npc_name, action_name, storage) super(nil, action_name)
	self.st = storage
end

function action_remark_activity:initialize()
	--printf("_bp: action_remark_activity: initialize")
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()

	self:reset_scheme()
end


function action_remark_activity:reset_scheme()
	self.object:clear_animations()
	
	self.state = state_initial

	self.st.signals = {}
	self.sound_end_signalled = false
	self.move_end_signalled = false
end	

function action_remark_activity:signal_arrival()
	if not self.move_end_signalled then
		self.move_end_signalled = true
		self.st.signals["move_end"] = true
		printf("xr_remark: signalling move_end")
	end
end

function action_remark_activity:execute()
	action_base.execute(self)

	-- Scheme finalization conditions:
	if not self.sound_end_signalled and
	   self.state ~= state_initial and self.object:active_sound_count() == 0 then
		self.sound_end_signalled = true
		self.st.signals["sound_end"] = true
		printf("xr_remark: signalling sound_end")
	end

	-- Try to switch to another scheme:
	xr_logic.try_switch_to_another_section(self.object, self.st)

	local actor = level.actor()
	if not actor or not actor:alive() then
		return
	end

	if self.state == state_initial then
		xr_state.anim_update(nil, self.object)
		if not self.st.no_move then
			self.object:set_path_type(game_object.level_path)
			self.object:set_desired_direction(actor:direction())
			self.object:set_dest_level_vertex_id(actor:level_vertex_id())
			self.object:set_movement_type(move.run)
			self.object:set_mental_state(anim.danger)
			self.object:set_body_state(move.standing)
			self.state = state_going_to_plr
		else
			self.object:set_movement_type(move.stand)
			self.object:set_mental_state(anim.danger)
			self.object:set_body_state(move.standing)
			self.state = state_standing
		end
		utils.stalker_look_at_stalker(self.object, actor)

		if self.st.hello_snd then
			local snd = {}
			snd.rnd = snd_prob
			snd.maxidle = 1
			snd.sumidle = -1
			snd.themes = parse_names(self.st.hello_snd)
			xr_sound.sound_update(self.object, snd)
		end

		if self.st.hello_anim then
			xr_state.anim_update(self.st.hello_anim, self.object)
		end

		return
	end

	self.object:set_item(object.idle, self.object:best_weapon())
	utils.stalker_look_at_stalker(self.object, actor)

	if self.state == state_standing then
		if not self.st.no_move then
			if distance_between(self.object, actor) >= 4 then
				self.object:set_movement_type(move.run)
				self.object:set_desired_direction(actor:direction())
				self.object:set_dest_level_vertex_id(actor:level_vertex_id())
				self.state = state_going_to_plr
			end
		else
			if distance_between(self.object, actor) < 3 then
				self:signal_arrival()
				--self:talk_with_plr(actor)
			end
		end
		return
	end

	if self.state == state_going_to_plr then
		if distance_between(self.object, actor) >= 3 then
			self.object:set_movement_type(move.run)
			self.object:set_desired_direction(actor:direction())
			self.object:set_dest_level_vertex_id(actor:level_vertex_id())
		else
			self.object:set_movement_type(move.stand)
			self:signal_arrival()
			--self:talk_with_plr(actor)
			self.state = state_standing
		end
		return
	end
end

function action_remark_activity:finalize()
	self.object:clear_animations()
	action_base.finalize(self)
end

----------------------------------------------------------------------------------------------------------------------
--remark binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
		printf("DEBUG: add_to_binder: scheme='%s', section='%s'", scheme, section)
  		local operators	= {}
	  	local properties  = {}
		
	   	local manager = npc:motivation_action_manager()

		properties["event"] = xr_evaluators_id.reaction
		properties["state_end"] = xr_evaluators_id.state_change
	 	properties["need_remark"] = xr_evaluators_id.zmey_remark_base + 1

	 	operators["action_remark"] = xr_actions_id.zmey_remark_base + 1

	   	-- // evaluators
		manager:add_evaluator(properties["need_remark"], this.evaluator_need_remark(storage))

		local new_action = this.action_remark_activity(npc, "action_remark_activity", storage)
		new_action:add_precondition(world_property(stalker_ids.property_alive, true))
		new_action:add_precondition(world_property(stalker_ids.property_enemy, false))
		new_action:add_precondition(world_property(properties["need_remark"], true))
		new_action:add_precondition(world_property(properties["event"], false))
		new_action:add_precondition(world_property(properties["state_end"], true))
	   	new_action:add_effect(world_property(properties["need_remark"], false))
		manager:add_action(operators["action_remark"], new_action)

		-- Зарегистрировать все actions, в которых должен быть вызван метод reset_scheme при изменении настроек схемы:
		xr_logic.subscribe_action_for_events(storage, new_action)

	  	new_action = manager:action(stalker_ids.action_puzzle_solver)
	  	new_action:add_precondition(world_property(properties["need_remark"], false))
end

-- Включение схемы
-- 
-- enabled - включена ли схема
-- path_walk - основной путь, по которому ходит охранник
-- path_look [опционально] - путь, куда смотрит охранник
-- team [опционально] - команда для синхронизации
--
function set_scheme(npc, ini, scheme, section, gulag_name)
	printf("DEBUG: set_scheme: scheme='%s', section='%s'", scheme, section)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
	printf("DEBUG: set_scheme: storage assigned")

	st.logic     = xr_logic.cfg_get_switch_conditions(ini, section, npc)

	st.no_move = utils.cfg_get_bool(ini,       section, "no_move",       npc, false)
	st.hello_snd = utils.cfg_get_string(ini,   section, "hello_snd",     npc, false, "")
	st.hello_anim = utils.cfg_get_string(ini,  section, "hello_anim",    npc, false, "")

	-- После изменении настроек, сбросить все actions, нуждающиеся в сбросе:
	printf("DEBUG: set_scheme: about to call xr_logic.reset_actions()")
	xr_logic.reset_actions(st)
end

