--[[------------------------------------------------------------------------------------------------------------------
Управление диалогами групп сталкеров
Чугай Саша

Сделать:
	- расстояние между говорящими
--------------------------------------------------------------------------------------------------------------------]]

local teams = {}  -- группы сталкеров, сгруппированных для диалога
local snd = { themes = {} }
-- пределы периода молчанки между диалогами в секундах
local idle_min, idle_max = 20, 60

----------------------------------------------------------------------------------------------------------------------
-- деревья диалогов
----------------------------------------------------------------------------------------------------------------------
local dialogs = {
	place = {
		[1] = { snd = "place1", next = 2 },
		[2] = { snd = "place2" }
	},
}

----------------------------------------------------------------------------------------------------------------------
-- класс управления диалогами (только звуками)
----------------------------------------------------------------------------------------------------------------------
class "dialog_mgr"

function dialog_mgr:__init()
end

function dialog_mgr:reset( npc, team )
	self.object = npc

	if self.team ~= team then
		-- если сталкер в команде
		if self.team then
			-- убрать из текущей команды
			self:finalize()
		end

		self.team = team

		if not teams[team] then
			teams[team] = { npcs = {}, npcs_num = 0, idle_end = 0 }
		end

		self.a = teams[team]
--		self.a.npcs[npc:id()] = npc
		table.insert( self.a.npcs, npc )

--		printf( "[dialogs] adding %s to dlgteam %s", npc:name(), team )
	end
end

function dialog_mgr:finalize()
	-- убрать сталкера из списка
	for i, v in self.a.npcs do
		if v:id() == self.object:id() then
			table.remove( self.a.npcs, i )
			break
		end
	end

	self.team = nil

	-- если никого не осталось, сбросить диалог
	if table.getn( self.a.npcs ) == 0 then
		self:reset_dialog()
	end
end

-- включить возможность начала диалога
function dialog_mgr:enable( ... )
	self.a.dlgs = arg
end

-- выключить возможность начала диалога
function dialog_mgr:disable()
	self.a.dlgs = nil
end

-- текущий активный диалог
function dialog_mgr:active()
	return self.a.cur_dlg
end

-- начало нового диалога
function dialog_mgr:new_dialog()
	-- выбор нового диалога
	if self.a.dlgs.n > 1 then
		local r = math.random( 1, self.a.dlgs.n - 1 )
		if self.a.dlgs[r] == self.a.last_dlg then
			r = r + 1
		end

		self.a.cur_dlg = self.a.dlgs[r]
	else
		self.a.cur_dlg = self.a.dlgs[1]
	end

	self.a.last_dlg = self.a.cur_dlg

--	printf( "!!!!! NEW_DIALOG="..self.a.cur_dlg )
	self:new_phrase()
end

-- сбросить диалог
function dialog_mgr:reset_dialog()
	self.a.dlgs             = nil
	self.a.cur_dlg          = nil
	self.a.cur_phrase       = nil
	self.a.cur_npc          = nil

	-- следующий диалог может начаться лишь по истечению периода молчанки
	self.a.idle_end   = game.time() + math.random( idle_min, idle_max ) * 1000

--	printf( "reset dialog" )
end

-- подготовка новой фразы
function dialog_mgr:new_phrase()
	-- выбор нового говорящего. он должен быть недалеко от предыдущего говорящего
	local r

	if self.a.cur_npc then
		r = math.random( 1, table.getn( self.a.npcs ) - 1 )
		if self.a.npcs[r]:id() == self.a.cur_npc:id() then
			r = r + 1
		end
	else
		r = math.random( 1, table.getn( self.a.npcs ) )
	end

	self.a.cur_npc = self.a.npcs[r]

	-- выбор новой фразы
	if not self.a.cur_phrase then
		self.a.cur_phrase = dialogs[self.a.cur_dlg][1]
	else
		local p = self.a.cur_phrase.next
		if not p then
			-- следующей фразы нету
			return false
		end

		if type( p ) == "table" then
			p = p[math.random( 1, table.getn( p ) )]
		end

		self.a.cur_phrase = dialogs[self.a.cur_dlg][p]
	end

	-- установить задержку перед новой фразой
	self.a.phrase_delay_end = game.time() + math.random( 6000, 10000 )
	self.a.phrase_playing   = false

	return true
end

-- обновление
function dialog_mgr:update()
	if self.a.cur_dlg then	-- активен ли диалог?
		if self.object:id() == self.a.cur_npc:id() then	-- обновление говорящего?
			if self.a.phrase_delay_end < game.time() then -- окончилась ли необходимая задержка перед фразой?
				if self.a.phrase_playing then	-- начали ли уже играть звук?
					if self.a.cur_npc:active_sound_count() == 0 then	-- звук закончился?
						if not self:new_phrase() then
							-- если новая фраза не выбрана, то наступил конец диалога
							self:reset_dialog()
						end
					end
				else
				-- произнести фразу
					snd.themes[1] = self.a.cur_phrase.snd
					xr_sound.sound_update( self.a.cur_npc, snd, true )
					self.a.phrase_playing = true
				-- printf( "SNDSNDNSNDND = " .. snd.themes[1] )	
				end
			end
		end
	else
		-- если можно, начать диалог и у нас не один говорящий
		if self.a.dlgs and self.a.idle_end < game.time() and table.getn( self.a.npcs ) > 1 then
			self:new_dialog()
		end
	end
end
