

--' Анимации персонажа
--' мы уже находимся в необходимом состоянии?
class "eva_state_mgr_animation" (property_evaluator)
function eva_state_mgr_animation:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animation:evaluate()
	if self.st.callback ~= nil and
		self.st.callback.func ~= nil and
		state_lib.states[self.st.target_state].animation == nil and
		self.st.callback.begin == nil
	then
		printf("animation false")
		return false
	end

	return state_lib.states[self.st.target_state].animation == self.st.animation:state()
end
--' нужно ли нам отыгрывать извращенную анимацию
class "eva_state_mgr_animation_play" (property_evaluator)
function eva_state_mgr_animation_play:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animation_play:evaluate()
	return state_lib.states[self.st.target_state].animation ~= nil
end
--' Отыгрываем ли мы сейчас извращенную анимацию
class "eva_state_mgr_animation_play_now" (property_evaluator)
function eva_state_mgr_animation_play_now:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animation_play_now:evaluate()
	return self.st.animation:state() ~= "wait" and self.st.animation:state() ~= nil
end
--' нужно ли нам вообще не отыгрывать анимацию
class "eva_state_mgr_animation_none" (property_evaluator)
function eva_state_mgr_animation_none:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animation_none:evaluate()
	return state_lib.states[self.st.target_state].animation == nil
end
--' мы уже не отыгрываем никакую извращенную анимацию
class "eva_state_mgr_animation_none_now" (property_evaluator)
function eva_state_mgr_animation_none_now:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animation_none_now:evaluate()
	return self.st.animation:state() == nil
end
--' нужен ли схеме экстренный ресет
class "eva_state_mgr_animation_reset" (property_evaluator)
function eva_state_mgr_animation_reset:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animation_reset:evaluate()
	--printf("reset state [%s]", utils.to_str(self.st.reset_state))
	--printf("state [%s]", utils.to_str(state_lib.states[target_state]))
	if state_lib.states[target_state] ~= nil then
		--printf("state reset [%s]", utils.to_str(state_lib.states[target_state].reset))
	end

	if self.st.callback ~= nil and
		self.st.callback.func ~= nil and
		state_lib.states[self.st.target_state].animation == nil and
		self.st.callback.begin == nil
	then
		return true
	end
	
	return self.st.reset_state == true and
		   state_lib.states[self.st.target_state] ~= nil and
		   self.st.current_state == self.st.target_state and
		   state_lib.states[self.st.target_state].reset == true	
end
--' залочена ли схема
class "eva_state_mgr_animation_locked" (property_evaluator)
function eva_state_mgr_animation_locked:__init(name, st) super (nil, name)
	self.st = st
end
function eva_state_mgr_animation_locked:evaluate()
--	printf("animstate %s", utils.to_str(self.st.animation:state()))
	return self.st.animation:state() == "wait" or
		   self.st.animation:state() == "new"
end


--' Играем входную анимацию
class "act_state_mgr_animation_start" (action_base)
function act_state_mgr_animation_start:__init(name, st) super (nil, name)
	self.st = st
end
function act_state_mgr_animation_start:initialize()
	action_base.initialize(self)
	self.st.animation:set_state(state_lib.states[self.st.target_state].animation)
end
function act_state_mgr_animation_start:execute()
	action_base.execute(self)
end
function act_state_mgr_animation_start:finalize()
	action_base.finalize(self)
end
--' ресетим анимацию
class "act_state_mgr_animation_reset" (action_base)
function act_state_mgr_animation_reset:__init(name, st) super (nil, name)
	self.st = st
end
function act_state_mgr_animation_reset:initialize()
	action_base.initialize(self)
	--printf("RESET")
	self.st.animation:set_state(state_lib.states[self.st.target_state].animation, true)
	self.st.reset_state = false
end
function act_state_mgr_animation_reset:execute()
	action_base.execute(self)
end
function act_state_mgr_animation_reset:finalize()
	action_base.finalize(self)
end
--' Играем выходную анимацию
class "act_state_mgr_animation_stop" (action_base)
function act_state_mgr_animation_stop:__init(name, st) super (nil, name)
	self.st = st
end
function act_state_mgr_animation_stop:initialize()
	action_base.initialize(self)
	self.st.animation:set_state(nil)
end
function act_state_mgr_animation_stop:execute()
	action_base.execute(self)
end
function act_state_mgr_animation_stop:finalize()
	action_base.finalize(self)
end


class "animation"
function animation:__init(npc, mgr)
	self.mgr = mgr
	self.npc = npc
	
	self.animations = {
		idle		= {	prop	= { maxidle = 5,
									sumidle = 3,
									rnd = 80 },	
						into	= nil,
						out		= nil,
						idle	= { [0]	= "idle_0_idle_1",
									[1]	= "idle_1_idle_1",
									[2]	= "idle_2_idle_1",
									[3]	= "idle_3_idle_1",
									[4]	= "idle_4_idle_1",
									[8]	= "idle_8_idle_1",
									[9]	= "idle_2_idle_1",
									[10]= "idle_10_idle_1" },
						rnd		= {	[0]	= {	"idle_0_idle_0",
											"idle_0_idle_2",
											"idle_0_idle_3",
											"idle_0_idle_4" },
									[1]	= {	"idle_1_idle_0",
											"idle_1_idle_2",
											"idle_1_idle_3",
											"idle_1_idle_4" },
									[2]	= {	"idle_2_idle_0",
											"idle_2_idle_2",
											"idle_2_idle_3",
											"idle_2_idle_4"},	
									[3]	= { "idle_3_idle_0",
											"idle_3_idle_2",
											"idle_3_idle_3",
											"idle_3_idle_4" },
									[4]	= {	"idle_4_idle_0",
											"idle_4_idle_2",
											"idle_4_idle_3",
											"idle_4_idle_4" },	
									[8]	= { "idle_8_idle_0",
											"idle_8_idle_2",
											"idle_8_idle_3",
											"idle_8_idle_4" },	
									[9]	= { "idle_2_idle_0",
											"idle_2_idle_2",
											"idle_2_idle_3",
											"idle_2_idle_4" },	
									[10]= { "idle_10_idle_0",
											"idle_10_idle_2",
											"idle_10_idle_3",
											"idle_10_idle_4" }}},
		caution	= {		prop	= { maxidle = 5,
									sumidle = 3,
									rnd = 80 },	
						into	= { [0]	= "prisluh_0_in",
									[1]	= "prisluh_1_in",
									[2]	= "prisluh_2_in",
									[3]	= "prisluh_3_in",
									[4]	= "prisluh_4_in",
									[8]	= "prisluh_8_in",
									[9]	= "prisluh_9_in",
									[10]= "prisluh_10_in" },
						out		= { [0]	= "prisluh_0_out",
									[1]	= "prisluh_1_out",
									[2]	= "prisluh_2_out",
									[3]	= "prisluh_3_out",
									[4]	= "prisluh_4_out",
									[8]	= "prisluh_8_out",
									[9]	= "prisluh_9_out",
									[10]= "prisluh_10_out" },
						idle	= { [0]	= "prisluh_0_1",
									[1]	= "prisluh_1_1",
									[2]	= "prisluh_2_1",
									[3]	= "prisluh_3_1",
									[4]	= "prisluh_4_1",
									[8]	= "prisluh_8_1",
									[9]	= "prisluh_9_1",
									[10]= "prisluh_10_1" },
						rnd		= { [0]	= {	"prisluh_0_0",
											"prisluh_0_2" },
									[1]	= {	"prisluh_1_0",
											"prisluh_1_2" },
									[2]	= {	"prisluh_2_0",
											"prisluh_2_2" },
									[3]	= {	"prisluh_3_0",
											"prisluh_3_2" },
									[4]	= {	"prisluh_4_0",
											"prisluh_4_2" },
									[8]	= {	"prisluh_8_0",
											"prisluh_8_2" },
									[9]	= {	"prisluh_9_0",
											"prisluh_9_2" },
									[10]= {	"prisluh_10_0",
											"prisluh_10_2" }}},										
		poisk		= {	prop	= { maxidle = 5,
									sumidle = 3,
									rnd = 80 },
						into	= nil,
						out		= nil,
						idle	= { [0]	= "poisk_0_idle_1",
									[1]	= "poisk_1_idle_1",
									[2]	= "poisk_2_idle_1",
									[3]	= "poisk_3_idle_1",
									[4]	= "poisk_4_idle_1",
									[8]	= "poisk_8_idle_1",
									[9]	= "poisk_9_idle_1",
									[10]= "poisk_10_idle_1"},
						rnd		= { [0]	= {	"poisk_0_idle_0",
											"poisk_0_idle_2" },
									[1]	= {	"poisk_1_idle_0",
											"poisk_1_idle_2" },
									[2]	= {	"poisk_2_idle_0",
											"poisk_2_idle_2" },
									[3]	= { "poisk_3_idle_0",
											"poisk_3_idle_2" },
									[4]	= { "poisk_4_idle_0",
											"poisk_4_idle_2" },
									[8]	= { "poisk_8_idle_0",
											"poisk_8_idle_2" },
									[9]	= { "poisk_9_idle_0",
											"poisk_9_idle_2" },
									[10]= { "poisk_10_idle_0",
											"poisk_10_idle_2" }}},
		hide		= {	prop	= { maxidle = 5,
									sumidle = 3,
									rnd = 80 },
						into	= { [0] = { "cr_idle_0_in" },
									[1] = { "cr_idle_1_in" },
									[2] = { "cr_idle_2_in" },
									[3] = { "cr_idle_3_in" },
									[4] = { "cr_idle_4_in" },
									[8] = { "cr_idle_8_in" },
									[9] = { "cr_idle_9_in" },
									[10] ={ "cr_idle_10_in" }},									
						out		= { [0] = { "cr_idle_0_out" },
									[1] = { "cr_idle_1_out" },
									[2] = { "cr_idle_2_out" },
									[3] = { "cr_idle_3_out" },
									[4] = { "cr_idle_4_out" },
									[8] = { "cr_idle_8_out" },
									[9] = { "cr_idle_9_out" },
									[10] ={ "cr_idle_10_out" }},
						idle	= { [0]	= "cr_idle_0_1",
									[1]	= "cr_idle_1_1",
									[2]	= "cr_idle_2_1",
									[3]	= "cr_idle_3_1",
									[4]	= "cr_idle_4_1",
									[8]	= "cr_idle_8_1",
									[9]	= "cr_idle_9_1",
									[10]= "cr_idle_10_1" },
						rnd		= { [0] = { "cr_idle_0_0",
											"cr_idle_0_2" },
									[1] = { "cr_idle_1_0",
											"cr_idle_1_2" },
									[2] = { "cr_idle_2_0",
											"cr_idle_2_2" },
									[3] = { "cr_idle_3_0",
											"cr_idle_3_2" },
									[4] = { "cr_idle_4_0",
											"cr_idle_4_2" },
									[8] = { "cr_idle_8_0",
											"cr_idle_8_2" },
									[9] = { "cr_idle_9_0",
											"cr_idle_9_2" },
									[10]= { "cr_idle_10_0",
											"cr_idle_10_2" }}},
		sit			= {	prop	= { maxidle = 5,
									sumidle = 3,
									rnd = 80 },
						into	= nil,
						out		= nil,
						idle	= nil,
						rnd		= { [0] = { "sit_0_idle_1",
											"sit_0_idle_2",
											"sit_0_idle_3" }}},
		sit_knee	= {	prop	= { maxidle = 5,
									sumidle = 3,
									rnd = 80 },
						into	= nil,
						out		= nil,
						idle	= nil,
						rnd		= { [0] = { "sit_1_idle_1",
											"sit_1_idle_2",
											"sit_1_idle_3" }}},
		sit_ass		= {	prop	= { maxidle = 5,
									sumidle = 3,
									rnd = 80 },
						into	= nil,
						out		= nil,
						idle	= nil,
						rnd		= { [0] = { "sit_2_idle_1",
											"sit_2_idle_2",
											"sit_2_idle_3" }}},


											
		hello		= {	prop	= { maxidle = 5,
									sumidle = 5,
									rnd = 100 },
						into	= nil,
						out		= nil,
						idle	= nil,
						rnd		= {	[0]	= {	"hello_0_idle_0" },
									[1]	= {	"hello_1_idle_0" },
									[2]	= {	"hello_2_idle_0" },
									[3]	= { "hello_3_idle_0" },
									[4]	= {	"hello_4_idle_0" },
									[8]	= {	"hello_8_idle_0" },
									[9]	= {	"hello_9_idle_0" },
									[10]= {	"hello_10_idle_0" }}},
		refuse		= {	prop	= { maxidle = 3,
									sumidle = 3,
									rnd = 100 },
						into	= nil,
						out		= nil,
						idle	= nil,
						rnd		= {	[0]	= {	"net_0_0" },
									[1]	= {	"net_1_0" },
									[2]	= {	"net_2_0" },
									[3]	= {	"net_3_0" },
									[4]	= {	"net_4_0" },
									[8]	= {	"net_8_0" },
									[9]	= {	"net_9_0" },
									[10]= {	"net_10_0" }}},
		claim		= {	prop	= { maxidle = 5,
									sumidle = 2,
									rnd = 100 },
						into	= nil,
						out		= nil,
						idle	= nil,
						rnd		= {	[0]	= nil,
									[1]	= {	"gop_stop_1_0" },
									[2]	= {	"gop_stop_2_0" },
									[3]	= {	"gop_stop_3_0" },
									[4]	= {	"gop_stop_4_0" },
									[8]	= {	"gop_stop_8_0" },
									[9]	= {	"gop_stop_9_0" },
									[10]= {	"gop_stop_10_0" }}},
		backoff		= {	prop	= { maxidle = 5,
									sumidle = 2,
									rnd = 100 },
						into	= nil,
						out		= nil,
						idle	= nil,
						rnd		= {	[0]	= {	"uhodi_1_0",
											"uhodi_1_1" },
									[1]	= {	"uhodi_1_0",
											"uhodi_1_1" },
									[2]	= {	"uhodi_2_0",
											"uhodi_2_1" },
									[3]	= {	"uhodi_3_0",
											"uhodi_3_1" },
									[4]	= {	"uhodi_4_0",
											"uhodi_4_1" },
									[8]	= {	"uhodi_8_0",
											"uhodi_8_1" },
									[9]	= {	"uhodi_9_0",
											"uhodi_9_1" },
									[10]= {	"uhodi_10_0",
											"uhodi_10_1" }}},
		hide_s_left	= {	prop	= { maxidle = 1,
									sumidle = 1,
									rnd = 100 },
						into	= {	[0]	= {	"sss_left_0", {s="speech"}, "sss_left_1" },
									[2]	= {	"sss_left_0", {s="speech"}, "sss_left_1" }},
						out		= nil,
						idle	= nil,
						rnd		= nil},
		hide_s_right = {prop	= { maxidle = 1,
									sumidle = 1,
									rnd = 100 },
						into 	= {	[0]	= {	"sss_right_0", {s="speech"}, "sss_right_1"},
									[2]	= {	"sss_right_0", {s="speech"}, "sss_right_1"}},
						out		= nil,
						rnd		= nil,
						idle	= nil},
		dynamite	 = {prop	= { maxidle = 1,
									sumidle = 1,
									rnd = 100 },
						into 	= {	[0]	= {	"dinamit_1" }},
						out		= nil,
						rnd		= nil,
						idle	= nil},
		suicide		= {	prop	= { maxidle = 5,
									sumidle = 2,
									rnd = 100 },
						into	= {	[0]	= {	"kamikadze_0" }},
						out		= nil,
						idle	= {	[0]	= 	"kamikadze_1" },
						rnd		= nil},
		punch		= {	prop	= { maxidle = 5,
									sumidle = 2,
									rnd = 100 },
						into	= {	[0]	= {	"udar_0" }},
						out		= nil,
						idle	= nil,
						rnd		= nil},
		sleeping	= {	prop	= { maxidle = 5,
									sumidle = 10,
									rnd = 100 },
						into	= nil,
						out		= nil,
						idle	= nil,
						rnd		= {	[0]	= {	"sleep_idle_1" }}},
		wound_heavy	= {	prop	= { maxidle = 5,
									sumidle = 10,
									rnd = 100 },
						into	= {	[0]	= {	"waunded_1_in" }},
						out		= {	[0]	= {	"waunded_1_out" }},
						idle	= {	[0]	= "waunded_1_idle_0" },
						rnd		= nil},
		help_me		= {	prop	= { maxidle = 5,
									sumidle = 10,
									rnd = 100 },
						into	= nil,
						out		= nil,
						idle	= nil,
						rnd		= {	[0]	= {	"wounded_ruka_0" }}},
		eat_bread	= {	prop	= { maxidle = 3,
									sumidle = 3,
									rnd = 80 },
						into	= { [0]	= {"item_2_draw_0",  {a="bread_a"}, "item_2_draw_1"} },
						out		= { [0]	= {"item_2_holster_0", {d="bread_a"}, "item_2_holster_1"} },
						idle	= { [0]	= "item_2_aim_0" },
						rnd		= { [0]	= {	"item_2_prepare_0",
											"item_2_attack_0" } }},
		eat_vodka	= {	prop	= { maxidle = 3,
									sumidle = 3,
									rnd = 80 },
						into	= { [0]	= {"item_4_draw_0",  {a="vodka_a"}, "item_4_draw_1"} },
						out		= { [0]	= {"item_4_holster_0", {d="vodka_a"}, "item_4_holster_1"} },
						idle	= { [0]	= "item_4_aim_0" },
						rnd		= { [0]	= {	"item_4_prepare_0",
											"item_4_attack_0" } }},
		eat_kolbasa	= {	prop	= { maxidle = 3,
									sumidle = 3,
									rnd = 80 },
						into	= { [0]	= {"item_1_draw_0", {a="kolbasa_a"}, "item_1_draw_1"}},
						out		= { [0]	= {"item_1_holster_0", {d="kolbasa_a"}, "item_1_holster_1"} },
						idle	= { [0]	= "item_1_idle_1" },
						rnd		= { [0]	= {	"item_1_attack_0",
											"item_1_idle_0" } }},

		guitar	= {	prop	= { maxidle = 3,
									sumidle = 3,
									rnd = 80 },
						into	= { [0]	= {"sit_1_guitar_0_0", {a="guitar_a"}, "sit_1_guitar_0_1"}},
						out		= { [0]	= {"guitar_0_sit_1_0", {d="guitar_a"}, "guitar_0_sit_1_1"} },
						idle	= { [0]	= "guitar_3" },
						rnd		= { [0]	= {	"guitar_1",
											"guitar_2" } },
						subanim = { [1] = {	prop = { maxidle = 3,
													 sumidle = 3,
													 rnd = 0 },
											into_music = "guitar", 
											into	= nil,
											out		= nil,
											idle	= { [0]	= "guitar_0" },											
											rnd		= nil }}},
		harmonica	= {	prop	= { maxidle = 3,
									sumidle = 3,
									rnd = 80 },
						into	= { [0]	= {"sit_2_harmonica_1_0", {a="harmonica_a"}, "sit_2_harmonica_1_1"}},
						out		= { [0]	= {"harmonica_1_sit_2_0", {d="harmonica_a"}, "harmonica_1_sit_2_1"} },
						idle	= { [0]	= "harmonica_1" },
						rnd		= { [0]	= {	"harmonica_2",
											"harmonica_3" } },
						subanim = { [1] = {	prop = { maxidle = 3,
													 sumidle = 3,
													 rnd = 0 },
											into_music = "harmonica", 
											into	= nil,
											out		= nil,
											idle	= { [0]	= "harmonica_0" },											
											rnd		= nil }}},

		choosing	= {	prop	= { maxidle = 8,
									sumidle = 10,
									rnd = 80 },
						into	= nil,
						out		= nil,
						idle	= nil,
						rnd		= { [0]	= {	"komandir_0",
											"komandir_1",
											"komandir_2" } }},
		press		= {	prop	= { maxidle = 8,
									sumidle = 10,
									rnd = 80 },
						into	= { [0]	= {"knopka_0"} },
						out		= { [0]	= "knopka_1" },
						idle	= { [0]	= "knopka_2" },
						rnd		= nil },

		warding		= {	prop	= { maxidle = 10,
									sumidle = 10,
									rnd = 0 },
						into	= {	[0]	= "ohrana_0"},
						out		= {	[0]	= "ohrana_2"},
						idle	= {	[0]	= "ohrana_1"},
						rnd		= nil },			

		bar_fas		= {	prop	= { maxidle = 5,
									sumidle = 5,
									rnd = 70 },
						into	= {	[0]	= "bar_0_idle_in" },
						out		= {	[0]	= "bar_0_idle_out" },
						idle	= {	[0]	= "bar_0_idle_0" },
						rnd		= { [0]	= {	"bar_0_idle_1",
											"bar_0_idle_2",
											"bar_0_idle_3" } } },			
		bar_left	= {	prop	= { maxidle = 5,
									sumidle = 5,
									rnd = 70 },
						into	= {	[0]	= "bar_1_idle_in" },
						out		= {	[0]	= "bar_1_idle_out" },
						idle	= {	[0]	= "bar_1_idle_0" },
						rnd		= { [0]	= {	"bar_1_idle_1",
											"bar_1_idle_2",
											"bar_1_idle_3" } } },			
		bar_head	= {	prop	= { maxidle = 5,
									sumidle = 5,
									rnd = 70 },
						into	= {	[0]	= "bar_2_idle_in" },
						out		= {	[0]	= "bar_2_idle_out" },
						idle	= {	[0]	= "bar_2_idle_0" },
						rnd		= nil },			
		bar_sleep	= {	prop	= { maxidle = 5,
									sumidle = 5,
									rnd = 70 },
						into	= {	[0]	= "bar_3_idle_in" },
						out		= {	[0]	= "bar_3_idle_out" },
						idle	= {	[0]	= "bar_3_idle_0" },
						rnd		= nil },			
		bar_right	= {	prop	= { maxidle = 5,
									sumidle = 5,
									rnd = 70 },
						into	= {	[0]	= "bar_4_idle_in" },
						out		= {	[0]	= "bar_4_idle_out" },
						idle	= {	[0]	= "bar_4_idle_0" },
						rnd		= nil },

		barman_wait	= {	prop	= { maxidle = 5,
									sumidle = 5,
									rnd = 70 },
						into	= {	[0]	= "idle_0_to_idle_1" },
						out		= nil,
						idle	= nil,
						rnd		= { [0]	= {	"idle_0_idle_0",
											"idle_0_idle_1",
											"idle_0_idle_2",
											"idle_0_idle_3" } } },
		barman_talk	= {	prop	= { maxidle = 5,
									sumidle = 5,
									rnd = 70 },
						into	= {	[0]	= "idle_1_to_idle_0" },
						out		= nil,
						idle	= nil,
						rnd		= nil },
		psy_armed	= {	prop	= { maxidle = 1,
									sumidle = 1,
									rnd = 100 },
						into	= {	[0]	= "idle_0_to_psy_0_idle_0",
									[1]	= "idle_0_to_psy_1_idle_0" },
						out		= {	[0]	= "psy_0_idle_0_to_idle_0",
									[1]	= "psy_1_idle_0_to_idle_0" },
						idle	= {	[0]	= "psy_0_idle_0",
									[1]	= "psy_1_idle_0" },
						rnd		= { [0]	= {	"psy_0_idle_1",
											"psy_0_idle_2",
											"psy_0_idle_3" },
									[1]	= {	"psy_1_idle_1",
											"psy_1_idle_2",
											"psy_1_idle_3" } } },
		psy_shoot	= {	prop	= { maxidle = 1,
									sumidle = 1,
									rnd = 100 },
						into	= {	[1]	= {"psy_1_shot_0", {sh=1000}} },
						out		= nil,
						idle	= {	[1]	= "psy_1_death_0" },
						rnd		= nil },					
		binocular	= {	prop	= { maxidle = 1,
									sumidle = 1,
									rnd = 100 },
						into	= {	[0]	= {"binoculars_draw_0", {a="binocular_a"}, "binoculars_draw_1", "binoculars_zoom_in_0"} },
						out		= {	[0]	= {"binoculars_zoom_out_0", "binoculars_hide_0", {d="binocular_a"}, "binoculars_hide_1"} },
						idle	= {	[0]	= "binoculars_zoom_idle_0" },
						rnd		= {	[0]	= {"binoculars_zoom_idle_1",
										   "binoculars_zoom_idle_2",
										   "binoculars_zoom_idle_3",
										   "binoculars_zoom_idle_4"} } },															
		salut		= {	prop	= { maxidle = 1,
									sumidle = 1,
									rnd = 100 },
						into	= {	[0]	= {"chest_0_idle_0", "chest_0_idle_2"} },
						out		= {	[0]	= {"chest_0_idle_3"} },
						idle	= {	[0]	= "chest_0_idle_1" },
						rnd		= nil },
		salut_free	= {	prop	= { maxidle = 1,
									sumidle = 1,
									rnd = 100 },
						into	= {	[0]	= {"chest_1_idle_0"} },
						out		= nil,
						idle	= nil,
						rnd		= nil },
		raciya		= {	prop	= { maxidle = 1,
									sumidle = 1,
									rnd = 100 },
						into	= {	[0]	= {"raciya_0_draw_0", {a="hand_radio"}, "raciya_0_draw_1"},
									[1]	= {"raciya_1_draw_0", {a="hand_radio"}, "raciya_1_draw_1"},
									[2]	= {"raciya_2_draw_0", {a="hand_radio"}, "raciya_2_draw_1"},
									[3]	= {"raciya_3_draw_0", {a="hand_radio"}, "raciya_3_draw_1"},
									[4]	= {"raciya_4_draw_0", {a="hand_radio"}, "raciya_4_draw_1"},
									[8]	= {"raciya_8_draw_0", {a="hand_radio"}, "raciya_8_draw_1"},
									[9]	= {"raciya_9_draw_0", {a="hand_radio"}, "raciya_9_draw_1"},
									[10]= {"raciya_10_draw_0",{a="hand_radio"}, "raciya_10_draw_1"} },
						out		= {	[0]	= {"raciya_0_hide_0", {d="hand_radio"}, "raciya_0_hide_1"},
									[1]	= {"raciya_1_hide_0", {d="hand_radio"}, "raciya_1_hide_1"},
									[2]	= {"raciya_2_hide_0", {d="hand_radio"}, "raciya_2_hide_1"},
									[3]	= {"raciya_3_hide_0", {d="hand_radio"}, "raciya_3_hide_1"},
									[4]	= {"raciya_4_hide_0", {d="hand_radio"}, "raciya_4_hide_1"},
									[8]	= {"raciya_8_hide_0", {d="hand_radio"}, "raciya_8_hide_1"},
									[9]	= {"raciya_9_hide_0", {d="hand_radio"}, "raciya_9_hide_1"},
									[10]= {"raciya_10_hide_0",{d="hand_radio"}, "raciya_10_hide_1"} },
						idle	= {	[0]	= "raciya_0_idle_0",
									[1]	= "raciya_1_idle_0",
									[2]	= "raciya_2_idle_0",
									[3]	= "raciya_3_idle_0",
									[4]	= "raciya_4_idle_0",
									[8]	= "raciya_8_idle_0",
									[9]	= "raciya_9_idle_0",
									[10]= "raciya_10_idle_0" },
						rnd		= {	[0]	= {"raciya_0_talk_0"},
									[1]	= {"raciya_1_talk_0"},
									[2]	= {"raciya_2_talk_0"},
									[3]	= {"raciya_3_talk_0"},
									[4]	= {"raciya_4_talk_0"},
									[8]	= {"raciya_8_talk_0"},
									[9]	= {"raciya_9_talk_0"},
									[10]= {"raciya_10_talk_0"} } },
		cr_raciya		= {	prop	= { maxidle = 1,
									sumidle = 1,
									rnd = 100 },
						into	= {	[0]	= {"cr_raciya_0_draw_0", {a="hand_radio"}, "cr_raciya_0_draw_1"},
									[1]	= {"cr_raciya_1_draw_0", {a="hand_radio"}, "cr_raciya_1_draw_1"},
									[2]	= {"cr_raciya_2_draw_0", {a="hand_radio"}, "cr_raciya_2_draw_1"},
									[3]	= {"cr_raciya_3_draw_0", {a="hand_radio"}, "cr_raciya_3_draw_1"},
									[4]	= {"cr_raciya_4_draw_0", {a="hand_radio"}, "cr_raciya_4_draw_1"},
									[8]	= {"cr_raciya_8_draw_0", {a="hand_radio"}, "cr_raciya_8_draw_1"},
									[9]	= {"cr_raciya_9_draw_0", {a="hand_radio"}, "cr_raciya_9_draw_1"},
									[10]= {"cr_raciya_10_draw_0",{a="hand_radio"},"cr_raciya_10_draw_1"} },
						out		= {	[0]	= {"cr_raciya_0_hide_0", {d="hand_radio"}, "cr_raciya_0_hide_1"},
									[1]	= {"cr_raciya_1_hide_0", {d="hand_radio"}, "cr_raciya_1_hide_1"},
									[2]	= {"cr_raciya_2_hide_0", {d="hand_radio"}, "cr_raciya_2_hide_1"},
									[3]	= {"cr_raciya_3_hide_0", {d="hand_radio"}, "cr_raciya_3_hide_1"},
									[4]	= {"cr_raciya_4_hide_0", {d="hand_radio"}, "cr_raciya_4_hide_1"},
									[8]	= {"cr_raciya_8_hide_0", {d="hand_radio"}, "cr_raciya_8_hide_1"},
									[9]	= {"cr_raciya_9_hide_0", {d="hand_radio"}, "cr_raciya_9_hide_1"},
									[10]= {"cr_raciya_10_hide_0",{d="hand_radio"},"cr_raciya_10_hide_1"} },
						idle	= {	[0]	= "cr_raciya_0_idle_0",
									[1]	= "cr_raciya_1_idle_0",
									[2]	= "cr_raciya_2_idle_0",
									[3]	= "cr_raciya_3_idle_0",
									[4]	= "cr_raciya_4_idle_0",
									[8]	= "cr_raciya_8_idle_0",
									[9]	= "cr_raciya_9_idle_0",
									[10]= "cr_raciya_10_idle_0" },
						rnd		= {	[0]	= {"cr_raciya_0_talk_0"},
									[1]	= {"cr_raciya_1_talk_0"},
									[2]	= {"cr_raciya_2_talk_0"},
									[3]	= {"cr_raciya_3_talk_0"},
									[4]	= {"cr_raciya_4_talk_0"},
									[8]	= {"cr_raciya_8_talk_0"},
									[9]	= {"cr_raciya_9_talk_0"},
									[10]= {"cr_raciya_10_talk_0"} } }

	}
	
	self.states = {
		last_id = nil,
		current_state = nil,
		target_state = nil,
		begin = nil,
		idle = nil,
		anim_level = 0,
		attach_items = {hand_radio	= {mode = "detach", done = true},
						bread_a		= {mode = "detach", done = true},
						vodka_a		= {mode = "detach", done = true},
						kolbasa_a	= {mode = "detach", done = true},
						guitar_a	= {mode = "detach", done = true},
						harmonica_a	= {mode = "detach", done = true},
						binocular_a	= {mode = "detach", done = true}}
	}
	
	self.clb_settings = {
		cnt = 0,
		a = nil,
		d = nil,
		s = nil
	}
end
--' установка нового состояния
function animation:set_state(id, reset)
	printf("set new animation [%s], current_state [%s]", tostring(id), tostring(self.states.target_state))
	local nn = 0
	local wpn_slot = self:weapon_slot()
	--' выход из старого состояния
	self.npc:clear_animations()	
	if self.animations[self.states.target_state] ~= nil then
		if self.mgr.emerg.animation_nout == true or
		   self.mgr.emerg.animation == true
		then
			-- обнулить озвучку
			stop_play_sound(self.npc)
			-- экстренный выход, необходимо дропнуть приатаченные предметы
			if self.animations[self.states.target_state].out ~= nil then
				anima = self:anim_for_slot(wpn_slot,self.animations[self.states.target_state].out)
				if anima then
					if type(anima) == "table" then
						for k,v in anima do
							if type(v) == "table" and v.d ~= nil then
								local obj = self.npc:object(v.d)
								if obj then
									printf("extra detached [%s] for [%s]", obj:name(), self.npc:name())
									obj:enable_attachable_item(false)
--									printf("droped [%s] for [%s]", obj:name(), self.npc:name())
--									self.npc:set_item(object.drop, obj)
								end
								self.states.attach_items[v.d].mode = "detach"
								self.states.attach_items[v.d].done = true
							end
						end
					end
				end	
			end		
		else
			-- выход из поданимаций	
			if self.mgr.subanim > 0 then
				for key = self.mgr.subanim, 0 do
					local a = self.animations[self.states.target_state].subanim[key]
					if a and a.out then
						anima = self:anim_for_slot(wpn_slot,a.out)
						if anima then
							self.npc:add_animation(anima, true)
						end
					end
				end
			end			
			if self.animations[self.states.target_state].out ~= nil then
				anima = self:anim_for_slot(wpn_slot,self.animations[self.states.target_state].out)
				if anima then
					if type(anima) == "table" then
						for k,v in anima do
							if type(v) == "table" then
								self:set_anim_callback(v)
							else
								self.npc:add_animation(v, true)
							end
						end
					else
						self.npc:add_animation(anima, true)
					end
					nn = nn +1
				end			
			end
		end
	end
	--' вход в новое состояние	
	if self.animations[id] ~= nil then
		if self.animations[id].into ~= nil then
			anima = self:anim_for_slot(wpn_slot,self.animations[id].into)
			if type(anima) == "table" then
				for k,v in anima do
					if type(v) == "table" then
						self:set_anim_callback(v)
					else
						self.npc:add_animation(v, true)
					end
				end
				nn = nn +1
			else
				self.npc:add_animation(anima, true)
				nn = nn +1
			end
		end
		if reset == true then
			if self.mgr.callback ~= nil then
				self.mgr.callback.begin = nil
			end
			self:play_rnd(id, 100)			
		end
		if self.animations[id].idle ~= nil then
			anima = self:anim_for_slot(wpn_slot,self.animations[id].idle)
			if anima then
				self.npc:add_animation(anima, true)
			end
			nn = nn + 1
		else
			-- Для политкорректности просим анимстейт отыграть свою айдловую анимацию
			self.mgr.animstate:add_idle_animation()
		end
	else
		-- Для политкорректности просим анимстейт отыграть свою айдловую анимацию
		self.mgr.animstate:add_idle_animation()
	end

	self.states.current_state = "new"
	self.states.target_state = id
	self.states.begin = nil
	self.states.anim_level = 0
end
--' апдейт
function animation:update()
--	printf("update")
--	printf("		time %s", time_global())				
--	printf("		current state %s", utils.to_str(self.states.current_state))
--	printf("		target state %s", utils.to_str(self.states.target_state))
--	printf("		anims %s", self.npc:animation_count())
	self.is_called = false
	
	-- !!! проверка что закончился играться наш звук
	if self.sound_played then
		if self.npc:active_sound_count() == 0 then
			self.sound_played = false
		end
	end	

	-- АТТАЧ ДЕТАЧ ОБЪЕКТОВ
	for k,v in self.states.attach_items do
--		printf("Trying to attach [%s]", tostring(k))
		if v.done == false then
--			printf("proceed [%s]", tostring(k))
			local t = self.npc:object(k)
			if t then
--				printf("item [%s] exist", tostring(k))
				if v.mode == "attach" then
					printf("item [%s] attached for [%s]", tostring(k), self.npc:name())
					t:enable_attachable_item(true)
				elseif v.mode == "detach" then
					printf("item [%s] detached for [%s]", tostring(k), self.npc:name())
					t:enable_attachable_item(false)
				end
			end
			v.done = true
		end
	end
	
	if self.states.current_state == nil then
		self:callback_process()
		return
	end

	-- обрубить анимации и экстренно начать сразу
	if self.mgr.emerg ~= nil and  
	   self.mgr.emerg.animation == true then
		
		--если мы уже
--		if self.states.target_state ~= state_lib.states[self.mgr.target_state].animation 
--		then
--			self.npc:clear_animations()
--			self:set_state(nil)
--			self.states.current_state = nil
--		end			
--		self.mgr.emerg.animation = nil

		self.npc:clear_animations()
		self:set_state(nil)
		self.states.current_state = nil
		self.mgr.emerg.animation = nil

		return
	end

	-- проверка закончился ли переход в состояние
	if self.states.current_state == "new" then
		local nnum = 0
		if (self.animations[self.states.target_state] ~= nil and
		   self.animations[self.states.target_state].idle ~= nil) or
		   self.mgr.animstate:idle_animation_present()
		then
			nnum = 1
		end
		if self.npc:animation_count() <= nnum then
			self.states.current_state = self.states.target_state
			self:callback_init()
		end
		return
	end
	
	--' ожидаем окончания перехода.
	if self.states.current_state == "wait" then		
		local nnum = 0
		if (self.animations[self.states.target_state] ~= nil and
		   self.animations[self.states.target_state].idle ~= nil) or
		   self.mgr.animstate:idle_animation_present()
		then
			nnum = 1
		end
		if self.npc:animation_count() <= nnum then
			self.states.current_state = self.states.target_state
		end
		
		-- инициализация коллбека при повторном вызове этого же стейта
		if self.states.target_state == state_lib.states[self.mgr.target_state].animation and
		   self.mgr.callback and self.mgr.callback.func and self.mgr.callback.timeout and
		   self.mgr.callback.begin == nil
		then
			self:callback_init()
		end
		self:callback_process()
		return
	end
	
	-- Отыгрыш рандомных анимашек, если они есть
	if 	self.states.current_state == self.states.target_state then
		--' проверка на экстренный ресет схемы	
		if self:callback_process() == true then
			return
		end
		local wpn_slot = self:weapon_slot()
		-- Проверка на уровень рекурсивности.
		-- если нужный уровень рекурсии достигнут - играть рандомные и зацикленные айдлы из него.
		-- если нет - отыграть весь набор входных анимаций до него.
		if self.states.anim_level < self.mgr.subanim then
			self.npc:clear_animations()
			for key = self.states.anim_level+1, self.mgr.subanim do
				local a = self.animations[self.states.current_state].subanim[key]
				if a and a.into then
					anima = self:anim_for_slot(wpn_slot,a.into)
					if anima then
						self.npc:add_animation(anima, true)
					end
				end
				--' устанавливаем музыку
				if a.into_music then
					xr_sound.set_sound_play(self.npc, a.into_music)
				end				
			end
			self.states.anim_level = self.mgr.subanim
			-- добавляем айдл текущего уровня
			anima = self:anim_for_slot(wpn_slot,self.animations[self.states.current_state].subanim[self.states.anim_level].idle)
			if anima then
				self.npc:add_animation(anima, true)
			end		
			self.states.current_state = "wait"			
			return
		end
		-- если текущий уровень рекурсии выше, чем необходимый - отыграть набор выходных анимаций из него.
		if self.states.anim_level > self.mgr.subanim then
			self.npc:clear_animations()
			for key = self.states.anim_level, self.mgr.subanim+1 do
				local a = self.animations[self.states.current_state].subanim[key]
				if a and a.out then
					anima = self:anim_for_slot(wpn_slot,a.out)
					if anima then
						self.npc:add_animation(anima, true)
					end
				end
			end
			self.states.anim_level = self.mgr.subanim
			-- добавляем айдл текущего уровня
			local anima
			if self.states.anim_level == 0 then
				anima = self:anim_for_slot(wpn_slot,self.animations[self.states.current_state].idle)
			else
				anima = self:anim_for_slot(wpn_slot,self.animations[self.states.current_state].subanim[self.states.anim_level].idle)
			end
			if anima then
				self.npc:add_animation(anima, true)
			end		
			self.states.current_state = "wait"
			return
		end
		--' Определяем нужно ли добавлять анимацию или ждать
		if	self.animations[self.states.current_state] ~= nil then
			local state			
			if self.states.anim_level == 0 then
				state = self.animations[self.states.current_state]
			else
				state = self.animations[self.states.current_state].subanim[self.states.anim_level]
			end
			if state.rnd ~= nil then
				if self.states.begin == nil then				
					self:play_rnd(state, true)
				elseif time_global() - self.states.begin > self.states.idle then
					self:play_rnd(state)
				end
			end
		end		
	
	end
end
-- Отыгрыш рандомной анимации
function animation:play_rnd(state, must_play)
	--printf("try to add rnd animation [%s] for [%s]", utils.to_str(state), utils.to_str(rnd))
	-- нельзя добавлять рандом во время лока схемы.
	if not (self.mgr.planner:evaluator(self.mgr.properties["animation"]):evaluate() and
	        self.mgr.planner:evaluator(self.mgr.properties["weapon"]):evaluate())
	then
		return
	end
	
	-- !!! проверка что закончился играться наш звук
	if self.sound_played then
		if self.npc:active_sound_count() == 0 then
			self.sound_played = false
		end
		return
	end
	
	--' Определение промежутков времени между анимациями	
	self.states.begin = time_global()
	self.states.idle = (math.random(state.prop.maxidle) + 
									state.prop.sumidle) * 1000
	if math.random(100) < state.prop.rnd or must_play then	
		local wpn_slot = self:weapon_slot()
		local anima = self:anim_for_slot(wpn_slot,state.rnd)
		if anima == nil then			
			return
		end
		
		local r
		if table.getn(anima) > 1 then			
			if self.states.last_id == nil then
				r = math.random(table.getn(anima))
			else
				r = math.random(table.getn(anima)-1)
				if r >= self.states.last_id then
					r = r + 1
				end
			end
			self.states.last_id = r
		else
			r = 1
		end		
		self.npc:clear_animations()
		if anima[r] ~= nil then
			self.npc:add_animation(anima[r], true)
			-- добавить рандомный звук
			if self.mgr.synsound then
				xr_sound.set_sound_play(self.npc, self.mgr.synsound)
				self.sound_played = true		   
			end
		end
		if state.idle ~= nil then
			anima = self:anim_for_slot(wpn_slot,state.idle)
			if anima then
				self.npc:add_animation(anima, true)
			end
		else
			-- Для политкорректности просим анимстейт отыграть свою айдловую анимацию
			self.mgr.animstate:add_idle_animation()
		end				
		self.states.current_state = "wait"				
	end
end
-- Инициализация коллбека
function animation:callback_init()
--		printf("callback init")
		
		if self.mgr.callback ~= nil and
		   self.mgr.callback.func ~= nil and
		   state_lib.states[self.mgr.target_state].animation == self.states.current_state and
		   self.mgr.callback.begin == nil
		then
				self.mgr.callback.begin = time_global()
--				printf("		Callback initialized %s", time_global())				
		end
end
--' обработка колбека на время
function animation:callback_process()
		local ret = false
		
		if self.mgr.callback ~= nil and
		   self.mgr.callback.func ~= nil and
		   self.mgr.callback.begin ~= nil
		then
--			printf("callback process")
--			printf("	%s - %s ? %s", time_global(), utils.to_str(self.mgr.callback.begin), utils.to_str(self.mgr.callback.timeout))
			if time_global() - self.mgr.callback.begin >= self.mgr.callback.timeout then
--				printf("		Callback called %s", time_global())
				
				local a = self.mgr.callback.func
				local b = self.mgr.callback.obj
				self.mgr.callback.begin = nil
				self.mgr.callback.func = nil
				a(b)
				ret = true
			end
		end
		return ret
end
--' настройка колбека на особые действия
function animation:set_anim_callback(a)
	print_table(a)
	self.clb_settings.cnt = self.npc:animation_count()
	self.clb_settings.a = a.a
	self.clb_settings.d = a.d
	self.clb_settings.s = a.s
	self.clb_settings.sh = a.sh
	return true 
end
--' коллбек на особые действия
function animation:anim_callback()
	self.clb_settings.cnt = self.clb_settings.cnt - 1
	if self.clb_settings.cnt == 0 then
		if self.clb_settings.a ~= nil and
		   self.states.attach_items[self.clb_settings.a] ~= nil 
		then
			printf("item [%s] attach", utils.to_str(self.clb_settings.a))	
			self.states.attach_items[self.clb_settings.a].mode = "attach"
			self.states.attach_items[self.clb_settings.a].done = false
		end
		self.clb_settings.a = nil
		if self.clb_settings.d ~= nil and
		   self.states.attach_items[self.clb_settings.d] ~= nil 
		then
			printf("item [%s] detach", utils.to_str(self.clb_settings.d))	
			self.states.attach_items[self.clb_settings.d].mode = "detach"
			self.states.attach_items[self.clb_settings.d].done = false
		end
		self.clb_settings.d = nil
		if self.clb_settings.s ~= nil then
			xr_sound.set_sound_play(self.npc, self.clb_settings.s)
		end
		self.clb_settings.s = nil
		if self.clb_settings.sh ~= nil then
			-- наносим хит себе.
			local h = hit()
			h.power = self.clb_settings.sh
			h.direction = vector_rotate_y(self.npc:direction(), 90)
			h.bone = "bip01_head"
			h.draftsman = self.npc
			h.impulse = 200
			h.type = hit.wound
			self.npc:hit(h)
		end
		self.clb_settings.sh = nil
	end
	return true 
end
--' в каком состоянии мы находимся
function animation:state()
	return self.states.current_state
end
--' в каком состоянии мы находимся
function animation:target_state()
	return self.states.target_state
end
--' оружейный слот
function animation:weapon_slot()
	local weapon = self.npc:active_item()
	if weapon == nil or self.npc:weapon_strapped() == true then
		return 0
	end
	
	printf("SLOT [%s]", utils.to_str(weapon:animation_slot()))
		
	return weapon:animation_slot()
end
--' оружейный слот
function animation:anim_for_slot(slot, t)
	printf("ANIM for SLOT [%s]", slot)
	if t[slot] ~= nil then
		return t[slot]
	else
		return t[0]
	end			
end