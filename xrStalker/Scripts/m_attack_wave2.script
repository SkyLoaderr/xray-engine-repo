-- „то используетс€ в скрипте
-- —талкеры
-- stalker_young (молодой сталкер)  путь: way_young			позици€:	ќт костра
-- stalker_veteran (ветеран)		путь: way_veteran		позици€:	ќт костра
-- defender1						путь: way_defender1		позици€:	ќт гаражей со стороны пам€тника
-- defender2						путь: way_defender2		позици€:	ќт гаражей со стороны ангаров
-- defender3						путь: way_defender3		позици€:	—о стороны вертолетной площадки
-- defender4						путь: нет				позици€:	Ќа мосту
-- defender5						путь: нет				позици€:	Ќа мосту, ближе к баррикаде
-- tower1							путь: нет				позици€:	Ќа вышке, около шлагбаума
-- tower2							путь: нет				позици€:	Ќа дальней вышке
-- stalker_chief					путь: way_chief			позици€:	Ќа мосту
-- stalker_chief использует путь way_chief после падени€ с моста. јнимаци€ norm_dmg_escape_0
-- —криптовые зоны
-- barricade_zone					срабатывает, когда мостры пройдут баррикаду

-- ћонстры
-- m_boar_e0000, m_boar_e0001, m_boar_e0002, m_boar_e0003 - кабаны
-- m_dog_e0000, m_dog_e0001, m_dog_e0002, m_dog_e0003, m_dog_e0004, m_dog_e0005 - собаки
-- m_pseudodog_e0000, m_pseudodog_e0001, m_pseudodog_e0003 - псевдособаки
-- m_flesh_e0000, m_flesh_e0001, m_flesh_e0002, m_flesh_e0003, m_flesh_e0004 - плоть
-- ¬се монстры штурмуют баррикаду и базу

-- ƒл€ защитников создан класс Defender
-- ≈сли не задан патрульный путь, то npc изначально находитс€ в позиции "на корточках" с
-- оружием и цель выбирает из таблицы монстров 
-- ѕараметры коструктора:
--			npc			-	npc объект
--			patrol_way  -   объект патрульного пути
--			script_name	-	им€ управл€ющего скрипта
--			monsters	-	таблица, котора€ содержит монстров или еще кого, от кого надо отбиватьс€	
-- 			available	-	флаг, который указывает  на то, может ли монстр атаковать сталкера
--			stand		-	флаг, который указывает на то, стоит сталкер или сидит


local max_attackers = 	2	--максимальное количество мутантов, которые могут атаковать сталкера
local too_many		=	0	--сталкера атакуют многие
local already		=	1	--мутант уже атакует данного сталкера	
local added			=	2	--мутант добавлен в список атакующих

-------------------------------------------------------------------------------------------------------------------------------------
--  ласс защитника
-------------------------------------------------------------------------------------------------------------------------------------
class "Defender"

function Defender:__init (npc, patrol_way, script_name, monsters, available, stand)
	self.npc = npc
	self.patrol_way = way
	self.script_name = script_name
	self.monsters = monsters
	self.setdown = false
	self.pre_state = true
	self.enemy = nil
	self.waiting = 1
	self.available = available
	self.attackers = {}					-- монстры, которые атакуют сталкера.
	self.weapon = nil
	if stand == true then 
	   self.stand = move.standing 
	else 
       self.stand = move.crouch 
	end
end

function Defender:initialize ()
	self.npc:script (true, self.script_name)
	action (self.npc, anim (anim.free), cond (cond.time_end, time_infinite))	
end

function Defender:find_enemy ()
	if table.getn (self.monsters) == 0 then return nil end
	local distance = 10000000.0
	local enemy = nil
	for a = 1, table.getn (self.monsters), 1 do
		local tmonster = self.monsters[a]
		if tmonster ~= nil then
		   local tdist = distance_between (self.npc, tmonster.npc)
		   if tdist < distance and self.npc:see (tmonster.npc) == true then
		   	  distance = tdist
		   	  enemy = tmonster
		   end	  
		end
	end

	if enemy ~= nil then
       --printf ("Defender %s find enemy %s", self.npc:name (), enemy.npc:name ())	
	   if distance_between (enemy.npc, self.npc) > 30 then enemy = nil end
	end

	return enemy		
end

function Defender:get_num_attackers ()
	return table.getn (self.attackers)
end

function Defender:add_attacker (mutant)

	local num = table.getn (self.attackers)
	if num > max_attackers then 
	   return too_many
	end
	for a = 1, num, 1 do
		if self.attackers[a] == mutant then 
		   return already 
        end
	end

	table.insert (self.attackers, mutant)
	return added
end

function Defender:attacker_present (mutant)
	for a = 1, num, 1 do
		if self.attackers[a] == mutant then 
		   return true 
        end
	end
	return false
end

function Defender:is_alive ()
	if self.npc ~= nil and self.npc:alive () == true then return true end
	return false
end

function Defender:prestate ()
	if self.patrol_way == nil then 
	   self.pre_state = false 
	   return true
	end
	if npc:action () then 
	   return false 
	end
	self.pre_state = false
	self.patrol_way = nil
	return true
end


function Defender:process ()

--	printf ("Process object %s : ", self.npc:name ())

	--если npc помер, то выйдем
	if self.npc == nil or self.npc:alive () == false then 
	   return 
    end
	
	--если мы еще не на позиции, то выйдем на нее
	if self.pre_state == true and self:prestate () == false then 
	   return 
    end

	if self.weapon == nil then
  	   self.weapon = self.npc:active_item ()
	   if self.weapon ~= nil then
	      --printf ("Object %s have weapon %s", self.npc:name (), self.weapon:name ())	
	   end
	end

	--если мы еще не сидим, то с€дем 
	if self.setdown == false then
	   reset_action (self.npc, self.script_name)
	   action (self.npc, move (self.stand, move.stand, move.line, vector ():set (0, 0, 0)), 
			   look (look.search), anim (anim.danger), cond (cond.time_end, time_infinite))
	   self.setdown = true
    end
	
	
	-- или, если не нашли достойного врага
	local enemy = self:find_enemy ()
	if enemy == nil then 
	   self.enemy = nil	
	   return 
	end
	
	if self.enemy ~= enemy then
  	   reset_action (self.npc, self.script_name)
	   action (self.npc, move (self.stand, move.stand, move.line, self.npc:position ()), 
			   look (look.fire_point, enemy.npc), object (self.weapon, object.fire1),
			   cond (cond.time_end, time_infinite))
	   self.enemy = enemy
    end	
--	else
--  	   reset_action (self.npc, self.script_name)
--	   action (self.npc, move (self.stand, move.stand, move.line, vector():set (0, 0, 0)), look (look.fire_point, enemy.npc), cond (cond.time_end, time_infinite))	
--	end
 
--	if self.waiting > 0 then
--	   self.waiting = self.waiting - game.time ()
--	   if self.waiting <= 0 then
--		  reset_action (self.npc, self.script_name)
--		  printf ("Attack %s target %s", self.npc:name (), enemy.npc:name ())
--		  action (self.npc, move (self.stand, move.stand, move.line, vector ():set (0, 0, 0)), 
--				  look (look.fire_point, enemy.npc), object (self.weapon, object.fire1),
--				  cond (cond.time_end, time_infinite))	
--		  self.waiting = game.time () + math.random (2000, 3000)
--	   end
--	end		
		
end         		  
	   	  				

-------------------------------------------------------------------------------------------------------------------------------------
--  ласс монстра
-------------------------------------------------------------------------------------------------------------------------------------
class "Monster"

function Monster:__init (npc, attack_way, script_name)
	self.npc = npc
	self.way = attack_way
	self.script = script_name
	self.first_start = true
	self.freemove = false
	self.callback = nil
end

function Monster:set_callback (callback)
	self.callback = callback
end	



function Monster:initialize ()
	self.npc:script (true, self.script)
	action (self.npc, move (move.act_stand_idle, move.default, self.npc:position()), cond (cond.time_end, time_infinite))
end



function Monster:process ()

	--если монстр отущен из под скрипта, то вываливаемс€
	if self.freemove == true or self.npc == nil or self.npc:alive () == false then return end

	if self.first_start == true then	
	   reset_action (self.npc, self.script)
	   action (self.npc, move (move.act_run, move.force_type, self.way), cond (cond.move_end))
	   self.first_start = false
	   return 
	end   
	
	
	if self.npc:action () then return end
	
	if self.callback ~= nil then 
	   self.callback (self) 
	   self.callback = nil
    end
    
	self.freemove = true
	self.npc:script (false, self.script)
	printf ("Monster %s freed from our control", self.npc:name ())
	
end	

-------------------------------------------------------------------------------------------------------------------------------------
-- ¬се остальное
-------------------------------------------------------------------------------------------------------------------------------------

function boar_callback (monster)
	reset_action (monster.npc, monster.script)
  	action (monster.mpc, move (move.act_stand_idle, move.force_type, monster.npc:position ()), anim ("stand_attack_1"),
      		sound ("monsters\\boar\\attack_0", "bip01_head", vector():set(0,0,0), vector():set(0,0,0), false),  cond (cond.anim_end))
	printf ("Callback called")      		
end      		


function main ()

	local scrname = m_attack_wave2.script_name ()

    local monsters = {
                      m_attack_wave2.Monster (get_level_object ("m_boar_e0000"), patrol ("way0000"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_boar_e0001"), patrol ("way0001"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_boar_e0002"), patrol ("way0002"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_boar_e0003"), patrol ("way0003"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_dog_e0000"),  patrol ("way0004"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_dog_e0001"),  patrol ("way0005"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_dog_e0002"),  patrol ("way0006"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_dog_e0003"),  patrol ("way0007"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_dog_e0004"),  patrol ("way0008"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_pseudodog_e0000"),  patrol ("way0009"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_pseudodog_e0001"),  patrol ("way0010"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_pseudodog_e0002"),  patrol ("way0011"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_pseudodog_e0003"),  patrol ("way0012"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_flesh_e0000"),  patrol ("way0013"), scrname)
					  }
					  
	monsters[1]:set_callback (m_attack_wave2.boar_callback)					  

	local stalkers = {
					 m_attack_wave2.Defender (get_level_object ("stalker_young"), patrol ("way_young"), scrname, monsters, true, true),
					 m_attack_wave2.Defender (get_level_object ("stalker_veteran"), patrol ("way_veteran"), scrname, monsters, true, false),
					 m_attack_wave2.Defender (get_level_object ("defender1"), patrol ("way_defender1"), scrname, monsters, true, false),
					 m_attack_wave2.Defender (get_level_object ("defender2"), patrol ("way_defender2"), scrname, monsters, true, true),
					 m_attack_wave2.Defender (get_level_object ("defender3"), patrol ("way_defender2"), scrname, monsters, true, true),
					 m_attack_wave2.Defender (get_level_object ("defender4"), nil, scrname, monsters, true, false),
					 m_attack_wave2.Defender (get_level_object ("defender5"), nil, scrname, monsters, true, false),
					 m_attack_wave2.Defender (get_level_object ("tower1"), nil, scrname, monsters, false, false),
					 m_attack_wave2.Defender (get_level_object ("tower2"), nil, scrname, monsters, false, true),
					 m_attack_wave2.Defender (get_level_object ("stalker_chief"), nil, scrname, monsters, true, true)
					 }

	for a = 1, table.getn (monsters), 1 do
		monsters[a]:initialize ()
	    if a <= table.getn (stalkers) then
		   stalkers[a]:initialize ()
		end
	end
	

    wait (20000)


	while true do 
   		  for a = 1, table.getn (monsters), 1 do
			  monsters[a]:process ()
	          if a <= table.getn (stalkers) then
		         stalkers[a]:process ()
  		      end
		  end	
		  wait (200)
	end


end