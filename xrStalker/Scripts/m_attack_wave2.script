-- Что используется в скрипте
-- Сталкеры
-- stalker_young (молодой сталкер)  путь: way_young			позиция:	От костра
-- stalker_veteran (ветеран)		путь: way_veteran		позиция:	От костра
-- defender1						путь: way_defender1		позиция:	От гаражей со стороны памятника
-- defender2						путь: way_defender2		позиция:	От гаражей со стороны ангаров
-- defender3						путь: way_defender3		позиция:	Со стороны вертолетной площадки
-- defender4						путь: нет				позиция:	На мосту
-- defender5						путь: нет				позиция:	На мосту, ближе к баррикаде
-- tower1							путь: нет				позиция:	На вышке, около шлагбаума
-- tower2							путь: нет				позиция:	На дальней вышке
-- stalker_chief					путь: way_chief			позиция:	На мосту
-- stalker_chief использует путь way_chief после падения с моста. Анимация norm_dmg_escape_0
-- Скриптовые зоны
-- barricade_zone					срабатывает, когда мостры пройдут баррикаду

-- Монстры
-- m_boar_e0000, m_boar_e0001, m_boar_e0002, m_boar_e0003 - кабаны
-- m_dog_e0000, m_dog_e0001, m_dog_e0002, m_dog_e0003, m_dog_e0004, m_dog_e0005 - собаки
-- m_pseudodog_e0000, m_pseudodog_e0001, m_pseudodog_e0003 - псевдособаки
-- m_flesh_e0000, m_flesh_e0001, m_flesh_e0002, m_flesh_e0003, m_flesh_e0004 - плоть
-- Все монстры штурмуют баррикаду и базу

-- Для защитников создан класс Defender
-- Если не задан патрульный путь, то npc изначально находится в позиции "на корточках" с
-- оружием и цель выбирает из таблицы монстров 
-- Параметры коструктора:
--			npc			-	npc объект
--			patrol_way  -   объект патрульного пути
--			script_name	-	имя управляющего скрипта
--			monsters	-	таблица, которая содержит монстров или еще кого, от кого надо отбиваться	
-- 			available	-	флаг, который указывает  на то, может ли монстр атаковать сталкера
--			stand		-	флаг, который указывает на то, стоит сталкер или сидит



-------------------------------------------------------------------------------------------------------------------------------------
-- Класс монстра
-------------------------------------------------------------------------------------------------------------------------------------
class "Monster"

function Monster:__init (npc, attack_way, script_name)
	self.npc = npc
	self.way = attack_way
	self.script = script_name
	self.first_start = true
	self.freemove = false
	self.callback = nil
end

function Monster:set_callback (callback)
	self.callback = callback
end	



function Monster:initialize ()
	self.npc:script (true, self.script)
	action (self.npc, move (move.act_stand_idle, move.default, self.npc:position()), cond (cond.time_end, time_infinite))
end



function Monster:process ()

	--если монстр отущен из под скрипта, то вываливаемся
	if self.freemove == true or self.npc == nil or self.npc:alive () == false then return end

	if self.first_start == true then	
	   reset_action (self.npc, self.script)
	   action (self.npc, move (move.act_run, move.force_type, self.way), cond (cond.move_end))
	   self.first_start = false
	   return 
	end   
	
	
	if self.npc:action () then return end
	
	if self.callback ~= nil then 
	   self.callback (self) 
	   self.callback = nil
    end
    
	self.freemove = true
	self.npc:script (false, self.script)
	
	--printf ("%s if freed from our control", self.npc:name ())	
end	

function Monster:validate ()
    if self.npc ~= nil and self.npc:alive () == true then return true end
    return false
end

-------------------------------------------------------------------------------------------------------------------------------------
-- Класс защитника
-------------------------------------------------------------------------------------------------------------------------------------
class "Defender"

local on_ready = 0
local on_move = 1
local on_free = 2

function Defender:__init (npc, script, way, monsters, has_freed)
	self.npc = npc
	self.script = script
	self.way = way
	self.monsters = monsters
	self.state = on_ready
	self.has_freed = has_freed
	self.freed = false
	
	self.npc:script (true, self.script)
	action (self.npc, anim (anim.free), cond (cond.time_end, time_infinite))
end

function Defender:initialize ()

    reset_action (self.npc, self.script)
     
    if self.way == nil then
	   action (self.npc, move (move.crouch, move.stand, move.line, self.npc:position ()), anim (anim.danger), 
	   		   cond (cond.time_end, time_infinite))	
	   self.state = on_ready		   
	else
	   action (self.npc, move (move.standing, move.run, move.line, self.way), anim (anim.danger), cond (cond.move_end))
	   self.state = on_move		   		   
	end	   		   
	
	
end

function Defender:process ()
    if self.npc:alive () == false then self.freed = true end
	if self.npc == nil or self.npc:alive () == false or self.freed == true then return end
	
	--если еще идем, то вперед
	if self.state == on_move then
	   if self.npc:action () then 
	   	  return
	   else 
	      reset_action (self.npc, self.script)   
	      action (self.npc, move (move.crouch, move.stand, move.line, self.way), anim (anim.danger), cond (cond.time_end, time_infinite))	
	      self.state = on_ready 
	   end
	end   
	
	--если сталкер должен быть отпущен, то отпускаем
	if self.has_freed == true then
	   self.npc:script (false, self.script)
	   self.freed = true
	   return
	end
	
	--если таблица монстров не задана или в ней нет элементов, то отпускаем нпц       
    if self.monsters == nil or table.getn (self.monsters) == 0 then
	   self.npc:script (false, self.script)
	   self.freed = true
	   printf ("Stalker freed 2")
	   return
	end
	
	--найдем врага
	local dist = 10000000
	local enemy = nil
	local tdist
	for a = 1, table.getn (self.monsters), 1 do
	    local monster = self.monsters[a]
	    printf ("Monster : %s", monster.npc:name ())
	    if monster.npc:alive () == true then
	       tdist = distance_between (monster.npc, self.npc)
	       printf ("Distance from stalker to monster - %f", tdist)
	       if tdist < dist then
	          printf ("tdist less then dist")
              if self.npc:see(monster.npc) then
    	          printf ("Monster found")
    	          dist = tdist
    	          enemy = monster
    	      end
    	   end
	    end      
	end    
	
	--если нет врагов, то отпускаем мужика
    if enemy == nil then
	   self.npc:script (false, self.script)
	   self.freed = true
	   printf ("Stalker freed 3")
	   return
    end	   
	
	--целимся во врага
	update_action (self.npc, self.script, look (look.fire_point, enemy.npc))
    printf ("Stalker see enemy 1")
	--если дистанция более 30 метров, то ничего не делаем
	if tdist > 30 then return end
    printf ("Stalker see enemy 2")
	--стреляем
    update_action (self.npc, self.script, object (self.npc:active_item (), object.fire1))
	
end

-------------------------------------------------------------------------------------------------------------------------------------
-- Все остальное
-------------------------------------------------------------------------------------------------------------------------------------

function boar_callback (monster)
	reset_action (monster.npc, monster.script)
  	action (monster.mpc, move (move.act_stand_idle, move.force_type, monster.npc:position ()), anim ("stand_attack_1"),
      		sound ("monsters\\boar\\attack_0", "bip01_head", vector():set(0,0,0), vector():set(0,0,0), false),  cond (cond.anim_end))
	printf ("Callback called")      		
end      		

local entered = false
function on_zone_enter (zone, obj)
    zone:clear_callback (true)
    entered = true
end

function main ()

	local scrname = m_attack_wave2.script_name ()

    local monsters = {
                      m_attack_wave2.Monster (get_level_object ("m_boar_e0000"), patrol ("way0000"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_boar_e0001"), patrol ("way0001"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_boar_e0002"), patrol ("way0002"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_boar_e0003"), patrol ("way0003"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_dog_e0000"),  patrol ("way0004"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_dog_e0001"),  patrol ("way0005"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_dog_e0002"),  patrol ("way0006"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_dog_e0003"),  patrol ("way0007"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_dog_e0004"),  patrol ("way0008"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_pseudodog_e0000"),  patrol ("way0009"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_pseudodog_e0001"),  patrol ("way0010"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_pseudodog_e0002"),  patrol ("way0011"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_pseudodog_e0003"),  patrol ("way0012"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_flesh_e0000"),  patrol ("way0013"), scrname)
					  }
					  
	--monsters[1]:set_callback (m_attack_wave2.boar_callback)					  
    
	local stalkers = {
					 m_attack_wave2.Defender (get_level_object ("stalker_young"), scrname, patrol ("way_young"), monsters, true),
					 m_attack_wave2.Defender (get_level_object ("stalker_veteran"), scrname, patrol ("way_veteran"), monsters, true),
					 m_attack_wave2.Defender (get_level_object ("defender1"), scrname, patrol ("way_defender1"), monsters, true),
					 m_attack_wave2.Defender (get_level_object ("defender2"), scrname, patrol ("way_defender2"),monsters, true),
					 m_attack_wave2.Defender (get_level_object ("defender3"), scrname, patrol ("way_defender2"), monsters, true),
					 m_attack_wave2.Defender (get_level_object ("defender4"), scrname, nil, monsters, true),
					 m_attack_wave2.Defender (get_level_object ("defender5"), scrname, nil, monsters, true),
					 m_attack_wave2.Defender (get_level_object ("tower1"), scrname, nil, monsters, false),
					 m_attack_wave2.Defender (get_level_object ("tower2"), scrname, nil, monsters, false),
					 m_attack_wave2.Defender (get_level_object ("stalker_chief"), scrname, nil, monsters, true)
					 }
					 
    local enter_zone = get_level_object ("barricade_zone")
    enter_zone:set_callback (m_attack_wave2.on_zone_enter, true)

	for a = 1, table.getn (monsters), 1 do
		monsters[a]:initialize ()
	end
	

    wait (20000)

	while entered == false do
	      for a = 1, table.getn (monsters), 1 do   
		      monsters[a]:process ()
		  end
          wait ()
	end


	for a = 1, table.getn (stalkers), 1 do
	    stalkers[a]:initialize ()
    end	    

	while true do 
   		  for a = 1, table.getn (monsters), 1 do
			  monsters[a]:process ()
	          if a <= table.getn (stalkers) then
		         stalkers[a]:process ()
  		      end
		  end	
		  wait ()
	end


end