-- Что используется в скрипте
-- Сталкеры
-- stalker_young (молодой сталкер)  путь: way_young			позиция:	От костра
-- stalker_veteran (ветеран)		путь: way_veteran		позиция:	От костра
-- defender1						путь: way_defender1		позиция:	От гаражей со стороны памятника
-- defender2						путь: way_defender2		позиция:	От гаражей со стороны ангаров
-- defender3						путь: way_defender3		позиция:	Со стороны вертолетной площадки
-- defender4						путь: нет				позиция:	На мосту
-- defender5						путь: нет				позиция:	На мосту, ближе к баррикаде
-- tower1							путь: нет				позиция:	На вышке, около шлагбаума
-- tower2							путь: нет				позиция:	На дальней вышке
-- stalker_chief					путь: way_chief			позиция:	На мосту
-- stalker_chief использует путь way_chief после падения с моста. Анимация norm_dmg_escape_0
-- Скриптовые зоны
-- barricade_zone					срабатывает, когда мостры пройдут баррикаду

-- Монстры
-- m_boar_e0000, m_boar_e0001, m_boar_e0002, m_boar_e0003 - кабаны
-- m_dog_e0000, m_dog_e0001, m_dog_e0002, m_dog_e0003, m_dog_e0004, m_dog_e0005 - собаки
-- m_pseudodog_e0000, m_pseudodog_e0001, m_pseudodog_e0003 - псевдособаки
-- m_flesh_e0000, m_flesh_e0001, m_flesh_e0002, m_flesh_e0003, m_flesh_e0004 - плоть
-- Все монстры штурмуют баррикаду и базу

-- Для защитников создан класс Defender
-- Если не задан патрульный путь, то npc изначально находится в позиции "на корточках" с
-- оружием и цель выбирает из таблицы монстров 
-- Параметры коструктора:
--			npc			-	npc объект
--			patrol_way  -   объект патрульного пути
--			script_name	-	имя управляющего скрипта
--			monsters	-	таблица, которая содержит монстров или еще кого, от кого надо отбиваться	
-- 			available	-	флаг, который указывает  на то, может ли монстр атаковать сталкера
--			stand		-	флаг, который указывает на то, стоит сталкер или сидит


-------------------------------------------------------------------------------------------------------------------------------------
-- Класс защитника
-------------------------------------------------------------------------------------------------------------------------------------
class "Defender"

function Defender:__init (npc, patrol_way, script_name, monsters, available, stand)
	self.npc = npc
	self.patrol_way = way
	self.script_name = script_name
	self.monsters = monsters
	self.setdown = false
	self.pre_state = true
	self.enemy = nil
	self.waiting = 1
	self.available = available
	self.attacker = nil					-- монстр, который атакует сталкера. Если не nil, то сталкер свободен :)
	self.weapon = nil
	if stand == true then 
	   self.stand = move.standing 
	else 
       self.stand = move.crouch 
	end
end

function Defender:initialize ()
	self.npc:script (true, self.script_name)
	action (self.npc, anim (anim.free), cond (cond.time_end, time_infinite))	
end

function Defender:find_enemy ()
	if table.getn (self.monsters) == 0 then return nil end
	local distance = 10000000.0
	local enemy = nil
	for a = 1, table.getn (self.monsters), 1 do
		local tmonster = self.monsters[a]
		if tmonster ~= nil then
		   local tdist = distance_between (self.npc, tmonster.npc)
		   if tdist < distance and self.npc:see (tmonster.npc) == true then
		   	  distance = tdist
		   	  enemy = tmonster
		   end	  
		end
	end

	if enemy ~= nil then
       printf ("Defender %s find enemy %s", self.npc:name (), enemy.npc:name ())	
	   if distance_between (enemy.npc, self.npc) > 30 then enemy = nil end
	end

	return enemy		
end

function Defender:is_alive ()
	if self.npc ~= nil and self.npc:alive () == true then return true end
	return false
end

function Defender:prestate ()
	if self.patrol_way == nil then 
	   self.pre_state = false 
	   return true
	end
	if npc:action () then 
	   return false 
	end
	self.pre_state = false
	self.patrol_way = nil
	return true
end


function Defender:process ()

--	printf ("Process object %s : ", self.npc:name ())

	--если npc помер, то выйдем
	if self.npc == nil or self.npc:alive () == false then 
	   return 
    end
	
	--если мы еще не на позиции, то выйдем на нее
	if self.pre_state == true and self:prestate () == false then 
	   return 
    end

	if self.weapon == nil then
  	   self.weapon = self.npc:active_item ()
	   if self.weapon ~= nil then
	      printf ("Object %s have weapon %s", self.npc:name (), self.weapon:name ())	
	   end
	end

	--если мы еще не сидим, то сядем 
	if self.setdown == false then
	   reset_action (self.npc, self.script_name)
	   action (self.npc, move (self.stand, move.stand, move.line, vector ():set (0, 0, 0)), 
			   look (look.search), anim (anim.danger), cond (cond.time_end, time_infinite))
	   self.setdown = true
    end
	
	
	-- или, если не нашли достойного врага
	local enemy = self:find_enemy ()
	if enemy == nil then 
	   self.enemy = nil	
	   return 
	end
	
	if self.enemy ~= enemy then
  	   reset_action (self.npc, self.script_name)
	   action (self.npc, move (self.stand, move.stand, move.line, vector ():set (0, 0, 0)), 
			   look (look.fire_point, enemy.npc), cond (cond.time_end, time_infinite))
	   self.enemy = enemy
	else
  	   reset_action (self.npc, self.script_name)
	   action (self.npc, move (self.stand, move.stand, move.line, vector():set (0, 0, 0)), look (look.fire_point, enemy.npc), cond (cond.time_end, time_infinite))	
	end
 
	if self.waiting > 0 then
	   self.waiting = self.waiting - game.time ()
	   if self.waiting <= 0 then
		  reset_action (self.npc, self.script_name)
		  printf ("Attack %s target %s", self.npc:name (), enemy.npc:name ())
		  action (self.npc, move (self.stand, move.stand, move.line, vector ():set (0, 0, 0)), 
				  look (look.fire_point, enemy.npc), object (self.weapon, object.fire1),
				  cond (cond.time_end, time_infinite))	
		  self.waiting = game.time () + math.random (2000, 3000)
	   end
	end		
		
end         		  
	   	  				

-------------------------------------------------------------------------------------------------------------------------------------
-- Класс монстра
-------------------------------------------------------------------------------------------------------------------------------------
class "Monster"

function Monster:__init (npc, attack_way, script_name)
	self.npc = npc
	self.way = attack_way
	self.script = script_name
	self.moving = true
	self.first_start = true
	self.target = nil
	self.targets = {}
end



function Monster:initialize ()
	self.npc:script (true, self.script)
	action (self.npc, move (move.act_stand_idle, move.default, vector ():set (0, 0, 0)), cond (cond.time_end, time_infinite))
end

function Monster:set_enemyes (enemyes)
	self.targets = enemyes
end

function Monster:is_alive ()
	if self.npc ~= nil and self.npc:alive () == true then return true end
	return false
end

function Monster:find_enemy ()
	if table.getn (self.targets) == 0 then return nil end	
	local dist = 100000000
	local enemy = nil
	for a = 1, table.getn (self.targets), 1 do
		if self.targets[a]:is_alive () == true and self.targets[a].available == true then
		   local tdist = distance_between (self.npc, self.targets[a].npc) 
		   if tdist < dist and self.targets[a].attacker == nil and self.npc:see (self.targets[a].npc) then
			  dist = tdist
			  enemy = self.targets[a]
		   end
        end
	end
	if enemy ~= nil then enemy.attacker = self end
	
	if enemy ~= nil then
  	   printf ("Attacker %s find enemy %s", self.npc:name (), enemy.npc:name ())	
	   if distance_between (enemy.npc, self.npc) > 30 then enemy = nil end
	end
	return enemy
end

function Monster:process ()

--	printf ("Process object %s : ", self.npc:name ())

	if self.first_start == true then
	   self.first_start = false	
	   reset_action (self.npc, self.script)
	   action (self.npc, move (move.act_run, move.force_type, self.way), cond (cond.move_end))
	   printf ("Move attacker : %s", self.npc:name ())	
	   return	
	end

	if self.moving == true then 
	   if self.npc:action () then 
--		  printf ("Attacker %s in move", self.npc:name ())
		  return 
       end
	   printf ("Attacker %s is end move", self.npc:name ())	
	   self.moving = false
    end	 

	local enemy = nil
	if self.target == nil or self.target:is_alive () == false then enemy = self:find_enemy () end
	if enemy == nil then return 
	else
       if enemy ~= self.target then 
		  reset_action (self.npc, self.script)
		  action (self.npc, move (move.act_run, move.force_type, enemy.npc), cond (cond.time_end))
	   end	  
	end   

	self.target = enemy

	if distance_between (self.npc, self.target.npc) < 2 then
       reset_action (self.npc, self.script)
	   action_first (self.npc, move (act_attack, move.default, self.target.npc), cond (cond.time_end, 1000))
	end
	
end	   

-------------------------------------------------------------------------------------------------------------------------------------
-- Все остальное
-------------------------------------------------------------------------------------------------------------------------------------


function main ()

	local scrname = m_attack_wave2.script_name ()

    local monsters = {
                      m_attack_wave2.Monster (get_level_object ("m_boar_e0000"), patrol ("way0000"), scrname)
--                      m_attack_wave2.Monster (get_level_object ("m_boar_e0001"), patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_boar_e0002"), patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_boar_e0003"), patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_dog_e0000"),  patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_dog_e0001"),  patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_dog_e0002"),  patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_dog_e0003"),  patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_dog_e0004"),  patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_dog_e0005"),  patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_pseudodog_e0000"),  patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_pseudodog_e0001"),  patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_pseudodog_e0002"),  patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_pseudodog_e0003"),  patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_flesh_e0000"),  patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_flesh_e0001"),  patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_flesh_e0002"),  patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_flesh_e0003"),  patrol ("way0000"), scrname),
--                      m_attack_wave2.Monster (get_level_object ("m_flesh_e0004"),  patrol ("way0000"), scrname)
					  }

	local stalkers = {
--					 m_attack_wave2.Defender (get_level_object ("stalker_young"), patrol ("way_young"), scrname, monsters, true, true),
--					 m_attack_wave2.Defender (get_level_object ("stalker_veteran"), patrol ("way_veteran"), scrname, monsters, true, false),
--					 m_attack_wave2.Defender (get_level_object ("defender1"), patrol ("way_defender1"), scrname, monsters, true, false),
--					 m_attack_wave2.Defender (get_level_object ("defender2"), patrol ("way_defender2"), scrname, monsters, true, true),
--					 m_attack_wave2.Defender (get_level_object ("defender3"), patrol ("way_defender2"), scrname, monsters, true, true),
--					 m_attack_wave2.Defender (get_level_object ("defender4"), nil, scrname, monsters, true, false),
--					 m_attack_wave2.Defender (get_level_object ("defender5"), nil, scrname, monsters, true, false),
--					 m_attack_wave2.Defender (get_level_object ("tower1"), nil, scrname, monsters, false, false),
--					 m_attack_wave2.Defender (get_level_object ("tower2"), nil, scrname, monsters, false, true),
--					 m_attack_wave2.Defender (get_level_object ("stalker_chief"), nil, scrname, monsters, true, true)
					 }

	for a = 1, table.getn (monsters), 1 do
		monsters[a]:set_enemyes (stalkers)
		monsters[a]:initialize ()
--	    if a <= table.getn (stalkers) then
--		   stalkers[a]:initialize ()
		end
	end
	

    wait (20000)


	while true do 
   		  for a = 1, table.getn (monsters), 1 do
			  monsters[1]:process ()
--	          if a <= table.getn (stalkers) then
--		         stalkers[a]:process ()
  		      end
		  end	
		  wait (200)
	end


end