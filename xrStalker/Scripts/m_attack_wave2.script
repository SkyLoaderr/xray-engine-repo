-- „то используетс€ в скрипте
-- stalker_young (молодой сталкер)  путь: way_young	от костра
-- stalker_veteran (ветеран)		путь	

-- ƒл€ защитников создан класс Defender
-- ≈сли не задан патрульный путь, то npc изначально находитс€ в позиции "на корточках" с
-- оружием и цель выбирает из таблицы монстров 
-- ѕараметры коструктора:
--			npc			-	npc объект
--			patrol_way  -   объект патрульного пути
--			script_name	-	им€ управл€ющего скрипта
--			monsters	-	таблица, котора€ содержит монстров или еще кого, от кого надо отбиватьс€	

class "Defender"

function Defender:__init (npc, patrol_way, script_name, monsters)
	self.npc = npc
	self.patrol_way = way
	self.script_name = script_name
	self.monsters = monsters
	self.setdown = false
	self.pre_state = true
	self.enemy = nil
	self.waiting = 0
end

function Defender:initialize ()
	self.npc:script (true, self.script_name)
	action (self.npc, anim (anim.free), cond (cond.time_end, time_infinite))	
end

function Defender:find_enemy ()
	if table.getn (self.monsters) == 0 then return nil end
	local distance = 10000000.0
	local enemy = nil
	for a = 1, table.getn (self.monsters), 1 do
		local tmonster = self.monsters[a]
		if tmonster ~= nil then
		   local tdist = distance_between (self.npc, tmonster)
		   if tdist < distance and self.npc:see (tmonster) == true then
		   	  distance = tdist
		   	  enemy = tmonster
		   end	  
		end
	end	
	return enemy		
end

function Defender:prestate ()
	if self.patrol_way == nil then 
	   self.pre_state = false 
	   return true
	end
	if npc:action () then 
	   return false 
	end
	self.pre_state = false
	self.patrol_way = nil
	return true
end


function Defender:process ()

	--если npc помер, то выйдем
	if self.npc == nil or self.npc:alive () == false then 
	   return 
    end
	
	--если мы еще не на позиции, то выйдем на нее
	if self.pre_state == true and self:prestate () == false then 
	   return 
    end

	--если мы еще не сидим, то с€дем 
	if self.setdown == false then
	   reset_action (self.npc, self.script_name)
	   action (self.npc, move (move.crouch, move.stand), look (look.free), anim (anim.danger), cond (cond.time_end, time_infinite))
	   selt.setdown = true
    end
	
	
	-- или, если не нашли достойного врага
	local enemy = self:find_enemy ()
	if enemy == nil then 
	   self.enemy = nil	
	   return 
	end
	
	if self.enemy ~= enemy then
  	   reset_action (self.npc, self.script_name)
	   action (self.npc, move (move.crouch, move.stand), look (look.fire_point, enemy), cond (cond.time_end, time_infinite))
	   self.enemy = enemy
	else
  	   reset_action (self.npc, self.script_name)
	   action (self.npc, move (move.crouch, move.stand), look (look.fire_point, enemy), cond (cond.time_end, time_infinite))	
	end
 
	if waiting ~= 0 then
	   waiting = waiting - game.time ()
	   if waiting < 0 then
		  waiting = game.time () + math.random (2000, 3000)
	   end
	end		
		
end         		  
	   	  				


local chief = nil

function boar_callback (obj, action_type, index)

  	local ptr = patrol (obj:patrol ())

	printf ("Path : %s, index : %d", obj:patrol (), index) 

	if index < 0 then return end

	if ptr:flag (index, 1) then
	   action_first (obj, anim ("stand_attack_2"), cond (cond.anim_end))
  	   local h = hit()
       h.power = 1
       h.direction:set (-1, 0, 0)
       h:bone ("bip01_head")
       h.draftsman = obj
       h.impulse = 1000
       h.type  = hit.strike
       chief:hit (h)
	   printf ("Chief hit !!!")	
       obj:clear_callback (game_object.movement)
	   end	
		
end


function main ()
	
	chief = get_level_object ("stalker_chief")
	chief:script (true, m_attack_wave2.script_name ())
	printf ("Script name : %s", m_attack_wave2.script_name ())

    local t = {
               get_level_object ("m_boar_e0000"),
               get_level_object ("m_boar_e0001"),
               get_level_object ("m_boar_e0002"),
               get_level_object ("m_boar_e0003"),
               get_level_object ("m_dog_e0000"),
               get_level_object ("m_dog_e0001"),
               get_level_object ("m_dog_e0002"),
               get_level_object ("m_dog_e0003"),
               get_level_object ("m_dog_e0004"),
               get_level_object ("m_dog_e0005"),
               get_level_object ("m_pseudodog_e0000"),
               get_level_object ("m_pseudodog_e0001"),
               get_level_object ("m_pseudodog_e0002"),
               get_level_object ("m_pseudodog_e0003"),
               get_level_object ("m_flesh_e0000"),
               get_level_object ("m_flesh_e0001"),
               get_level_object ("m_flesh_e0002"),
               get_level_object ("m_flesh_e0003"),
               get_level_object ("m_flesh_e0004"),
               }
    local tways = {
                  patrol ("way0000"),            --m_boar_e0000
                  patrol ("way0001"),            --m_boar_e0001
                  patrol ("way0002"),            --m_boar_e0002
                  patrol ("way0003"),            --m_boar_e0003
                  patrol ("way0004"),            --m_dog_e0000
                  patrol ("way0005"),            --m_dog_e0001
                  patrol ("way0006"),            --m_dog_e0002
                  patrol ("way0007"),            --m_dog_e0003
                  patrol ("way0008"),            --m_dog_e0004
                  patrol ("way0009"),            --m_dog_e0005
                  patrol ("way0001"),            --m_pseudodog_e0000
                  patrol ("way0005"),            --m_pseudodog_e0001
                  patrol ("way0003"),            --m_pseudodog_e0002
                  patrol ("way0002"),            --m_pseudodog_e0003
                  patrol ("way0010"),            --m_flesh_e0000
                  patrol ("way0011"),            --m_flesh_e0001
                  patrol ("way0003"),            --m_flesh_e0002
                  patrol ("way0009"),            --m_flesh_e0003
                  patrol ("way0012"),            --m_flesh_e0004
                  }


    for a = 1, table.getn (t), 1 do
        t[a]:script (true, m_attack_wave2.script_name ())
        action (t[a], move (move.act_stand_idle, move.default, tways[a]), cond (cond.time_end, 1000000000))
        end

    wait (20000)


	t[1]:set_callback (m_attack_wave2.boar_callback, game_object.movement)

    for a = 1, table.getn (t), 1 do
        reset_action (t[a], m_attack_wave2.script_name ())
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        action (t[a], move (move.act_run, move.force_type, tways[a]), cond (cond.move_end))
        end

    wait (120000)

    for a = 1, table.getn (t), 1 do
        t[a]:script (false, m_attack_wave2.script_name ())
        end

end