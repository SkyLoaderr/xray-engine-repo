-- Что используется в скрипте
-- Сталкеры
-- stalker_young (молодой сталкер)  путь: way_young			позиция:	От костра
-- stalker_veteran (ветеран)		путь: way_veteran		позиция:	От костра
-- defender1						путь: way_defender1		позиция:	От гаражей со стороны памятника
-- defender2						путь: way_defender2		позиция:	От гаражей со стороны ангаров
-- defender3						путь: way_defender3		позиция:	Со стороны вертолетной площадки
-- defender4						путь: нет				позиция:	На мосту
-- defender5						путь: нет				позиция:	На мосту, ближе к баррикаде
-- tower1							путь: нет				позиция:	На вышке, около шлагбаума
-- tower2							путь: нет				позиция:	На дальней вышке
-- stalker_chief					путь: way_chief			позиция:	На мосту
-- stalker_chief использует путь way_chief после падения с моста. Анимация norm_dmg_escape_0
-- Скриптовые зоны
-- barricade_zone					срабатывает, когда мостры пройдут баррикаду

-- Монстры
-- m_boar_e0000, m_boar_e0001, m_boar_e0002, m_boar_e0003 - кабаны
-- m_dog_e0000, m_dog_e0001, m_dog_e0002, m_dog_e0003, m_dog_e0004, m_dog_e0005 - собаки
-- m_pseudodog_e0000, m_pseudodog_e0001, m_pseudodog_e0003 - псевдособаки
-- m_flesh_e0000, m_flesh_e0001, m_flesh_e0002, m_flesh_e0003, m_flesh_e0004 - плоть
-- Все монстры штурмуют баррикаду и базу

-- Для защитников создан класс Defender
-- Если не задан патрульный путь, то npc изначально находится в позиции "на корточках" с
-- оружием и цель выбирает из таблицы монстров 
-- Параметры коструктора:
--			npc			-	npc объект
--			patrol_way  -   объект патрульного пути
--			script_name	-	имя управляющего скрипта
--			monsters	-	таблица, которая содержит монстров или еще кого, от кого надо отбиваться	
-- 			available	-	флаг, который указывает  на то, может ли монстр атаковать сталкера
--			stand		-	флаг, который указывает на то, стоит сталкер или сидит


local max_attackers = 	2	--максимальное количество мутантов, которые могут атаковать сталкера
local too_many		=	0	--сталкера атакуют многие
local already		=	1	--мутант уже атакует данного сталкера	
local added			=	2	--мутант добавлен в список атакующих

-------------------------------------------------------------------------------------------------------------------------------------
-- Класс защитника
-------------------------------------------------------------------------------------------------------------------------------------
class "Defender"

function Defender:__init (npc, patrol_way, script_name, monsters, available, stand)
	self.npc = npc
	self.patrol_way = way
	self.script_name = script_name
	self.monsters = monsters
	self.setdown = false
	self.pre_state = true
	self.enemy = nil
	self.waiting = 1
	self.available = available
	self.attackers = {}					-- монстры, которые атакуют сталкера.
	self.weapon = nil
	if stand == true then 
	   self.stand = move.standing 
	else 
       self.stand = move.crouch 
	end
end

function Defender:initialize ()
	self.npc:script (true, self.script_name)
	action (self.npc, anim (anim.free), cond (cond.time_end, time_infinite))	
end

function Defender:find_enemy ()
	if table.getn (self.monsters) == 0 then return nil end
	local distance = 10000000.0
	local enemy = nil
	for a = 1, table.getn (self.monsters), 1 do
		local tmonster = self.monsters[a]
		if tmonster ~= nil then
		   local tdist = distance_between (self.npc, tmonster.npc)
		   if tdist < distance and self.npc:see (tmonster.npc) == true then
		   	  distance = tdist
		   	  enemy = tmonster
		   end	  
		end
	end

	if enemy ~= nil then
       printf ("Defender %s find enemy %s", self.npc:name (), enemy.npc:name ())	
	   if distance_between (enemy.npc, self.npc) > 30 then enemy = nil end
	end

	return enemy		
end

function Defender:get_num_attackers ()
	return table.getn (self.attackers)
end

function Defender:add_attacker (mutant)

	local num = table.getn (self.attackers)
	if num > max_attackers then 
	   return too_many
	end
	for a = 1, num, 1 do
		if self.attackers[a] == mutant then 
		   return already 
        end
	end

	table.insert (self.attackers, mutant)
	return added
end

function Defender:attacker_present (mutant)
	for a = 1, num, 1 do
		if self.attackers[a] == mutant then 
		   return true 
        end
	end
	return false
end

function Defender:is_alive ()
	if self.npc ~= nil and self.npc:alive () == true then return true end
	return false
end

function Defender:prestate ()
	if self.patrol_way == nil then 
	   self.pre_state = false 
	   return true
	end
	if npc:action () then 
	   return false 
	end
	self.pre_state = false
	self.patrol_way = nil
	return true
end


function Defender:process ()

--	printf ("Process object %s : ", self.npc:name ())

	--если npc помер, то выйдем
	if self.npc == nil or self.npc:alive () == false then 
	   return 
    end
	
	--если мы еще не на позиции, то выйдем на нее
	if self.pre_state == true and self:prestate () == false then 
	   return 
    end

	if self.weapon == nil then
  	   self.weapon = self.npc:active_item ()
	   if self.weapon ~= nil then
	      printf ("Object %s have weapon %s", self.npc:name (), self.weapon:name ())	
	   end
	end

	--если мы еще не сидим, то сядем 
	if self.setdown == false then
	   reset_action (self.npc, self.script_name)
	   action (self.npc, move (self.stand, move.stand, move.line, vector ():set (0, 0, 0)), 
			   look (look.search), anim (anim.danger), cond (cond.time_end, time_infinite))
	   self.setdown = true
    end
	
	
	-- или, если не нашли достойного врага
	local enemy = self:find_enemy ()
	if enemy == nil then 
	   self.enemy = nil	
	   return 
	end
	
	if self.enemy ~= enemy then
  	   reset_action (self.npc, self.script_name)
	   action (self.npc, move (self.stand, move.stand, move.line, self.npc:position ()), 
			   look (look.fire_point, enemy.npc), object (self.weapon, object.fire1),
			   cond (cond.time_end, time_infinite))
	   self.enemy = enemy
    end	
--	else
--  	   reset_action (self.npc, self.script_name)
--	   action (self.npc, move (self.stand, move.stand, move.line, vector():set (0, 0, 0)), look (look.fire_point, enemy.npc), cond (cond.time_end, time_infinite))	
--	end
 
--	if self.waiting > 0 then
--	   self.waiting = self.waiting - game.time ()
--	   if self.waiting <= 0 then
--		  reset_action (self.npc, self.script_name)
--		  printf ("Attack %s target %s", self.npc:name (), enemy.npc:name ())
--		  action (self.npc, move (self.stand, move.stand, move.line, vector ():set (0, 0, 0)), 
--				  look (look.fire_point, enemy.npc), object (self.weapon, object.fire1),
--				  cond (cond.time_end, time_infinite))	
--		  self.waiting = game.time () + math.random (2000, 3000)
--	   end
--	end		
		
end         		  
	   	  				

-------------------------------------------------------------------------------------------------------------------------------------
-- Класс монстра
-------------------------------------------------------------------------------------------------------------------------------------
class "Monster"

function Monster:__init (npc, attack_way, script_name)
	self.npc = npc
	self.way = attack_way
	self.script = script_name
	self.moving = true
	self.first_start = true
	self.target = nil
	self.targets = {}
	self.freemove = false
end



function Monster:initialize ()
	self.npc:script (true, self.script)
	action (self.npc, move (move.act_stand_idle, move.default, self.npc:position()), cond (cond.time_end, time_infinite))
	self.npc:set_callback (self, "callback", game_object.movement)
end

function Monster:callback (obj, action_type, index)

    local ptr = patrol (obj:patrol ())

  	if index < 0 then return end

    if ptr:flag (index, 1) == true then 	
	   self.moving = false 
	   self.npc:clear_callback (game_object.movement)
	   printf ("Callback called for object %s", self.npc:name ())	 
	end

	
	

end

function Monster:set_enemyes (enemyes)
	self.targets = enemyes
end

function Monster:is_alive ()
	if self.npc ~= nil and self.npc:alive () == true then return true end
	return false
end

function Monster:find_enemy ()
	if table.getn (self.targets) == 0 then return nil end	
	local dist = 100000000
	local enemy = nil
	for a = 1, table.getn (self.targets), 1 do
		if self.targets[a]:is_alive () == true and self.targets[a].available == true then
		   local tdist = distance_between (self.npc, self.targets[a].npc) 
		   if tdist < dist and 
			  self.targets[a]:get_num_attackers () < max_attackers and 
			  self.targets[a]:attacker_present (self) == false and
			  self.npc:see (self.targets[a].npc) then
			  dist = tdist
			  enemy = self.targets[a]
		   end
        end
	end

	if enemy ~= nil then enemy:add_attacker (self) end
	
--	if enemy ~= nil then
--  	   printf ("Attacker %s find enemy %s", self.npc:name (), enemy.npc:name ())	
--	   if distance_between (enemy.npc, self.npc) > 30 then enemy = nil end
--	end

	return enemy
end

function Monster:process ()

	--если монстр отущен из под скрипта, то вываливаемся
	if self.freemove == true then return end

--	printf ("Process object %s : ", self.npc:name ())

	--если первый заход, то двигаем монстра по пути
	if self.first_start == true then
	   self.first_start = false	
	   reset_action (self.npc, self.script)
	   action (self.npc, move (move.act_run, move.force_type, self.way), cond (cond.move_end))
	   printf ("Move attacker : %s", self.npc:name ())	
	   return	
	end

	--если монстр еще двигается по пути, то выйдем
	if self.moving == true then return end

	if true then
   	   self.npc:script (false, self.script)
	   self.freemove = true
  	   return
	end	

	--если больше нет целей, то отпускаем зверя и флаг ему в руки 
	if table.getn (self.targets) == 0 then 
	   self.npc:script (false, self.script)
	   self.freemove = true
	   return	 
	end

	--ищем врага в списке. Критерий: враг рядом, он жив и не является целью для другого	мутанта
	local enemy = nil
	if self.target == nil or self.target:is_alive () == false then enemy = self:find_enemy () end
	if enemy == nil then return 
	else
       if enemy ~= self.target then 
		  reset_action (self.npc, self.script)
		  action (self.npc, move (move.act_run, move.force_type, enemy.npc), cond (cond.time_end))
	   end	  
	end   

	--сохраняем цель
	self.target = enemy

	--если дистанция до цели меньше критической, то отиграем анимацию атаки
	if distance_between (self.npc, self.target.npc) < 2 then
       reset_action (self.npc, self.script)
	   action_first (self.npc, move (act_attack, move.default, self.target.npc), cond (cond.time_end, 1000))
	end
	
end	   

-------------------------------------------------------------------------------------------------------------------------------------
-- Все остальное
-------------------------------------------------------------------------------------------------------------------------------------


function main ()

	local scrname = m_attack_wave2.script_name ()

    local monsters = {
                      m_attack_wave2.Monster (get_level_object ("m_boar_e0000"), patrol ("way0000"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_boar_e0001"), patrol ("way0001"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_boar_e0002"), patrol ("way0002"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_boar_e0003"), patrol ("way0003"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_dog_e0000"),  patrol ("way0004"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_dog_e0001"),  patrol ("way0005"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_dog_e0002"),  patrol ("way0006"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_dog_e0003"),  patrol ("way0007"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_dog_e0004"),  patrol ("way0008"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_pseudodog_e0000"),  patrol ("way0009"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_pseudodog_e0001"),  patrol ("way0010"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_pseudodog_e0002"),  patrol ("way0011"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_pseudodog_e0003"),  patrol ("way0012"), scrname),
                      m_attack_wave2.Monster (get_level_object ("m_flesh_e0000"),  patrol ("way0013"), scrname)
					  }

	local stalkers = {
					 m_attack_wave2.Defender (get_level_object ("stalker_young"), patrol ("way_young"), scrname, monsters, true, true),
					 m_attack_wave2.Defender (get_level_object ("stalker_veteran"), patrol ("way_veteran"), scrname, monsters, true, false),
					 m_attack_wave2.Defender (get_level_object ("defender1"), patrol ("way_defender1"), scrname, monsters, true, false),
					 m_attack_wave2.Defender (get_level_object ("defender2"), patrol ("way_defender2"), scrname, monsters, true, true),
					 m_attack_wave2.Defender (get_level_object ("defender3"), patrol ("way_defender2"), scrname, monsters, true, true),
					 m_attack_wave2.Defender (get_level_object ("defender4"), nil, scrname, monsters, true, false),
					 m_attack_wave2.Defender (get_level_object ("defender5"), nil, scrname, monsters, true, false),
					 m_attack_wave2.Defender (get_level_object ("tower1"), nil, scrname, monsters, false, false),
					 m_attack_wave2.Defender (get_level_object ("tower2"), nil, scrname, monsters, false, true),
					 m_attack_wave2.Defender (get_level_object ("stalker_chief"), nil, scrname, monsters, true, true)
					 }

	for a = 1, table.getn (monsters), 1 do
		monsters[a]:set_enemyes (stalkers)
		monsters[a]:initialize ()
	    if a <= table.getn (stalkers) then
		   stalkers[a]:initialize ()
		end
	end
	

    wait (20000)


	while true do 
   		  for a = 1, table.getn (monsters), 1 do
			  monsters[a]:process ()
	          if a <= table.getn (stalkers) then
		         stalkers[a]:process ()
  		      end
		  end	
		  wait (200)
	end


end