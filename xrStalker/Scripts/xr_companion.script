----------------------------------------------------------------------------------------------------
-- Companion
----------------------------------------------------------------------------------------------------
-- Разработчик: Serhiy Vynnychenko (narrator@gsc-game.kiev.ua)
-- Доработки: Andrey Fidrya (Zmey) af@svitonline.com
----------------------------------------------------------------------------------------------------

local desired_distance = 2

local mt_stand = 0
local mt_walk = 1
local mt_run = 2
local mt_sprint = 3

----------------------------------------------------------------------------------------------------------------------
class "evaluator_need_companion" (property_evaluator)

function evaluator_need_companion:__init(storage, name) super (nil, name)
	self.st = storage
end

function evaluator_need_companion:evaluate()
	--printf("_bp: evaluator_need_companion:evaluate(): name='%s', self.st.enabled=%s",
	--	self.object:name(), utils.to_str(self.st.enabled))
	return self.st.enabled
end

----------------------------------------------------------------------------------------------------------------------
class "action_companion_activity" (action_base)

function action_companion_activity:__init(npc_name, action_name, storage) super (nil, action_name)
	self.st = storage

	self.sound_wait = {idle = 0,
		     begin = nil,
		     maxidle = 5, 
		     sumidle = 7,
   		     rnd = 80,
		     lastsound = nil,	
		     themes = {"weather", "state"}}
end

function action_companion_activity:initialize()
	--printf("_bp: action_companion_activity: initialize")
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()

	self.assist_point = nil
	
	self.move_type = mt_stand
	self.last_state = ""
end

function action_companion_activity:execute()
	action_base.execute(self)

	local actor = db.actor

	-- 1. Если мы находимся за большим радиусом - необходимо выбрать новую точку
	if self.assist_point == nil or
	   (self.object:position():distance_to(actor:position()) >= desired_distance and
	   level.vertex_position(self.assist_point):distance_to(actor:position()) >= 2*desired_distance)
	then
		self.assist_point = select_position(self.object, self.st)
		if self.assist_point == nil then
			return
		end
	end

	-- 2. Двигаемся на точку: если точка далеко - бежим, иначе идем
	self.object:set_path_type(game_object.level_path)
	self.object:set_dest_level_vertex_id(self.assist_point)

	local dist = level.vertex_position(self.assist_point):distance_to(self.object:position())
	
	printf("_bp: action_companion_activity:execute(): name='%s', dist=%s",
		self.object:name(), dist)
	
	if dist < 1 then
		self.move_type = mt_stand
	end
	if dist >= 1 and self.move_type == mt_stand then
		self.move_type = mt_walk
	end
	if dist >= 6 and
		(self.move_type == mt_stand or self.move_type == mt_walk)
	then
		self.move_type = mt_run		
	end
	if dist >= 10 and
		(self.move_type == mt_stand or self.move_type == mt_walk or
		self.move_type == mt_run)
	then
		self.move_type = mt_sprint		
	end
	
	local new_state
	if self.move_type == mt_stand then
		new_state = "guard_na"
	elseif self.move_type == mt_walk then
		new_state = "patrol"
	elseif self.move_type == mt_run then
		new_state = "rush"
	else
		new_state = "sprint"
	end
	
	if new_state and new_state ~= self.last_state then
		state_mgr.set_state(self.object, new_state,
			nil, nil, nil, { animation = true })
		self.last_state = new_state
	end 

	-- 4. Если стоим на точке - петь песенки и прочую херню
	xr_sound.sound_update(self.object, self.sound_wait) 
end

function action_companion_activity:finalize()
	--local enemy = self.object:best_enemy()
	--if enemy then
	--	xr_sound.sound_update(self.object, get_sound_for_enemy(enemy))
	--end

	action_base.finalize(self)
end

--' Выбор новой позиции
function select_position(npc, st)
	local node_1_vertex_id = nil
	local node_1_distance = nil
	local node_2_vertex_id = nil
	local node_2_distance = nil

	local actor = db.actor

	-- проверяем точку слева от актера
	desired_direction = vector_rotate_y(actor:direction(), math.random(50,60) )
	node_1_vertex_id = level.vertex_in_direction(actor:level_vertex_id(),
		desired_direction,
		desired_distance)
	if npc:accessible(node_1_vertex_id) ~= true or node_1_vertex_id == actor:level_vertex_id() then			
		node_1_vertex_id = nil
	end
	-- проверяем точку справа от актера
	desired_direction = vector_rotate_y(actor:direction(), -math.random(50,60) )
	node_2_vertex_id = level.vertex_in_direction (  actor:level_vertex_id(),
		desired_direction,
		desired_distance )
	if npc:accessible(node_2_vertex_id) ~= true or node_2_vertex_id == actor:level_vertex_id() then			
		node_2_vertex_id = nil
	end
	
	-- Проверяем растояния до точек
	if node_1_vertex_id ~= nil then
		node_1_distance = npc:position():distance_to_sqr(level.vertex_position(node_1_vertex_id))
	else
		node_1_distance = -1
	end
	if node_2_vertex_id ~= nil then
		node_2_distance = npc:position():distance_to_sqr(level.vertex_position(node_2_vertex_id))
	else
		node_2_distance = -1
	end
	
	-- Выбираем ближайшую из существующих
	if node_1_distance == -1 and node_2_distance == -1 then
		--' Не смогли найти точку, ругаться
		return nil
	end
	if node_1_distance == -1 then
		return node_2_vertex_id
	end
	if node_2_distance == -1 then
		return node_1_vertex_id
	end
	if node_1_distance < node_2_distance then
		return node_1_vertex_id
	else
		return node_2_vertex_id
	end
end

--[[
ПОТЕНЦИАЛЬНО УСТАРЕЛО
function get_sound_for_enemy(enemy)
	local otype = enemy:clsid()

	local sound = { rnd = 100, maxidle = 1, sumidle = 0}

	if 	otype == clsid.actor or
  	   	otype == clsid.soldier or
	   	otype == clsid.script_stalker or
	   	otype == clsid.trader
	then
		sound.themes = {"reac_find_enemy"}
	elseif 	otype == clsid.crow or
		otype == clsid.rat or
		otype == clsid.rat_group or
		otype == clsid.zombie or
		otype == clsid.flesh or
		otype == clsid.controller or
		otype == clsid.bloodsucker or
		otype == clsid.burer or
		otype == clsid.chimera or
		otype == clsid.boar or
		otype == clsid.flesh_group or
		otype == clsid.dog_red or
		otype == clsid.dog_black or
		otype == clsid.pseudo_gigant
	then
		sound.themes = {"reac_find_monstr"}
	end

	return sound
end
--]]

function vector_rotate_y (v, angle)
    angle = angle * 0.017453292519943295769236907684886
    local c = math.cos (angle)
    local s = math.sin (angle)
    return vector ():set (v.x * c - v.z * s, v.y, v.x * s + v.z * c)
end

----------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc)
	--printf("_bp: add_to_binder (companion)")
	local operators    = {}
	local properties  = {}

	local manager = npc:motivation_action_manager()

	properties["need_companion"]   = xr_evaluators_id.zmey_companion_base + 1
	operators["action_companion"]   = xr_actions_id.zmey_companion_base + 1

	-- // evaluators
	manager:add_evaluator (properties["need_companion"],   this.evaluator_need_companion  (db.storage[npc:id()].companion, "companion_need_companion"))

	local new_action = this.action_companion_activity(npc, "action_companion_activity", db.storage[npc:id()].companion)
	new_action:add_precondition    (world_property(stalker_ids.property_alive,   true))
	new_action:add_precondition    (world_property(stalker_ids.property_enemy,   false))
	new_action:add_precondition    (world_property(properties["need_companion"],   true))
	new_action:add_effect(world_property(properties["need_companion"], false))
	manager:add_action(operators["action_companion"], new_action)

	new_action = manager:action(xr_actions_id.alife)
	new_action:add_precondition(world_property(properties["need_companion"], false))
end

function set_scheme(object, ini, scheme, section)
	local st = xr_logic.assign_storage_and_bind(object, ini, scheme, section)

	st.enabled = false
end

function disable_scheme(npc, scheme)
	local st = db.storage[npc:id()][scheme]
	if st then
		st.enabled = false
	end
end

