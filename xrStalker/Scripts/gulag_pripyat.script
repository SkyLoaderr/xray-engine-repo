--------------------------------------------------------------------------
-- Stuff
--------------------------------------------------------------------------
function printf() end


--------------------------------------------------------------------------
-- Member counts
--------------------------------------------------------------------------
local st_snorks_count = 10
local st_tushkanos_count = 8


--------------------------------------------------------------------------
-- States
--------------------------------------------------------------------------
local state_wait  = 0
local state_wave1 = 1
local state_wave2 = 2
local state_wave3 = 3
local state_wave4 = 4
local state_wave5 = 5
local state_wave6 = 6
local state_wave7 = 7
local state_wave8 = 8

local state_zombied_guard = 0
local state_zombied_scene = 1
local state_zombied_fight = 2


--------------------------------------------------------------------------
-- Locals
--------------------------------------------------------------------------
local function obj_has_item(npc_info, item_name, def_val)
    local se_obj = npc_info.se_obj
    local t = true

    if def_val then
        t = def_val
    end

    if se_obj.online then
        local obj = level.object_by_id(se_obj.id)
        if obj then
            t = obj:object(item_name) ~= nil
        end
    end

    return t
end


--------------------------------------------------------------------------
-- General
--------------------------------------------------------------------------
local t = {}
local gulags = {pri_followers       = {comm = {"stalker"}},
                pri_wave            = {comm = true},
                pri_ambush7         = {comm = {"monolith"}},
                pri_corner          = {comm = {"monolith"}},
                pri_depot           = {comm = {"psy_dog", "pseudodog", "controller"}},
                pri_monolith        = {comm = {"monolith"}},
                pri_stadium         = {comm = {"pseudo_gigant"}}}

-- Job -------------------------------------------------------------------
function load_job(sj, gname, type, squad, groups)
    local g = gulags[type]
    if g then
        g.job(sj, gname, type, squad, groups)
    end
end

-- State -----------------------------------------------------------------
function check_state_stub(gulag)
    return 0
end

function load_states(gname, type)
    local g = gulags[type]

    if g then
        return g.state or check_state_stub
    end

    return nil
end
        
-- Dynamic ltx -----------------------------------------------------------
function load_ltx(gname, type)
    local g = gulags[type]
    if g then
        return g.ltx
    end

    return nil
end

-- Check communities -----------------------------------------------------
local function checkCommon(npc_community, gulag_type, npc_rank, se_obj, stalker)
    local g = gulags[gulag_type]
    if g then
        if g.comm then
            if type(g.comm) == "function" then
                return g.comm(npc_community, gulag_type, npc_rank, se_obj, stalker)
            end
            if type(g.comm) == "boolean" then
                return g.comm == stalker
            end

            local i, v = 0, 0
            for i, v in pairs(g.comm) do
                if npc_community == v then
                    return true
                end
            end
            if i > 0 then
                return false
            end
        end
        return true
    end
    return false
end

function checkStalker(npc_community, gulag_type, npc_rank, se_obj)
    return checkCommon(npc_community, gulag_type, npc_rank, se_obj, true)
end

function checkMonster(npc_community, gulag_type, npc_rank, se_obj)
    return checkCommon(npc_community, gulag_type, npc_rank, se_obj, false)
end


--------------------------------------------------------------------------
-- Predicates
--------------------------------------------------------------------------
function f_predicate4_1(npc_info)
    if npc_info.class_id == clsid.script_stalker or npc_info.class_id == clsid.stalker then
        local prof = npc_info.profile_name
        return prof == "pri_soldier_suicide"
    end
    return false
end


--------------------------------------------------------------------------
-- Gulags
--------------------------------------------------------------------------

--------------------------------------------------------------------------
-- Followers
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function f_predicate(npc_info)
    return npc_info.profile_name == "pri_followers"
end

function f_predicate_b(npc_info)
    local pn = npc_info.profile_name
    return (pn == "pri_followers_bomber" or pn == "pri_followers") and obj_has_item(npc_info, "wpn_rpg7")
end

-- Jobs ------------------------------------------------------------------
gulags.pri_followers.job = function(sj, gname, type, squad, groups)
    local i, v, j = 0, 0, 0
    local ltx = "[meet@ignore_abuse]\n" ..
                "use             = false\n" ..
                "use_wpn         = false\n" ..
                "abuse           = false\n" ..
                "#include \"misc\\gulag_pripyat.ltx\"\n"

    -- gulag members
    local followers = {"leader", "bomber", "nap1", "nap2", "nap3"}

    -- states name
    local states_str = {"wait", "wave1", "wave2", "wave3", "wave4", "wave5", "wave6", "wave7", "wave8"}

    -- states num
    local states = {state_wait, state_wave1, state_wave2, state_wave3, state_wave4, state_wave5, state_wave6, state_wave7, state_wave8}

    -- out restrictors for the each state
    local restr = {"",                              "pri_followers_wave1_out_restr", "pri_followers_wave2_out_restr",
                   "pri_followers_wave3_out_restr", "pri_followers_wave4_out_restr", "pri_followers_wave5_out_restr",
                   "pri_followers_wave6_out_restr", "pri_followers_wave7_out_restr", "pri_followers_wave7_out_restr"}

    -- priorities
    local prior = {{2, 2, 2, 2, 2, 2, 2, 2, 3}, -- leader
                   {3, 3, 3, 3, 3, 3, 3, 3, 2}, -- bomber
                   {1, 1, 1, 1, 1, 1, 1, 1, 1}, -- nap1
                   {1, 1, 1, 1, 1, 1, 1, 1, 1}, -- nap2
                   {1, 1, 1, 1, 1, 1, 1, 1, 1}  -- nap3
                  }
    -- predicates              f_predicate_b
    local pred = {f_predicate, f_predicate, f_predicate, f_predicate, f_predicate}

    local pr, pd
    for i, v in pairs(followers) do
        pr = prior[i]
        pd = pred[i]
        for j = 1, 9 do
            t = { section = "logic@" .. gname .. "_" .. v .. "_" .. states_str[j],
                idle = 0,
                prior = pr[j], state = { states[j] },
                squad = squad, group = groups[1],
                in_rest = "", out_rest = restr[j],
                position_threshold = 100,
                online = true,
                predicate = pd
            }
            table.insert(sj, t)
        end
    end

    for i = 1, 3 do
        local pref = gname .. "_nap" .. i
        
        for j, v in pairs({1, 2, 4, 5, 6}) do
                       --- NAP: WAVE<j> --------------------------------------------------------------------------------
            ltx = ltx.."[logic@" .. pref .. "_wave" .. v .. "]\n" ..
                       "active              = walker@" .. pref .. "_wave" .. v .. "_wait\n" ..
                       "on_hit              = followers_hit\n" ..
                       "on_death            = followers_death\n" ..

                       "[walker@" .. pref .. "_wave" .. v .. "_wait]\n" ..
                       "path_walk           = wave" .. v .. "_stalker" .. i .. "_syn_walk\n" ..
                       "path_look           = wave" .. v .. "_stalker" .. i .. "_syn_look\n" ..
                       "def_state_moving1   = assault\n" ..
                       "def_state_moving2   = assault\n" ..
                       "team                = followers\n" ..
                       "on_signal           = syn | walker@" .. pref .. "_wave" .. v .. "\n" ..
                       "on_info             = {+pri_wave" .. v .. "_start} walker@" .. pref .. "_wave" .. v .. "\n" ..
                       "danger              = danger@ignore\n" ..
                       "meet                = meet@ignore_abuse\n" .. --meet@def

                       "[walker@" .. pref .. "_wave" .. v .. "]\n" ..
                       "path_walk           = wave" .. v .. "_stalker" .. i .. "_walk\n" ..
                       "path_look           = wave" .. v .. "_stalker" .. i .. "_look\n" ..
                       "def_state_moving1   = assault\n" ..
                       "def_state_moving2   = assault\n" ..
                       "on_signal           = arrived | {-pri_wave" .. v .. "_start} %+pri_wave" .. v .. "_start%\n" ..
                       "meet                = meet@ignore_abuse\n" --meet@def
        end
        
                   --- NAP: KAMP ----------------------------------------------------------------------------------
        ltx = ltx.."[logic@" .. pref .. "_wait]\n" ..
                   "active              = remark@" .. pref .. "_wait\n" ..
                   --"combat_ignore       = combat_ignore\n" ..
                   "on_hit              = followers_hit\n" ..
                   "on_death            = followers_death\n" ..

                   "[remark@" .. pref .. "_wait]\n" ..
                   "path_walk           = wait_stalker" .. i .. "_walk\n" ..
                   "anim                = wait\n" ..
                   "target              = logic@pri_followers_leader_wait\n" ..
                   "meet                = meet@ignore_abuse\n" .. --meet@def
                   "danger              = danger@ignore\n" ..
                   --"combat_ignore_cond  = always\n" ..

--[[
                   "[walker@" .. pref .. "_wait]\n" ..
                   "path_walk           = wait_stalker" .. i .. "_walk\n" ..
                   "path_look           = wait_stalker" .. i .. "_look\n" ..
                   "def_state_moving1   = assault\n" ..
                   "def_state_moving2   = assault\n" ..
                   "def_state_moving3   = assault\n" ..
                   "meet                = meet@def\n" ..
                   "danger              = danger@ignore\n" ..
                   --"combat_ignore_cond  = always\n" ..
--]]
                   --- NAP: WAVE3 --------------------------------------------------------------------------------
                   "[logic@" .. pref .. "_wave3]\n" ..
                   "active              = walker@" .. pref .. "_wave3_wait\n" ..
                   "combat_ignore       = combat_ignore\n" ..
                   "on_hit              = followers_hit\n" ..
                   "on_death            = followers_death\n" ..

                   "[walker@" .. pref .. "_wave3_wait]\n" ..
                   "path_walk           = wave3_stalker" .. i .. "_syn_walk\n" ..
                   "path_look           = wave3_stalker" .. i .. "_syn_look\n" ..
                   "def_state_moving1   = assault\n" ..
                   "def_state_moving2   = assault\n" ..
                   "team                = followers\n" ..
                   "on_signal           = syn | walker@" .. pref .. "_wave3 %+pri_wave3_start%\n" ..
                   "on_info             = {+pri_wave3_start} walker@" .. pref .. "_wave3\n" ..
                   "meet                = meet@ignore_abuse\n" .. --meet@def
                   "danger              = danger@ignore\n" ..
                   "combat_ignore_cond  = {!fighting_actor}\n" ..

                   "[walker@" .. pref .. "_wave3]\n" ..
                   "path_walk           = wave3_stalker" .. i .. "_walk\n" ..
                   "path_look           = wave3_stalker" .. i .. "_look\n" ..
                   "def_state_moving1   = assault ;sprint\n" ..
                   "def_state_moving2   = assault ;sprint\n" ..
                   "on_timer            = " .. math.random(30, 40) .. "00 | remark@" .. pref .. "_wave3_fight\n" .. -- 30
                   "meet                = meet@ignore_abuse\n" .. --meet@def
                   "danger              = danger@ignore\n" ..
                   "combat_ignore_cond  = {!fighting_actor}\n" ..

                   "[remark@" .. pref .. "_wave3_fight]\n" ..
                   "anim                = threat_fire\n" ..
                   "target              = 807\n" ..
                   "on_timer            = " .. math.random(47, 55) .. "00 | walker@" .. pref .. "_wave3\n" .. -- 50
                   "meet                = meet@ignore_abuse\n" .. --meet@def
                   "danger              = danger@ignore\n" ..
                   "combat_ignore_cond  = {!fighting_actor}\n" ..

                   --- NAP: WAVE7 ------------------------------------------------------------------------------
                   "[logic@" .. pref .. "_wave7]\n" ..
                   "active              = walker@" .. pref .. "_wave7_wait\n" ..
                   --"combat_ignore       = combat_ignore\n" ..
                   "on_hit              = followers_hit\n" ..
                   "on_death            = followers_death\n" ..

                   "[walker@" .. pref .. "_wave7_wait]\n" ..
                   "path_walk           = wave7_stalker" .. i .. "_syn_walk\n" ..
                   "path_look           = wave7_stalker" .. i .. "_syn_look\n" ..
                   "def_state_moving1   = assault\n" ..
                   "def_state_moving2   = assault\n" ..
                   "team                = followers\n" ..
                   "on_info             = {+pri_wave7_leader_phrase_end} walker@" .. pref .. "_wave7\n" ..
                   "meet                = meet@ignore_abuse\n" .. --meet@def
                   "danger              = danger@ignore\n" ..

                   "[walker@" .. pref .. "_wave7]\n" ..
                   "path_walk           = wave7_stalker" .. i .. "_walk\n" ..
                   "path_look           = wave7_stalker" .. i .. "_look\n" ..
                   "def_state_moving1   = assault\n" ..
                   "def_state_moving2   = assault\n" ..
                   "on_signal           = arrived | {-pri_wave7_start} %+pri_wave7_start%\n" ..
                   "meet                = meet@ignore_abuse\n" .. --meet@def
                   "danger              = danger@ignore\n" ..
                   --"combat_ignore_cond  = {-pri_wave7_start}\n" ..

                   --- NAP: WAVE8 ------------------------------------------------------------------------------
                   "[logic@" .. pref .. "_wave8]\n" ..
                   "active              = walker@" .. pref .. "_wave8_wait\n" ..
                   "on_hit              = followers_hit\n" ..
                   "on_death            = followers_death\n" ..

                   "[walker@" .. pref .. "_wave8_wait]\n" ..
                   "path_walk           = wave8_stalker" .. i .. "_walk\n" ..
                   "path_look           = wave8_stalker" .. i .. "_look\n" ..
                   "def_state_moving1   = assault\n" ..
                   "def_state_moving2   = assault\n" ..
                   "meet                = meet@ignore_abuse\n" --meet@def
    end

    gulags.pri_followers.ltx = ltx
end

-- States ----------------------------------------------------------------
local pri_followers_switcher = {}
pri_followers_switcher[state_wait] = function(actor, delta_time)
    if actor:has_info("pri_followers_start") then
        return state_wave1
    end
    return state_wait
end
pri_followers_switcher[state_wave1] = function(actor, delta_time)
    if delta_time > 3000 or -- 5 min
        (actor:has_info("pri_wave1_monolith1_dead") and
        actor:has_info("pri_wave1_monolith2_dead") and
        actor:has_info("pri_wave1_monolith3_dead"))
    then
        actor:give_info_portion("pri_wave1_end")
        return state_wave2
    end
    return state_wave1
end
pri_followers_switcher[state_wave2] = function(actor, delta_time)
    if delta_time > 2400 or -- 4 min
        (actor:has_info("pri_wave2_monolith1_dead") and
        actor:has_info("pri_wave2_monolith2_dead") and
        actor:has_info("pri_wave2_monolith3_dead") and
        actor:has_info("pri_wave2_monolith4_dead"))
    then
        actor:give_info_portion("pri_wave2_end")
        return state_wave4 --3
    end
    return state_wave2
end
pri_followers_switcher[state_wave3] = function(actor, delta_time)
    if actor:has_info("pri_wave3_btr_dead") then
        actor:give_info_portion("pri_wave3_end")
        return state_wave4
    end
    return state_wave3
end
pri_followers_switcher[state_wave4] = function(actor, delta_time)
    if delta_time > 2400 or -- 4 min
        (actor:has_info("pri_wave4_monolith1_dead") and
        actor:has_info("pri_wave4_monolith2_dead") and
        actor:has_info("pri_wave4_monolith3_dead") and
        actor:has_info("pri_wave4_monolith4_dead") and
        actor:has_info("pri_wave4_monolith5_dead")) --and
        --actor:has_info("pri_wave4_monolith6_dead") and
        --actor:has_info("pri_wave4_monolith7_dead") and
        --actor:has_info("pri_wave4_monolith8_dead")
    then
        actor:give_info_portion("pri_wave4_end")
        return state_wave5
    end
    return state_wave4
end
pri_followers_switcher[state_wave5] = function(actor, delta_time)
    if actor:has_info("pri_wave5_monolith1_dead") and
        actor:has_info("pri_wave5_monolith2_dead") and
        actor:has_info("pri_wave5_monolith3_dead") and
        actor:has_info("pri_wave5_monolith4_dead")
    then
        actor:give_info_portion("pri_wave5_end")
        return state_wave6
    end
    return state_wave5
end
pri_followers_switcher[state_wave6] = function(actor, delta_time)
    if actor:has_info("pri_wave6_monolith1_dead") and
        actor:has_info("pri_wave6_monolith2_dead") --and
        --actor:has_info("pri_wave6_monolith3_dead")
    then
        actor:give_info_portion("pri_wave6_end")
        return state_wave7
    end
    return state_wave6
end
pri_followers_switcher[state_wave7] = function(actor, delta_time)
    if xr_gulag.getGulagPopulation("pri_ambush7") < 2
    then
        actor:give_info_portion("pri_undeground_respawn_start")
        actor:give_info_portion("pri_wave7_end")
        return state_wave8
    end
    return state_wave7
end
pri_followers_switcher[state_wave8] = function(actor, delta_time)
    return state_wave8
end

gulags.pri_followers.state = function(gulag)
    local state = gulag.state
    local actor = db.actor

    if actor:has_info("pri_followers_mission_accept") and actor:dont_has_info("pri_followers_actor_leave") then
        -- check min distance to actor
        local actor_leave = true
        local npc_id, npc = 0, 0
	    for npc_id, npc in pairs(gulag.Object) do
		    if npc ~= true and level.object_by_id(npc_id) ~= nil then
			    if npc:position():distance_to_sqr(actor:position()) <= 3600 then -- 60*60
			        actor_leave = false
			        break
			    end
		    end
	    end
	    if actor_leave then
	        actor:give_info_portion("pri_followers_actor_leave")
	    end
	end

    return pri_followers_switcher[state](actor, game.get_game_time():diffSec(gulag.stateBegin))
end


--------------------------------------------------------------------------
-- Ambush7
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------

-- Jobs ------------------------------------------------------------------
gulags.pri_ambush7.job = function(sj, gname, type, squad, groups)
    local i, ltx = 0, ""
    for i = 1, 7 do
        --- state 0
        t = { section = "logic@" .. gname .. "_monolith" .. i .. "_hide", 
            idle = 0,
            prior = 1, state = {0}, squad = squad, group = groups[1],
            in_rest = "", out_rest = gname .. "_out_restr"
        }
        table.insert(sj, t)
        --- state 1
        t = { section = "logic@" .. gname .. "_monolith" .. i, 
            idle = 0,
            prior = 1, state = {1}, squad = squad, group = groups[1],
            in_rest = "", out_rest = gname .. "_out_restr"
        }
        table.insert(sj, t)

        ltx = ltx.."[logic@" .. gname .. "_monolith" .. i .. "_hide]\n" ..
                   "active              = walker@" .. gname .. "_monolith" .. i .. "_hide\n" ..
                   "combat_ignore       = combat_ignore\n" ..

                   "[walker@" .. gname .. "_monolith" .. i .. "_hide]\n" ..
                   "path_walk           = monolith" .. i .. "_hide_walk\n" ..
                   "path_look           = monolith" .. i .. "_hide_look\n" ..
                   "combat_ignore_cond  = always\n" ..
                   "show_spot           = false\n" ..

                   "[logic@" .. gname .. "_monolith" .. i .. "]\n" ..
                   "active              = walker@" .. gname .. "_monolith" .. i .. "\n" ..

                   "[walker@" .. gname .. "_monolith" .. i .. "]\n" ..
                   "path_walk           = monolith" .. i .. "_walk\n" ..
                   "path_look           = monolith" .. i .. "_look\n" --..
                   --"show_spot           = false\n"
    end

    gulags.pri_ambush7.ltx = ltx
end

-- States ----------------------------------------------------------------
gulags.pri_ambush7.state = function(gulag)
    if db.actor:has_info("pri_wave7_start") then
        return 1
    else
        return 0
    end
end


--------------------------------------------------------------------------
-- Wave
--------------------------------------------------------------------------
-- Additional functions --------------------------------------------------
local function process_range(str, def_val_min, def_val_max)
    local v = {}
    if str then v = parse_nums(str) end
    local min = v[1] or def_val_min or 5
    local max = v[2] or def_val_max or 10
    
    if min > max then
        max = min --* 1.5
    end
    return math.random(min, max) --random_number(min, max)
end

local function process_num(str, def_val)
    if str ~= nil then
        return tonumber(str) or def_val
    end
    return def_val
end

-- Predicates ------------------------------------------------------------
function w_predicate_sn(npc_info)
    return npc_info.is_sniper == true
end

-- Jobs ------------------------------------------------------------------
gulags.pri_wave.job = function(sj, gname, type, squad, groups)
    local i, ltx = 1, ""
    local ib_cond = "combat_ignore_cond = {=check_fighting(806)}\n"

    ltx = "[wounded]\n" ..
          "hp_state = 0|help_me@help\n" ..
          "hp_state_see = 0|wounded@help_see\n" ..
          "hp_victim = 0|nil\n" ..
          "hp_fight = 0|false\n" ..
          "hp_cover = 0|false\n" ..

          "[danger1]\n" ..
          --"ignore_distance = 10\n" ..
          --"danger_inertion_time_hit = 1000\n" ..
          --"danger_inertion_time_sound = 500\n" ..
          --"danger_inertion_time_ricochet = 1000\n" ..
          "ignore_types = corpse\n" ..

          "[danger2]\n" ..
          --"ignore_distance = 20\n" ..
          --"danger_inertion_time_hit = 1000\n" ..
          --"danger_inertion_time_sound = 1500\n" ..
          --"danger_inertion_time_ricochet = 1000\n" ..
          "ignore_types = corpse\n"

    -- Снайперы в окнах.
    i = 1
    while level.patrol_path_exists(gname .. "_wsniper_" .. i .."_walk") do
        -- Необходимо вычитать количество работ из названия точки пути.
        local idstr = gname .. "_wsniper_" .. i
        local way_name = idstr .."_walk"
        local ptr = patrol(way_name)
        local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))

        local stime = process_range(wp_prop.stime, 15, 25) * 1000 -- sniper time in seconds
        local gtime = process_range(wp_prop.gtime, 15, 20) * 1000 -- guard time in seconds
        local htime = process_range(wp_prop.htime,  6,  8) * 1000 -- hide time in seconds

        local sdist = process_num(wp_prop.sdist, 50) -- sniper distance
        local gdist = process_num(wp_prop.gdist, 40) -- guard distance
        if gdist >= sdist then
            gdist = sdist + 5
        end

        local outr = wp_prop.outr or "" -- out restrictors
        local inr = wp_prop.inr or "" -- in restrictors

        local starti = wp_prop.starti -- start infoportion
        local deathi = wp_prop.deathi -- death infoportion

        local ib = ""
        if wp_prop.ib then -- ignore bomber
            ib = ib_cond
        end

        -- добавляем должность
        t = { section = "logic@" .. idstr,
            idle = 0,
            prior = 1, state = {0}, squad = squad, group = groups[1],
            in_rest = inr, out_rest = outr --,
            --predicate = w_predicate_sn
        }
        table.insert(sj, t)

        -- добавляем описание должности в лтх.
        ltx = ltx.."[logic@" .. idstr .. "]\n" ..
                   "combat_ignore = combat_ignore\n"
        
        if starti then
            ltx = ltx.."active = remark@" .. idstr .. "_wait\n"

            if deathi then
                ltx = ltx.."on_death = death@" .. idstr .. "\n" ..

                           "[death@" .. idstr .. "]\n" ..                            
                           "on_info = %+" .. deathi .. "%\n"
            end

            ltx = ltx.."[remark@" .. idstr .. "_wait]\n" ..                            
                       "path_walk           = wsniper_" .. i .. "_wait_walk\n" ..
                       "anim                = hide_na\n" ..
                       "show_spot           = false\n" ..
                       "on_info             = {+" .. starti .. "} camper@" .. idstr .. "\n" ..
                       "wounded             = wounded\n" ..
                       --"danger              = danger1\n" ..
                       "combat_ignore_cond  = always\n"
        else
            ltx = ltx.."active = camper@" .. idstr .. "\n"
        end

        ltx = ltx.."[camper@" .. idstr .. "]\n" ..                            
                   "path_walk                   = wsniper_" .. i .. "_walk\n" ..
                   "path_look                   = wsniper_" .. i .. "_look\n" ..
                   "def_state_moving            = sneak_run ;assault\n" ..
                   "def_state_campering         = threat\n" ..
                   "def_state_campering_fire    = threat_sniper_fire\n" ..
                   "sniper                      = true\n" ..
                   "radius                      = 0\n" ..
                   --"show_spot                   = false\n" ..
                   --"on_info                     = {=dist_to_enemy_le(" .. gdist .. ")} camper@" .. idstr .. "_guard\n" ..
                   --"on_actor_dist_le_nvis       = " .. gdist .. " | remark@" .. idstr .. "_hide\n" .. --camper@" .. idstr .. "_guard\n" ..
                   "on_timer                    = " .. stime .. " | camper@" .. idstr .. "_hide\n" ..
                   "wounded                     = wounded\n" ..
                   "danger                      = danger1\n" ..
                   ib ..

                   "[camper@" .. idstr .. "_guard]\n" ..                            
                   "path_walk                   = wsniper_" .. i .. "_walk\n" ..
                   "path_look                   = wsniper_" .. i .. "_look\n" ..
                   "def_state_moving            = sneak_run ;assault\n" ..
                   "def_state_campering         = threat\n" ..
                   "def_state_campering_fire    = threat_fire\n" ..
                   "no_retreat                  = true\n" ..
                   "radius                      = 0\n" ..
                   --"show_spot                   = false\n" ..
                   --"on_info                     = {!dist_to_enemy_le(" .. sdist .. ")} camper@" .. idstr .. "\n" ..
                   --"on_actor_dist_ge_nvis       = " .. sdist .. " | remark@" .. idstr .. "_hide\n" .. --camper@" .. idstr .. "\n" ..
                   "on_timer                    = " .. gtime .. " | camper@" .. idstr .. "_hide\n" ..
                   "wounded                     = wounded\n" ..
                   "danger                      = danger1\n" ..
                   ib ..

                   --"[remark@" .. idstr .. "_hide]\n" ..                            
                   --"anim                = hide\n" ..
                   --"target              = actor\n" ..
                   "[camper@" .. idstr .. "_hide]\n" ..                            
                   "path_walk           = wsniper_" .. i .. "_walk\n" ..
                   "path_look           = wsniper_" .. i .. "_look\n" ..
                   "def_state_moving    = sneak_run\n" ..
                   "def_state_campering = hide_na\n" ..
                   "no_retreat          = true\n" ..
                   "radius              = 0\n" ..
                   "show_spot           = false\n" ..
                   --"on_timer            = " .. htime .. " | {=dist_to_actor_ge(" .. sdist .. ")} camper@" .. idstr .. ", camper@" .. idstr .. "_guard\n" ..
                   "on_timer            = " .. htime .. " | {=dist_to_enemy_ge(" .. sdist .. ")} camper@" .. idstr .. ", camper@" .. idstr .. "_guard\n" ..
                   "wounded             = wounded\n" ..
                   "danger              = danger1\n" ..
                   "combat_ignore_cond  = always\n"
        i = i + 1
    end

    -- Снайперы на крышах.
    i = 1
    while level.patrol_path_exists(gname .. "_rsniper_" .. i .."_walk") do
        -- Необходимо вычитать количество работ из названия точки пути.
        local idstr = gname .. "_rsniper_" .. i
        local way_name = idstr .."_walk"
        local ptr = patrol(way_name)
        local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))

        local sdist = process_num(wp_prop.sdist, 50) -- sniper distance
        local gdist = process_num(wp_prop.gdist, 40) -- guard distance
        if gdist >= sdist then
            gdist = sdist + 5
        end

        local outr = wp_prop.outr or "" -- out restrictors
        local inr = wp_prop.inr or "" -- in restrictors

        local starti = wp_prop.starti -- start infoportion
        local deathi = wp_prop.deathi -- death infoportion

        local ib = ""
        if wp_prop.ib then -- ignore bomber
            ib = ib_cond
        end

        -- добавляем должность
        t = { section = "logic@" .. idstr,
            idle = 0,
            prior = 1, state = {0}, squad = squad, group = groups[1],
            in_rest = inr, out_rest = outr --,
            --predicate = w_predicate_sn
        }
        table.insert(sj, t)

        -- добавляем описание должности в лтх.
        ltx = ltx.."[logic@" .. idstr .. "]\n" ..
                   "combat_ignore = combat_ignore\n"
        
        if starti then
            ltx = ltx.."active = remark@" .. idstr .. "_wait\n"

            if deathi then
                ltx = ltx.."on_death = death@" .. idstr .. "\n" ..

                           "[death@" .. idstr .. "]\n" ..                            
                           "on_info = %+" .. deathi .. "%\n"
            end

            ltx = ltx.."[remark@" .. idstr .. "_wait]\n" ..                            
                       "path_walk           = rsniper_" .. i .. "_wait_walk\n" ..
                       --"path_look           = rsniper_" .. i .. "_look\n" ..
                       "anim                = hide_na\n" ..
                       "show_spot           = false\n" ..
                       "on_info             = {+" .. starti .. "} camper@" .. idstr .. "\n" ..
                       "wounded             = wounded\n" ..
                       --"danger              = danger1\n" ..
                       "combat_ignore_cond  = always\n"
        else
            ltx = ltx.."active = camper@" .. idstr .. "\n"
        end

        ltx = ltx.."[camper@" .. idstr .. "]\n" ..                            
                   "path_walk                   = rsniper_" .. i .. "_walk\n" ..
                   "path_look                   = rsniper_" .. i .. "_look\n" ..
                   "def_state_moving            = assault\n" ..
                   "def_state_campering         = hide_na\n" ..
                   "def_state_campering_fire    = hide_sniper_fire\n" ..
                   "sniper                      = true\n" ..
                   "radius                      = 0\n" ..
                   --"show_spot                   = false\n" ..
                   --"on_info                     = {=dist_to_enemy_le(" .. gdist .. ")} camper@" .. idstr .. "_guard\n" ..
                   "on_actor_dist_le_nvis       = " .. gdist .. " | camper@" .. idstr .. "_guard\n" ..
                   "wounded                     = wounded\n" ..
                   "danger                      = danger1\n" ..
                   ib ..

                   "[camper@" .. idstr .. "_guard]\n" ..                            
                   "path_walk                   = rsniper_" .. i .. "_walk\n" ..
                   "path_look                   = rsniper_" .. i .. "_look\n" ..
                   "def_state_moving            = assault\n" ..
                   "def_state_campering         = hide_na\n" ..
                   "def_state_campering_fire    = hide_fire\n" ..
                   "no_retreat                  = true\n" ..
                   "radius                      = 0\n" ..
                   --"show_spot                   = false\n" ..
                   --"on_info                     = {!dist_to_enemy_le(" .. sdist .. ")} camper@" .. idstr .. "\n" ..
                   "on_actor_dist_ge_nvis       = " .. sdist .. " | camper@" .. idstr .. "\n" ..
                   "wounded                     = wounded\n" ..
                   "danger                      = danger1\n" ..
                   ib
        i = i + 1
    end

    -- Свободные волкеры в кемпах.
    i = 1
    while level.patrol_path_exists(gname .. "_free_" .. i .."_walk") do
        -- Необходимо вычитать количество работ из названия точки пути.
        local idstr = gname .. "_free_" .. i
        local way_name = idstr .."_walk"
        local ptr = patrol(way_name)
        local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))

        local wtime = process_range(wp_prop.wtime, 40,  80) * 1000 -- walker state time in seconds
        local ktime = process_range(wp_prop.ktime, 90, 180) * 1000 -- kamp state time in seconds

        local kampi = process_num(wp_prop.kampi, 1) -- kamp index

        local outr = wp_prop.outr or "" -- out restrictors
        local inr = wp_prop.inr or "" -- in restrictors

        local starti = wp_prop.starti -- start infoportion
        local deathi = wp_prop.deathi -- death infoportion

        local ib = ""
        if wp_prop.ib then -- ignore bomber
            ib = ib_cond
        end

        -- добавляем должность
        t = { section = "logic@" .. idstr,
            idle = 0,
            prior = 1, state = {0}, squad = squad, group = groups[1],
            in_rest = inr, out_rest = outr
        }
        table.insert(sj, t)

        -- добавляем описание должности в лтх.
        ltx = ltx.."[logic@" .. idstr .. "]\n" ..
                   "combat_ignore = combat_ignore\n"
        
        if starti then
            ltx = ltx.."active = remark@" .. idstr .. "_wait\n"

            if deathi then
                ltx = ltx.."on_death = death@" .. idstr .. "\n" ..

                           "[death@" .. idstr .. "]\n" ..                            
                           "on_info = %+" .. deathi .. "%\n"
            end

            ltx = ltx.."[remark@" .. idstr .. "_wait]\n" ..                            
                       "path_walk           = free_" .. i .. "_wait_walk\n" ..
                       "anim                = hide_na\n" ..
                       --"show_spot           = false\n" ..
                       "on_info             = {+" .. starti .. "} walker@" .. idstr .. "\n" ..
                       "wounded             = wounded\n" ..
                       --"danger              = danger2\n" ..
                       "combat_ignore_cond  = always\n"
        else
            ltx = ltx.."active = walker@" .. idstr .. "\n"
        end

        ltx = ltx.."[walker@" .. idstr .. "]\n" ..                            
                   "path_walk                   = free_" .. i .. "_walk\n" ..
                   "path_look                   = free_" .. i .. "_look\n" ..
                   "def_state_moving1           = patrol\n" ..
                   "def_state_moving2           = assault\n" ..
                   "def_state_moving3           = assault\n" ..
                   --"show_spot                   = false\n" ..
                   "on_timer                    = " .. wtime .. " | kamp@" .. idstr .. "\n" ..
                   "wounded                     = wounded\n" ..
                   --"danger                      = danger2\n" ..
                   ib ..

                   "[kamp@" .. idstr .. "]\n" ..                            
                   "center_point        = kamp_" .. kampi .. "\n" ..
                   "def_state_moving    = patrol\n" ..
                   --"show_spot           = false\n" ..
                   "on_timer            = " .. ktime .. " | walker@" .. idstr .. "\n" ..
                   "wounded             = wounded\n" ..
                   "danger              = danger2\n"
        i = i + 1
    end

    gulags.pri_wave.ltx = ltx
    --printf("gulag <pri_wave>: %s.\nLTX:\n%s", gname, ltx)
end


--------------------------------------------------------------------------
-- Corners
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------

-- Jobs ------------------------------------------------------------------
gulags.pri_corner.job = function(sj, gname, type, squad, groups)
    local ltx, i = "", 0

    for i = 1, 3 do
        t = { section = "logic@" .. gname .. "_monolith" .. i , 
            idle = 0,
            prior = 1, state = {0}, squad = squad, group = groups[1],
            in_rest = "", out_rest = ""
        }
        table.insert(sj, t)

        ltx = ltx.."[logic@" .. gname .. "_monolith" .. i .. "]\n" ..
                   "active              = camper@" .. gname .. "_monolith" .. i .. "_guard\n" ..
                   "combat_ignore       = combat_ignore\n" ..

                   "[camper@" .. gname .. "_monolith" .. i .. "_guard]\n" ..
                   "path_walk           = guard_" .. i .. "_walk\n" ..
                   "path_look           = guard_" .. i .. "_look\n" ..
                   "radius              = 20\n" ..
                   "on_info             = {+pri_corner_start} patrol@" .. gname .. "_monolith_raid\n" ..
                   "combat_ignore_cond  = always\n"
    end

    gulags.pri_corner.ltx = ltx.."[patrol@" .. gname .. "_monolith_raid]\n" ..
                                 "path_walk = raid_walk\n" ..
                                 "path_look = raid_look\n" ..
                                 "on_signal = arrived | %+pri_corner_end%\n" 
end


--------------------------------------------------------------------------
-- Depot
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function z_predicate_c(npc_info)
    return npc_info.community == "controller"
end

function z_predicate_pd(npc_info)
    local c = npc_info.community
    return c == "psy_dog" or c == "pseudodog"
end

-- Jobs ------------------------------------------------------------------
gulags.pri_depot.job = function(sj, gname, type, squad, groups)
    local i = 0
    local ltx = ""

    local way_name = gname .."_controllers_home"
    local ptr = patrol(way_name)
    local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
    local count = process_num(wp_prop.count, 3) -- controllers number
        
    for i = 1, count do
        t = { section = "logic@" .. gname .. "_controller", 
            idle = 0,
            prior = 1, state = {0},
            squad = squad, group = groups[1],
            in_rest = "", out_rest = gname .. "_base_restr",
            predicate = z_predicate_c
        }
        table.insert(sj, t)
    end

    way_name = gname .."_psydogs_home"
    ptr = patrol(way_name)
    wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
    count = process_num(wp_prop.count, 9) -- psydogs number
        
    for i = 1, count do
        t = { section = "logic@" .. gname .. "_psydog", 
            idle = 0,
            prior = 1, state = {0},
            squad = squad, group = groups[2],
            in_rest = gname .. "_base_restr", out_rest = "",
            predicate = z_predicate_pd
        }
        table.insert(sj, t)
    end

    ltx = "[logic@" .. gname .. "_controller]\n" ..
          "active     = mob_home@" .. gname .. "_controller\n" ..

          "[mob_home@" .. gname .. "_controller]\n" ..
          "path_home    = controllers_home\n" ..
          "aggressive_home\n" ..

          "[logic@" .. gname .. "_psydog]\n" ..
          "active     = mob_home@" .. gname .. "_psydog\n" ..

          "[mob_home@" .. gname .. "_psydog]\n" ..
          "path_home    = psydogs_home\n" ..
          "aggressive_home\n"

    gulags.pri_depot.ltx = ltx
end


--------------------------------------------------------------------------
-- Monolith
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function m_predicate_l(npc_info)
    return npc_info.story_id == 828
end

function m_predicate_r(npc_info)
    return npc_info.profile_name == "pri_monolith_regular"
end

function m_predicate_s(npc_info)
    return npc_info.profile_name == "pri_monolith_specnaz"
end

function m_predicate_e(npc_info)
    return npc_info.profile_name == "pri_monolith_exo"
end

function m_predicate_s_rpg(npc_info)
    return npc_info.profile_name == "pri_monolith_specnaz" and obj_has_item(npc_info, "wpn_rpg7")
end

--function m_predicate_s_svd(npc_info)
--    return npc_info.profile_name == "pri_monolith_specnaz" and obj_has_item(npc_info, "wpn_svd")
--end

function m_predicate_s_sniper(npc_info)
    return npc_info.profile_name == "pri_monolith_specnaz" and npc_info.is_sniper == true
end

function m_predicate_e_rpg(npc_info)
    return npc_info.profile_name == "pri_monolith_exo" and obj_has_item(npc_info, "wpn_rpg7")
end

-- Jobs ------------------------------------------------------------------
gulags.pri_monolith.job = function(sj, gname, type, squad, groups)
    local i, j, v = 0, 0, 0
    local prior, pred = 0, 0
    local state1_kamp, state2_kamp = 0, 0
    local state1_restr, state2_restr = 0, 0
    local ltx = ""
    local in_r = "pri_snork_nest2_big_restr" --pri_snork_nest1_big_restr

    ltx = "[danger@monolith]\n" ..
          "ignore_distance_sound = 150\n" ..

          "[logic@" .. gname .. "_fight_in_base1]\n" ..
          "active              = kamp@" .. gname .. "_fight_in_base1\n" ..
          "combat_ignore       = combat_ignore\n" ..

          "[kamp@" .. gname .. "_fight_in_base1]\n" ..
          "center_point        = kamp1\n" ..
          "def_state_moving    = assault\n" ..
          "danger              = danger@monolith\n" ..
          "combat_ignore_cond  = {=pri_monolith_combat_ignore}\n" ..

          "[logic@" .. gname .. "_fight_in_base2]\n" ..
          "active              = kamp@" .. gname .. "_fight_in_base2\n" ..
          "combat_ignore       = combat_ignore\n" ..

          "[kamp@" .. gname .. "_fight_in_base2]\n" ..
          "center_point        = kamp2\n" ..
          "def_state_moving    = assault\n" ..
          "danger              = danger@monolith\n" ..
          "combat_ignore_cond  = {=pri_monolith_combat_ignore}\n" ..

          "[logic@" .. gname .. "_fight_in_base3]\n" ..
          "active              = kamp@" .. gname .. "_fight_in_base3\n" ..
          "combat_ignore       = combat_ignore\n" ..

          "[kamp@" .. gname .. "_fight_in_base3]\n" ..
          "center_point        = kamp5\n" ..
          "def_state_moving    = assault\n" ..
          "danger              = danger@monolith\n" ..
          "combat_ignore_cond  = {=pri_monolith_combat_ignore}\n" ..

          "[logic@" .. gname .. "_fight_in_base4]\n" ..
          "active              = kamp@" .. gname .. "_fight_in_base4\n" ..
          "combat_ignore       = combat_ignore\n" ..

          "[kamp@" .. gname .. "_fight_in_base4]\n" ..
          "center_point        = kamp7\n" ..
          "def_state_moving    = assault\n" ..
          "danger              = danger@monolith\n" ..
          "combat_ignore_cond  = {=pri_monolith_combat_ignore}\n" ..

          "[logic@" .. gname .. "_fight_in_hotel]\n" ..
          "active              = kamp@" .. gname .. "_fight_in_hotel\n" ..
          "combat_ignore       = combat_ignore\n" ..

          "[kamp@" .. gname .. "_fight_in_hotel]\n" ..
          "center_point        = kamp6\n" ..
          "def_state_moving    = assault\n" ..
          "danger              = danger@monolith\n" ..
          "combat_ignore_cond  = {=pri_monolith_combat_ignore}\n" ..

          "[logic@" .. gname .. "_fight_in_kolos]\n" ..
          "active              = kamp@" .. gname .. "_fight_in_kolos\n" ..
          "combat_ignore       = combat_ignore\n" ..

          "[kamp@" .. gname .. "_fight_in_kolos]\n" ..
          "center_point        = kamp4\n" ..
          "def_state_moving    = assault\n" ..
          "danger              = danger@monolith\n" ..
          "combat_ignore_cond  = {=pri_monolith_combat_ignore}\n"

    -- leader
    t = { section = "logic@" .. gname .. "_leader", 
        idle = 0,
        prior = 15, state = {0},
        squad = squad, group = groups[1],
        in_rest = in_r, out_rest = "", --gname .. "_leader_restr"
        predicate = m_predicate_l
    } table.insert(sj, t)
    ltx = ltx.."[logic@" .. gname .. "_leader]\n" ..
               "active              = walker@" .. gname .. "_leader\n" ..
               "combat_ignore       = combat_ignore\n" ..
               "on_death            = death@" .. gname .. "_leader\n" ..

               "[death@" .. gname .. "_leader]\n" ..
               "on_info             = %+sar2_death_55%\n" ..

               "[walker@" .. gname .. "_leader]\n" ..
               "path_walk           = leader_walk\n" ..
               "path_look           = leader_look\n" ..
               "danger              = danger@monolith\n" ..
               --"show_spot           = false\n" ..
               "combat_ignore_cond  = {=pri_monolith_combat_ignore}\n"

    t = { section = "logic@" .. gname .. "_fight_in_base3", 
        idle = 0,
        prior = 15, state = {1,2},
        squad = squad, group = groups[1],
        in_rest = "", out_rest = gname .. "_base_restr",
        predicate = m_predicate_l
    } table.insert(sj, t)

    -- walkers
    prior = {6, 7, 8, 12, 12, 5}
    state1_kamp  = {"_fight_in_hotel", "_fight_in_base1", "_fight_in_base3", "_fight_in_base2", "_fight_in_base2", "_fight_in_hotel"}
    state1_restr = {"_hotel_restr",    "_base_restr",     "_base_restr",     "_base_restr",     "_base_restr",     "_hotel_restr"}
    state2_kamp  = {"_fight_in_base4", "_fight_in_base3", "_fight_in_base2", "_fight_in_base1", "_fight_in_base1", "_fight_in_base3"}
    state2_restr = {"_base_restr",     "_base_restr",     "_base_restr",     "_base_restr",     "_base_restr",     "_base_restr"}
    for i, v in pairs({1, 3, 4, 5, 6, 8}) do
        --- state: main
        t = { section = "logic@" .. gname .. "_patrol" .. v, 
            idle = 0,
            prior = prior[i], state = {0},
            squad = squad, group = groups[6],
            in_rest = in_r, out_rest = "",
            predicate = m_predicate_s
        } table.insert(sj, t)
        ltx = ltx.."[logic@" .. gname .. "_patrol" .. v .. "]\n" ..
                   "active              = walker@" .. gname .. "_patrol" .. v .. "\n" ..
                   "combat_ignore       = combat_ignore\n" ..

                   "[walker@" .. gname .. "_patrol" .. v .. "]\n" ..
                   "path_walk           = patrol" .. v .. "_walk\n" ..
                   "path_look           = patrol" .. v .. "_look\n" ..
                   "danger              = danger@monolith\n" ..
                   "combat_ignore_cond  = {=pri_monolith_combat_ignore}\n"

        t = { section = "logic@" .. gname .. state1_kamp[i], 
            idle = 0,
            prior = prior[i], state = {1},
            squad = squad, group = groups[6],
            in_rest = "", out_rest = gname .. state1_restr[i],
            predicate = m_predicate_s
        } table.insert(sj, t)

        t = { section = "logic@" .. gname .. state2_kamp[i], 
            idle = 0,
            prior = prior[i], state = {2},
            squad = squad, group = groups[6],
            in_rest = "", out_rest = gname .. state2_restr[i],
            predicate = m_predicate_s
        } table.insert(sj, t)
    end

    -- followers
    prior = {6, 6, 4, 4}
    state1_kamp  = {"_fight_in_kolos", "_fight_in_hotel"}
    state1_restr = {"_kolos_restr",    "_hotel_restr"}
    state2_kamp  = {"_fight_in_kolos", "_fight_in_hotel"}
    state2_restr = {"_kolos_restr",    "_hotel_restr"}
    for i, v in pairs({7, 10}) do
        for j = 1, 2 do
            --- state: main
            t = { section = "logic@" .. gname .. "_group_patrol" .. i, 
                idle = 0,
                prior = prior[i + 2 * (j - 1)], state = {0},
                squad = squad, group = groups[7],
                in_rest = in_r, out_rest = "",
                predicate = m_predicate_s
            } table.insert(sj, t)

            t = { section = "logic@" .. gname .. state1_kamp[i], 
                idle = 0,
                prior = prior[i + 2 * (j - 1)], state = {1},
                squad = squad, group = groups[7],
                in_rest = "", out_rest = gname .. state1_restr[i],
                predicate = m_predicate_s
            } table.insert(sj, t)

            t = { section = "logic@" .. gname .. state2_kamp[i], 
                idle = 0,
                prior = prior[i + 2 * (j - 1)], state = {2},
                squad = squad, group = groups[7],
                in_rest = "", out_rest = gname .. state2_restr[i],
                predicate = m_predicate_s
            } table.insert(sj, t)
        end
        ltx = ltx.."[logic@" .. gname .. "_group_patrol" .. i .. "]\n" ..
                   "active              = patrol@" .. gname .. "_group_patrol" .. i .. "\n" ..
                   "combat_ignore       = combat_ignore\n" ..
                   
                   "[patrol@" .. gname .. "_group_patrol" .. i .. "]\n" ..
                   "path_walk           = patrol" .. v .. "_walk\n" ..
                   "path_look           = patrol" .. v .. "_look\n" ..
                   "formation           = line\n" ..
                   "danger              = danger@monolith\n" ..
                   "soundgroup          = " .. gname .."_group_patrol" .. i .. "_sg\n" ..
                   "combat_ignore_cond  = {=pri_monolith_combat_ignore}\n"
    end

    -- rpg, svd, machine-gun
    local id = {11, 12, 14}
    pred = {m_predicate_s_rpg, m_predicate_s_sniper, m_predicate_e_rpg}
    for i, v in pairs({"rpg", "svd", "machine_gun"}) do
        --- state: main
        t = { section = "logic@" .. gname .. "_stalker_" .. v, 
            idle = 0,
            prior = 14, state = {0,1,2},
            squad = squad, group = groups[8],
            in_rest = in_r, out_rest = "",
            predicate = pred[i]
        } table.insert(sj, t)
        ltx = ltx.."[logic@" .. gname .. "_stalker_" .. v .. "]\n" ..
                   "active              = camper@" .. gname .. "_stalker_" .. v .. "\n" ..
                   "combat_ignore       = combat_ignore\n" ..
                   
                   "[camper@" .. gname .. "_stalker_" .. v .. "]\n" ..
                   "path_walk                   = patrol" .. id[i] .. "_walk\n" ..
                   "path_look                   = patrol" .. id[i] .. "_look\n" ..
                   --"no_retreat                  = true\n" ..
                   "sniper                      = true\n" ..
                   "radius                      = 5\n" ..
                   "def_state_campering         = threat\n" ..
                   "def_state_campering_fire    = threat_fire\n" ..
                   "danger                      = danger@monolith\n" ..
                   "soundgroup                  = " .. gname .."_rpg_svd_sg\n" ..
                   "combat_ignore_cond          = {=pri_monolith_combat_ignore}\n"
        --if i == 2 then
        --    ltx = ltx.."sniper = true\n"
        --else
        --    ltx = ltx.."no_retreat = true\n"
        --end
    end

    -- kamps
    prior = {{11, 11, 11, 3}, {10, 10, 10, 2}, {11, 11, 11}, {9, 9, 9}, {13, 13, 1}}
    pred = {{m_predicate_s, m_predicate_s, m_predicate_s, m_predicate_s},
            {m_predicate_s, m_predicate_s, m_predicate_s, m_predicate_s},
            {m_predicate_e, m_predicate_e, m_predicate_e},
            {m_predicate_s, m_predicate_s, m_predicate_s},
            {m_predicate_e, m_predicate_e, m_predicate_s}}
    state1_kamp  = {"_fight_in_base1", "_fight_in_base2", "_fight_in_hotel", "_fight_in_kolos", "_fight_in_base3"}
    state1_restr = {"_base_restr",     "_base_restr",     "_hotel_restr",    "_kolos_restr",    "_base_restr"}
    state2_kamp  = {"_fight_in_base2", "_fight_in_base3", "_fight_in_base4", "_fight_in_base4", "_fight_in_base1"}
    state2_restr = {"_base_restr",     "_base_restr",     "_base_restr",     "_base_restr",     "_base_restr"}
    local pr, pd
    for i, v in pairs({4, 4, 3, 3, 3}) do
        pr = prior[i]
        pd = pred[i]
        for j = 1, v do
            --- state: main
            t = { section = "logic@" .. gname .. "_kamp" .. i .. "_soldier", 
                idle = 0,
                prior = pr[j], state = {0},
                squad = squad, group = groups[i],
                in_rest = in_r, out_rest = "",
                predicate = pd[j]
            } table.insert(sj, t)

            t = { section = "logic@" .. gname .. state1_kamp[i], 
                idle = 0,
                prior = pr[j], state = {1},
                squad = squad, group = groups[i],
                in_rest = "", out_rest = gname .. state1_restr[i],
                predicate = pd[j]
            } table.insert(sj, t)

            t = { section = "logic@" .. gname .. state2_kamp[i], 
                idle = 0,
                prior = pr[j], state = {2},
                squad = squad, group = groups[i],
                in_rest = "", out_rest = gname .. state2_restr[i],
                predicate = pd[j]
            } table.insert(sj, t)
        end
        ltx = ltx.."[logic@" .. gname .. "_kamp" .. i .. "_soldier]\n" ..
                   "active              = kamp@" .. gname .. "_kamp" .. i .. "_soldier\n" ..
                   "combat_ignore       = combat_ignore\n" ..
                   
                   "[kamp@" .. gname .. "_kamp" .. i .. "_soldier]\n" ..
                   "center_point        = kamp" .. i .. "\n" ..
                   "danger               = danger@monolith\n" ..
                   "def_state_moving    = run\n" ..
                   "soundgroup          = " .. gname .."_kamp" .. i .. "\n" ..
                   "combat_ignore_cond  = {=pri_monolith_combat_ignore}\n"
    end

    -- snipers
    for i = 1, 2 do
        t = { section = "logic@" .. gname .. "_sniper" .. i, 
            idle = 0,
            prior = 14, state = {0,1,2},
            squad = squad, group = groups[9],
            in_rest = in_r, out_rest = "",
            predicate = m_predicate_s_sniper
        } table.insert(sj, t)
        ltx = ltx.."[logic@" .. gname .. "_sniper" .. i .. "]\n" ..
                   "active          = camper@" .. gname .. "_sniper" .. i .. "_wait\n" ..
                   "combat_ignore   = combat_ignore\n" ..

                    "[camper@" .. gname .. "_sniper" .. i .. "_wait]\n" ..
                    "path_walk                  = balcony_sniper" .. i .. "_walk\n" ..
                    "path_look                  = balcony_sniper" .. i .. "_look\n" ..
                    "def_state_moving           = assault\n" ..
                    "def_state_campering        = threat\n" ..
                    "def_state_campering_fire   = threat_fire\n" ..
                    "sniper                     = true\n" ..
                    ";no_retreat                = true\n" ..
                    "radius                     = 0\n" ..
                    "on_info                    = {+" .. gname .. "_snipers_free} walker@" .. gname .. "_sniper" .. i .. "_free\n" ..
                    "combat_ignore_cond         = {=pri_monolith_combat_ignore}\n" ..

                    "[walker@" .. gname .. "_sniper" .. i .. "_free]\n" ..
                    "path_walk                  = balcony_sniper" .. i .. "_free_walk\n" ..
                    "path_look                  = balcony_sniper" .. i .. "_free_look\n" ..
                    "on_info                    = {-" .. gname .. "_snipers_free} camper@" .. gname .. "_sniper" .. i .. "_wait\n" ..
                    "combat_ignore_cond         = {=pri_monolith_combat_ignore}\n"
    end

    gulags.pri_monolith.ltx = ltx
end

-- States ----------------------------------------------------------------
gulags.pri_monolith.state = function(gulag)
    if gulag.state >= 1 and game.get_game_time():diffSec(gulag.stateBegin) < 180 then -- 3 minutes
        if db.actor:has_info("pri_monolith_base_attack_leader_zone") or gulag:get_population() < 10 then
            return 2 -- actor inside leader zone or gulag population is less then 10
        else
            return 1 -- somebody attack base
        end
    else
        local k, v = 0, 0
        for k,v in pairs(gulag.Object) do
            if v ~= true then
                local enemy = v:best_enemy()
                if enemy ~= nil then
                    local enemy_type = get_clsid(enemy)
                    if enemy_type == clsid.actor or enemy_type == clsid.script_stalker then
                        db.actor:give_info_portion("pri_monolith_base_attacked")
                        return 1
                    end
                end
            end
        end
        db.actor:disable_info_portion("pri_monolith_base_attacked")
    end

    return 0 -- normal state
end


--------------------------------------------------------------------------
-- Stadium
--------------------------------------------------------------------------
-- Jobs ------------------------------------------------------------------
gulags.pri_stadium.job = function(sj, gname, type, squad, groups)
    local i, ltx = 1, ""
    -- Проверяем наличие снайперов в лагере.
    while level.patrol_path_exists(gname .. "_sniper_" .. i .. "_walk") do
        -- Необходимо вычитать количество работ из названия точки пути.
        local way_name = gname .. "_sniper_" .. i .. "_walk"

        -- добавляем должность
        t = { section = "logic@" .. way_name,
            idle = 0,
            prior = 1, state = {0}, squad = squad, group = groups[1],
            in_rest = "", out_rest = "pri_stadium_restr",
            predicate = m_predicate_e
        }
        table.insert(sj, t)

        -- добавляем описание должности в лтх.
        ltx = ltx.."[logic@" .. way_name .. "]\n" ..
                   "active = camper@" .. way_name .. "\n" ..

                   "[camper@" .. way_name .. "]\n" ..
                   "path_walk                   = sniper_" .. i .. "_walk\n" ..
                   "path_look                   = sniper_look\n" ..
                   "def_state_campering         = threat\n" ..
                   "def_state_campering_fire    = threat_sniper_fire\n" ..
                   "sniper                      = true\n"
        i = i + 1
    end

    gulags.pri_stadium.ltx = ltx
end

--[[ Jobs ------------------------------------------------------------------
gulags.pri_stadium.job = function(sj, gname, type, squad, groups)
    local i, j, v = 0, 0, 0
    local restr = {"", "_kill_restr", "_restr"}
    local logic = {"wait", "heli", "free"}
    local ltx = ""

    for i, v in pairs(logic) do
        for j = 1, 10 do
            t = { section = "logic@" .. gname .. "_gigant_" .. v,
                idle = 0,
                prior = 1, state = {i - 1},
                squad = squad, group = groups[1],
                in_rest = "", out_rest = gname .. restr[i]
            }
            table.insert(sj, t)
        end
        ltx = ltx.."[logic@" .. gname .. "_gigant_" .. v .. "]\n" ..
                   "active     = mob_home@" .. gname .. "_gigant_" .. v .. "\n" ..

                   "[mob_home@" .. gname .. "_gigant_" .. v .. "]\n" ..
                   "path_home               = home" .. i .. "\n"
    end

    gulags.pri_stadium.ltx = ltx
end

-- States ----------------------------------------------------------------
gulags.pri_stadium.state = function(gulag)
    --local state = gulag.state
    local actor = db.actor
    if actor:has_info("pri_stadium_scene_start") then
        if actor:has_info("pri_stadium_scene_end") then
            return 2
        else
            return 1
        end
    else
        return 0
    end
end
--]]

-------------------------------------------------------------------------------------------------------------------------
--printf("gulag <pri>: table -")
--print_table(gulags)
