--------------------------------------------------------------------------
-- Stuff
--------------------------------------------------------------------------
function printf() end


--------------------------------------------------------------------------
-- Member counts
--------------------------------------------------------------------------
local st_snorks_count = 10
local st_tushkanos_count = 8


--------------------------------------------------------------------------
-- States
--------------------------------------------------------------------------
local state_wait  = 0
local state_wave1 = 1
local state_wave2 = 2
local state_wave3 = 3
local state_wave4 = 4
local state_wave5 = 5
local state_wave6 = 6
local state_wave7 = 7
local state_wave8 = 8

local state_zombied_guard = 0
local state_zombied_scene = 1
local state_zombied_fight = 2


--------------------------------------------------------------------------
-- Locals
--------------------------------------------------------------------------
local function obj_has_item(npc_info, item_name, def_val)
    local se_obj = npc_info.se_obj
    local t = true

    if def_val then
        t = def_val
    end

    if se_obj.online then
        local obj = level.object_by_id(se_obj.id)
        if obj then
            t = obj:object(item_name) ~= nil
        end
	end

	return t
end

zombied_in_combat = {}

function is_zombied_in_combat()
    local k, v = 0, 0
    for k,v in pairs(zombied_in_combat) do
        return true
    end
    return false
end


--------------------------------------------------------------------------
-- General
--------------------------------------------------------------------------
local t = {}
local gulags = {pri_followers       = {comm = {"stalker"}},
                pri_wave            = {comm = true},
                pri_ambush7         = {comm = {"monolith"}},
                pri_corner          = {comm = {"monolith"}},
                pri_zombied         = {comm = {"zombied", "military", "controller"}},
                pri_monolith        = {comm = {"monolith"}},
                pri_stadium         = {comm = {"pseudo_gigant"}}}

-- Job -------------------------------------------------------------------
function load_job(sj, gname, type, squad, groups)
    local g = gulags[type]
    if g then
        g.job(sj, gname, type, squad, groups)
    end
end

-- State -----------------------------------------------------------------
function check_state_stub(gulag)
    return 0
end

function load_states(gname, type)
    local g = gulags[type]

    if g then
        return g.state or check_state_stub
    end

	return nil
end
	    
-- Dynamic ltx -----------------------------------------------------------
function load_ltx(gname, type)
    local g = gulags[type]
    if g then
        return g.ltx
    end

	return nil
end

-- Check communities -----------------------------------------------------
local function checkCommon(npc_community, gulag_type, npc_rank, se_obj, stalker)
    local g = gulags[gulag_type]
    if g then
        if g.comm then
            if type(g.comm) == "function" then
                return g.comm(npc_community, gulag_type, npc_rank, se_obj, stalker)
            end
            if type(g.comm) == "boolean" then
                return g.comm == stalker
            end

            local i, v = 0, 0
            for i, v in pairs(g.comm) do
                if npc_community == v then
                    return true
                end
            end
            if i > 0 then
                return false
            end
        end
        return true
    end
	return false
end

function checkStalker(npc_community, gulag_type, npc_rank, se_obj)
	return checkCommon(npc_community, gulag_type, npc_rank, se_obj, true)
end

function checkMonster(npc_community, gulag_type, npc_rank, se_obj)
	return checkCommon(npc_community, gulag_type, npc_rank, se_obj, false)
end


--------------------------------------------------------------------------
-- Predicates
--------------------------------------------------------------------------
function f_predicate4_1(npc_info)
    if npc_info.class_id == clsid.script_stalker or npc_info.class_id == clsid.stalker then
        local prof = npc_info.profile_name
	    return prof == "pri_soldier_suicide"
	end
	return false
end


--------------------------------------------------------------------------
-- Gulags
--------------------------------------------------------------------------

--------------------------------------------------------------------------
-- Followers
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function f_predicate(npc_info)
	return npc_info.profile_name == "pri_followers"
end

function f_predicate_b(npc_info)
	return npc_info.profile_name == "pri_followers" and obj_has_item(npc_info, "wpn_rpg7")
end

-- Jobs ------------------------------------------------------------------
gulags.pri_followers.job = function(sj, gname, type, squad, groups)
    local i, v, j = 0, 0, 0

    -- gulag members
    local followers = {"leader", "bomber", "nap1", "nap2", "nap3"}

    -- states name
    local states_str = {"wait", "wave1", "wave2", "wave3", "wave4", "wave5", "wave6", "wave7", "wave8"}

    -- states num
    local states = {state_wait, state_wave1, state_wave2, state_wave3, state_wave4, state_wave5, state_wave6, state_wave7, state_wave8}

    -- out restrictors for the each state
    local restr = {"",                              "pri_followers_wave1_out_restr", "pri_followers_wave2_out_restr",
                   "pri_followers_wave3_out_restr", "pri_followers_wave4_out_restr", "pri_followers_wave5_out_restr",
                   "pri_followers_wave6_out_restr", "pri_followers_wave7_out_restr", "pri_followers_wave7_out_restr"}

    -- priorities
    local prior = {{2, 2, 2, 2, 2, 2, 2, 2, 3}, -- leader
                   {3, 3, 3, 3, 3, 3, 3, 3, 2}, -- bomber
                   {1, 1, 1, 1, 1, 1, 1, 1, 1}, -- nap1
                   {1, 1, 1, 1, 1, 1, 1, 1, 1}, -- nap2
                   {1, 1, 1, 1, 1, 1, 1, 1, 1}  -- nap3
                  }
    -- predicates
    local pred = {f_predicate, f_predicate_b, f_predicate, f_predicate, f_predicate}

    local pr, pd
    for i, v in pairs(followers) do
        pr = prior[i]
        pd = pred[i]
        for j = 1, 9 do
	        t = { section = "logic@" .. gname .. "_" .. v .. "_" .. states_str[j],
		        idle = 0,
		        prior = pr[j], state = { states[j] },
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = restr[j],
		        position_threshold = 100,
		        online = true,
		        predicate = pd
	        }
	        table.insert(sj, t)
        end
    end
end

-- States ----------------------------------------------------------------
gulags.pri_followers.state = function(gulag)
	local state = gulag.state
	local actor = db.actor
    --printf("gulag <state>: prip followers check state(%d).", state)
	if state == state_wait and actor:has_info("pri_followers_start") then
		return state_wave1
	end
	if state == state_wave1 and
		actor:has_info("pri_wave1_monolith1_dead") and
		actor:has_info("pri_wave1_monolith2_dead") and
		actor:has_info("pri_wave1_monolith3_dead") --and
		--actor:has_info("pri_wave1_monolith4_dead")
	then
		actor:give_info_portion("pri_wave1_end")
		return state_wave2
	end
	if state == state_wave2 and
		actor:has_info("pri_wave2_monolith1_dead") and
		actor:has_info("pri_wave2_monolith2_dead") and
		--actor:has_info("pri_wave2_monolith3_dead") and
		actor:has_info("pri_wave2_monolith4_dead") and
		--actor:has_info("pri_wave2_monolith5_dead") and
		actor:has_info("pri_wave2_monolith6_dead") --and
		--actor:has_info("pri_wave2_monolith7_dead") and
		--actor:has_info("pri_wave2_monolith8_dead") and
		--actor:has_info("pri_wave2_monolith9_dead")
	then
		actor:give_info_portion("pri_wave2_end")
		--actor:give_info_portion("pri_wave3_end") -- FAKE
		return state_wave3 --4
	end
	if state == state_wave3 and actor:has_info("pri_wave3_btr_dead") then
		actor:give_info_portion("pri_wave3_end")
		return state_wave4
	end
	if state == state_wave4 and
		actor:has_info("pri_wave4_monolith1_dead") and
		actor:has_info("pri_wave4_monolith2_dead") and
		actor:has_info("pri_wave4_monolith3_dead") and
		--actor:has_info("pri_wave4_monolith4_dead") and
		actor:has_info("pri_wave4_monolith5_dead") and
		--actor:has_info("pri_wave4_monolith6_dead") and
		--actor:has_info("pri_wave4_monolith7_dead") and
		actor:has_info("pri_wave4_monolith8_dead")
	then
		actor:give_info_portion("pri_wave4_end")
		return state_wave5
	end
	if state == state_wave5 and
		actor:has_info("pri_wave5_monolith1_dead") and
		actor:has_info("pri_wave5_monolith2_dead") and
		actor:has_info("pri_wave5_monolith3_dead") and
		actor:has_info("pri_wave5_monolith4_dead")
	then
	    --if actor:dont_has_info("pri_wave5_leader_phrase_end") then
		--    actor:give_info_portion("pri_wave5_leader_phrase_start")
		--    return state_wave5
	    --else
		    actor:give_info_portion("pri_wave5_end")
		    return state_wave6
		--end
	end
	if state == state_wave6 and
		--actor:has_info("pri_wave6_monolith1_dead") and
		actor:has_info("pri_wave6_monolith2_dead") and
		actor:has_info("pri_wave6_monolith3_dead")
	then
		actor:give_info_portion("pri_wave6_end")
		return state_wave7
	end
	if state == state_wave7 and
        xr_gulag.getGulagPopulation("pri_ambush7") == 0
    then
        actor:give_info_portion("pri_wave7_end")
        return state_wave8
    end
    return state
end


--------------------------------------------------------------------------
-- Ambush7
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------

-- Jobs ------------------------------------------------------------------
gulags.pri_ambush7.job = function(sj, gname, type, squad, groups)
    local i, ltx = 0, ""
    for i = 1, 7 do
        --- state 0
	    t = { section = "logic@" .. gname .. "_monolith" .. i .. "_hide", 
		    idle = 0,
		    prior = 1, state = {0}, squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_out_restr"
	    }
	    table.insert(sj, t)
        --- state 1
	    t = { section = "logic@" .. gname .. "_monolith" .. i, 
		    idle = 0,
		    prior = 1, state = {1}, squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_out_restr"
	    }
        table.insert(sj, t)

        ltx = ltx.."[logic@" .. gname .. "_monolith" .. i .. "_hide]\n" ..
                   "active              = walker@" .. gname .. "_monolith" .. i .. "_hide\n" ..
                   "combat_ignore       = combat_ignore\n" ..

                   "[walker@" .. gname .. "_monolith" .. i .. "_hide]\n" ..
                   "path_walk           = monolith" .. i .. "_hide_walk\n" ..
                   "path_look           = monolith" .. i .. "_hide_look\n" ..
                   "combat_ignore_cond  = always\n" ..
                   "show_spot           = false\n" ..

                   "[logic@" .. gname .. "_monolith" .. i .. "]\n" ..
                   "active              = walker@" .. gname .. "_monolith" .. i .. "\n" ..

                   "[walker@" .. gname .. "_monolith" .. i .. "]\n" ..
                   "path_walk           = monolith" .. i .. "_walk\n" ..
                   "path_look           = monolith" .. i .. "_look\n"
    end

    gulags.pri_ambush7.ltx = ltx
end

-- States ----------------------------------------------------------------
gulags.pri_ambush7.state = function(gulag)
	if db.actor:has_info("pri_wave7_start") then
        return 1
    else
	    return 0
	end
end


--------------------------------------------------------------------------
-- Wave
--------------------------------------------------------------------------
-- Additional functions --------------------------------------------------
local function process_range(str, def_val)
    return def_val
end

local function process_num(str, def_val)
    if str ~= nil then
        return tonumber(str) or def_val
    end
    return def_val
end

-- Predicates ------------------------------------------------------------

-- Jobs ------------------------------------------------------------------
gulags.pri_wave.job = function(sj, gname, type, squad, groups)
    local i, ltx = 1, ""

	-- Снайперы в окнах.
	i = 1
	while level.patrol_path_exists(gname .. "_wsniper_" .. i .."_walk") do
		-- Необходимо вычитать количество работ из названия точки пути.
		local idstr = gname .. "_wsniper_" .. i
		local way_name = idstr .."_walk"
        local ptr = patrol(way_name)
        local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))

        local stime = process_range(wp_prop.stime, 15) * 1000 -- sniper time in seconds
        local gtime = process_range(wp_prop.gtime, 10) * 1000 -- guard time in seconds
        local htime = process_range(wp_prop.htime, 7) * 1000  -- hide time in seconds

        local sdist = process_num(wp_prop.sdist, 55) -- sniper distance
        local gdist = process_num(wp_prop.gdist, 45) -- guard distance
        if gdist >= sdist then
            gdist = sdist + 5
        end

        local outr = wp_prop.outr or "" -- out restrictors
        local inr = wp_prop.inr or "" -- in restrictors

        local starti = wp_prop.starti -- start infoportion
        local deathi = wp_prop.deathi -- death infoportion

		-- добавляем должность
		t = { section = "logic@" .. idstr,
			idle = 0,
			prior = 1, state = {0}, squad = squad, group = groups[1],
			in_rest = inr, out_rest = outr
		}
		table.insert(sj, t)

		-- добавляем описание должности в лтх.
		ltx = ltx.."[logic@" .. idstr .. "]\n" ..
		           "combat_ignore = combat_ignore\n"
		
		if starti then
            ltx = ltx.."active = remark@" .. idstr .. "_wait\n"

		    if deathi then
                ltx = ltx.."on_death = death@" .. idstr .. "\n" ..

                           "[death@" .. idstr .. "]\n" ..							
                           "on_info = %+" .. deathi .. "%\n"
		    end

            ltx = ltx.."[remark@" .. idstr .. "_wait]\n" ..							
                       "path_walk           = wsniper_" .. i .. "_wait_walk\n" ..
                       "anim                = hide\n" ..
                       "on_info             = {+" .. starti .. "} camper@" .. idstr .. "\n" ..
                       "combat_ignore_cond  = always\n"
		else
            ltx = ltx.."active = camper@" .. idstr .. "\n"
		end

        ltx = ltx.."[camper@" .. idstr .. "]\n" ..							
                   "path_walk                   = wsniper_" .. i .. "_walk\n" ..
                   "path_look                   = wsniper_" .. i .. "_look\n" ..
                   "def_state_moving            = assault\n" ..
                   "def_state_campering         = threat\n" ..
                   "def_state_campering_fire    = threat_sniper_fire\n" ..
                   "sniper                      = true\n" ..
                   "on_info                     = {=dist_to_enemy_le(" .. gdist .. ")} camper@" .. idstr .. "_guard\n" ..
                   "on_timer                    = " .. stime .. " | remark@" .. idstr .. "_hide\n" ..

                   "[camper@" .. idstr .. "_guard]\n" ..							
                   "path_walk                   = wsniper_" .. i .. "_walk\n" ..
                   "path_look                   = wsniper_" .. i .. "_look\n" ..
                   "def_state_campering         = threat\n" ..
                   "def_state_campering_fire    = threat_fire\n" ..
                   "no_retreat                  = true\n" ..
                   "radius                      = 0\n" ..
                   "on_info                     = {!dist_to_enemy_le(" .. sdist .. ")} camper@" .. idstr .. "\n" ..
                   "on_timer                    = " .. gtime .. " | remark@" .. idstr .. "_hide\n" ..

                   "[remark@" .. idstr .. "_hide]\n" ..							
                   "anim                = hide\n" ..
                   "on_timer            = " .. htime .. " | camper@" .. idstr .. "\n" ..
                   "combat_ignore_cond  = always\n"
		i = i + 1
	end

	-- Снайперы на крышах.
	i = 1
	while level.patrol_path_exists(gname .. "_rsniper_" .. i .."_walk") do
		-- Необходимо вычитать количество работ из названия точки пути.
		local idstr = gname .. "_rsniper_" .. i
		local way_name = idstr .."_walk"
        local ptr = patrol(way_name)
        local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))

        local sdist = process_num(wp_prop.sdist, 55) -- sniper distance
        local gdist = process_num(wp_prop.gdist, 45) -- guard distance
        if gdist >= sdist then
            gdist = sdist + 5
        end

        local outr = wp_prop.outr or "" -- out restrictors
        local inr = wp_prop.inr or "" -- in restrictors

        local starti = wp_prop.starti -- start infoportion
        local deathi = wp_prop.deathi -- death infoportion

		-- добавляем должность
		t = { section = "logic@" .. idstr,
			idle = 0,
			prior = 1, state = {0}, squad = squad, group = groups[1],
			in_rest = inr, out_rest = outr
		}
		table.insert(sj, t)

		-- добавляем описание должности в лтх.
		ltx = ltx.."[logic@" .. idstr .. "]\n" ..
		           "combat_ignore = combat_ignore\n"
		
		if starti then
            ltx = ltx.."active = remark@" .. idstr .. "_wait\n"

		    if deathi then
                ltx = ltx.."on_death = death@" .. idstr .. "\n" ..

                           "[death@" .. idstr .. "]\n" ..							
                           "on_info = %+" .. deathi .. "%\n"
		    end

            ltx = ltx.."[remark@" .. idstr .. "_wait]\n" ..							
                       "path_walk           = rsniper_" .. i .. "_wait_walk\n" ..
                       "anim                = hide\n" ..
                       "on_info             = {+" .. starti .. "} camper@" .. idstr .. "\n" ..
                       "combat_ignore_cond  = always\n"
		else
            ltx = ltx.."active = camper@" .. idstr .. "\n"
		end

        ltx = ltx.."[camper@" .. idstr .. "]\n" ..							
                   "path_walk                   = rsniper_" .. i .. "_walk\n" ..
                   "path_look                   = rsniper_" .. i .. "_look\n" ..
                   "def_state_moving            = assault\n" ..
                   "def_state_campering         = threat\n" ..
                   "def_state_campering_fire    = threat_sniper_fire\n" ..
                   "sniper                      = true\n" ..
                   "on_info                     = {=dist_to_enemy_le(" .. gdist .. ")} camper@" .. idstr .. "_guard\n" ..

                   "[camper@" .. idstr .. "_guard]\n" ..							
                   "path_walk                   = rsniper_" .. i .. "_walk\n" ..
                   "path_look                   = rsniper_" .. i .. "_look\n" ..
                   "def_state_campering         = hide\n" ..
                   "def_state_campering_fire    = hide_fire\n" ..
                   "no_retreat                  = true\n" ..
                   "radius                      = 0\n" ..
                   "on_info                     = {!dist_to_enemy_le(" .. sdist .. ")} camper@" .. idstr .. "\n"
		i = i + 1
	end

	-- Свободные волкеры в кемпах.
	i = 1
	while level.patrol_path_exists(gname .. "_free_" .. i .."_walk") do
		-- Необходимо вычитать количество работ из названия точки пути.
		local idstr = gname .. "_free_" .. i
		local way_name = idstr .."_walk"
        local ptr = patrol(way_name)
        local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))

        local wtime = process_range(wp_prop.wtime, 40) * 1000  -- walker state time in seconds
        local ktime = process_range(wp_prop.ktime, 120) * 1000 -- kamp state time in seconds

        local kampi = process_num(wp_prop.sdist, 1) -- kamp index

        local outr = wp_prop.outr or "" -- out restrictors
        local inr = wp_prop.inr or "" -- in restrictors

        local starti = wp_prop.starti -- start infoportion
        local deathi = wp_prop.deathi -- death infoportion

		-- добавляем должность
		t = { section = "logic@" .. idstr,
			idle = 0,
			prior = 1, state = {0}, squad = squad, group = groups[1],
			in_rest = inr, out_rest = outr
		}
		table.insert(sj, t)

		-- добавляем описание должности в лтх.
		ltx = ltx.."[logic@" .. idstr .. "]\n" ..
		           "combat_ignore = combat_ignore\n"
		
		if starti then
            ltx = ltx.."active = remark@" .. idstr .. "_wait\n"

		    if deathi then
                ltx = ltx.."on_death = death@" .. idstr .. "\n" ..

                           "[death@" .. idstr .. "]\n" ..							
                           "on_info = %+" .. deathi .. "%\n"
		    end

            ltx = ltx.."[remark@" .. idstr .. "_wait]\n" ..							
                       "path_walk           = free_" .. i .. "_wait_walk\n" ..
                       "anim                = hide\n" ..
                       "on_info             = {+" .. starti .. "} camper@" .. idstr .. "\n" ..
                       "combat_ignore_cond  = always\n"
		else
            ltx = ltx.."active = camper@" .. idstr .. "\n"
		end

        ltx = ltx.."[camper@" .. idstr .. "]\n" ..							
                   "path_walk                   = free_" .. i .. "_walk\n" ..
                   "path_look                   = free_" .. i .. "_look\n" ..
                   "def_state_moving            = patrol\n" ..
                   "def_state_moving_fire       = patrol_fire\n" ..
                   "def_state_campering         = threat\n" ..
                   "def_state_campering_fire    = threat_sniper_fire\n" ..
                   "no_retreat                  = true\n" ..
                   "radius                      = 7\n" ..
                   "on_timer                    = " .. wtime .. " | kamp@" .. idstr .. "\n" ..

                   "[kamp@" .. idstr .. "]\n" ..							
                   "center_point        = kamp_" .. kampi .. "\n" ..
                   "def_state_moving    = patrol\n" ..
                   "on_timer            = " .. ktime .. " | camper@" .. idstr .. "\n"
		i = i + 1
	end

    gulags.pri_wave.ltx = ltx
end


--------------------------------------------------------------------------
-- Corners
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------

-- Jobs ------------------------------------------------------------------
gulags.pri_corner.job = function(sj, gname, type, squad, groups)
    local i = 0

    for i = 1, 3 do
	    t = { section = "logic@" .. gname .. "_monolith", 
		    idle = 0,
		    prior = 1, state = {0}, squad = squad, group = groups[1],
		    in_rest = "", out_rest = ""
	    }
	    table.insert(sj, t)
    end

    gulags.pri_corner.ltx = "[logic@" .. gname .. "_monolith]\n" ..
                            "active              = patrol@" .. gname .. "_monolith_wait\n" ..
                            "combat_ignore       = combat_ignore\n" ..

                            "[patrol@" .. gname .. "_monolith_wait]\n" ..
                            "path_walk           = monolith_wait_walk\n" ..
                            "path_look           = monolith_wait_look\n" ..
                            "formation           = back\n" ..
                            "on_info             = {+pri_corner_start} patrol@" .. gname .. "_monolith_go\n" ..
                            "combat_ignore_cond  = always\n" ..

                            "[patrol@" .. gname .. "_monolith_go]\n" ..
                            "path_walk           = monolith_walk\n" ..
                            "path_look           = monolith_look\n" ..
                            "on_signal           = arrived | %+pri_corner_end%\n" 
end


--------------------------------------------------------------------------
-- Zombied
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function z_predicate_c(npc_info)
	return npc_info.community == "controller"
end

function z_predicate_s(npc_info)
    local prof = npc_info.profile_name
	return prof == "pri_zombied" or prof == "pri_zombied_veteran"
end

-- Jobs ------------------------------------------------------------------
gulags.pri_zombied.job = function(sj, gname, type, squad, groups)
    local i, j, v = 0, 0, 0
    local ltx = ""

    ltx = "[" .. gname .. "_death]\n" ..
          "on_info      = {+pri_zombied_scene_end} %=pri_zombied_in_combat_dec%\n" ..

          "[logic@" .. gname .. "_controller]\n" ..
          "active     = mob_home@" .. gname .. "_controller\n" ..
          "mob_death  = " .. gname .. "_death\n" ..

          "[mob_home@" .. gname .. "_controller]\n" ..
          "path_home    = controllers_home\n" ..
          "aggressive_home\n"

    local states = {state_zombied_guard, state_zombied_scene, state_zombied_fight}
    for i = 1, 3 do
        for j, v in pairs(states) do
	        t = { section = "logic@" .. gname .. "_controller", 
		        idle = 0,
		        prior = 1, state = {states[j]},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = gname .. "_base_restr",
		        predicate = z_predicate_c
	        }
	        table.insert(sj, t)
        end
    end

    ltx = ltx.."[combat_zombied]\n" ..
               "combat_type           = zombied\n" ..

               "[danger@zombied]\n" ..
               "ignore_types = corpse\n" ..
               "ignore_distance_hit     = 1\n"

    -- out restrictors for the each state of zombied stalkers
    local states_str = {"guard", "scene", "fight"}
    local logic_str = {"fg", "scene", "fg"}
    local restr = {gname .. "_base_restr", gname .. "_base_big_restr", ""}
    for i = 1, 7 do
        for j, v in pairs(states_str) do
	        t = { section = "logic@" .. gname .. "_soldier" .. i .. "_" .. logic_str[j], 
		        idle = 0,
		        prior = 1, state = {states[j]},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = restr[j],
		        predicate = z_predicate_s
	        }
	        table.insert(sj, t)
        end
        ltx = ltx.."[logic@" .. gname .. "_soldier" .. i .. "_scene]\n" ..
                   "active              = walker@" .. gname .. "_soldier" .. i .. "_scene\n" ..
                   "on_combat           = combat_zombied\n" ..
                   "combat_ignore       = combat_ignore\n" ..

                   "[walker@" .. gname .. "_soldier" .. i .. "_scene]\n" ..
                   "path_walk           = scene_walk" .. i .. "\n" ..
                   "on_signal           = arrived | nil\n" ..
                   "danger              = danger@zombied\n" ..

                   "[logic@" .. gname .. "_soldier" .. i .. "_fg]\n" ..
                   "active              = walker@" .. gname .. "_soldier" .. i .. "\n" ..
                   "on_death            = " .. gname .. "_death\n" ..
                   "on_combat           = combat_zombied\n" ..

                   "[walker@" .. gname .. "_soldier" .. i .. "]\n" ..
                   "path_walk             = free" .. i .. "_walk\n" ..
                   "on_actor_dist_le_nvis = 25 | {+pri_zombied_scene_end} %=pri_zombied_in_combat_inc%\n" ..
                   "on_actor_dist_ge_nvis = 40 | {+pri_zombied_scene_end} %=pri_zombied_in_combat_dec%\n" ..
                   "danger                = danger@zombied\n"
    end
    
    gulags.pri_zombied.ltx = ltx
end

-- States ----------------------------------------------------------------
gulags.pri_zombied.state = function(gulag)
	--local state = gulag.state
	local actor = db.actor
    if actor:has_info("pri_zombied_scene_start") then
        if actor:dont_has_info("pri_zombied_scene_end") then
            return state_zombied_scene -- suicide scene
        elseif is_zombied_in_combat() then --table.getn(zombied_in_combat) > 0 then
            --if state_zombied_fight ~= state then
            --    printf("gulag <state>: pri_zombied - fight")
            --end
            return state_zombied_fight
        else
            --if state_zombied_guard ~= state then
            --    printf("gulag <state>: pri_zombied - guard")
            --end
            return state_zombied_guard
        end
    else
        return state_zombied_guard
    end
    --return state
end


--------------------------------------------------------------------------
-- Monolith
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function m_predicate_r(npc_info)
	return npc_info.profile_name == "pri_monolith_regular"
end

function m_predicate_s(npc_info)
	return npc_info.profile_name == "pri_monolith_specnaz"
end

function m_predicate_e(npc_info)
	return npc_info.profile_name == "pri_monolith_exo"
end

function m_predicate_s_rpg(npc_info)
	return npc_info.profile_name == "pri_monolith_specnaz" and obj_has_item(npc_info, "wpn_rpg7")
end

function m_predicate_s_svd(npc_info)
	return npc_info.profile_name == "pri_monolith_specnaz" and obj_has_item(npc_info, "wpn_svd")
end

function m_predicate_e_rpg(npc_info)
	return npc_info.profile_name == "pri_monolith_exo" and obj_has_item(npc_info, "wpn_rpg7")
end

-- Jobs ------------------------------------------------------------------
gulags.pri_monolith.job = function(sj, gname, type, squad, groups)
    local i, j, v = 0, 0, 0
    local prior, pred = 0, 0
    local ltx = ""
    local in_r = "pri_snork_nest2_big_restr" --pri_snork_nest1_big_restr

    ltx = "[danger@monolith]\n" ..
          "ignore_distance_sound = 150\n"

    -- walkers
    prior = {6, 7, 8, 12, 12, 5}
    for i, v in pairs({1, 3, 4, 5, 6, 8}) do
        --- state: main
	    t = { section = "logic@" .. gname .. "_patrol" .. v, 
		    idle = 0,
		    prior = prior[i], state = {0},
		    squad = squad, group = groups[6],
		    in_rest = in_r, out_rest = "",
		    predicate = m_predicate_s
	    }
	    table.insert(sj, t)
        ltx = ltx.."[logic@" .. gname .. "_patrol" .. v .. "]\n" ..
                   "active              = walker@" .. gname .. "_patrol" .. v .. "\n" ..
                   "combat_ignore       = combat_ignore\n" ..

                   "[walker@" .. gname .. "_patrol" .. v .. "]\n" ..
                   "path_walk           = patrol" .. v .. "_walk\n" ..
                   "path_look           = patrol" .. v .. "_look\n" ..
                   "danger              = danger@monolith\n" ..
                   "combat_ignore_cond  = {=pri_monolith_combat_ignore}\n"
	end

	-- followers
    prior = {6, 6, 4, 4}
    for i, v in pairs({7, 10}) do
        for j = 1, 2 do
            --- state: main
	        t = { section = "logic@" .. gname .. "_group_patrol" .. i, 
		        idle = 0,
		        prior = prior[i + 2 * (j - 1)], state = {0},
		        squad = squad, group = groups[7],
		        in_rest = in_r, out_rest = "",
		        predicate = m_predicate_s
	        }
	        table.insert(sj, t)
	    end
        ltx = ltx.."[logic@" .. gname .. "_group_patrol" .. i .. "]\n" ..
                   "active              = patrol@" .. gname .. "_group_patrol" .. i .. "\n" ..
                   "combat_ignore       = combat_ignore\n" ..
                   
                   "[patrol@" .. gname .. "_group_patrol" .. i .. "]\n" ..
                   "path_walk           = patrol" .. v .. "_walk\n" ..
                   "path_look           = patrol" .. v .. "_look\n" ..
                   "formation           = line\n" ..
                   "danger              = danger@monolith\n" ..
                   "soundgroup          = " .. gname .."_group_patrol" .. i .. "_sg\n" ..
                   "combat_ignore_cond  = {=pri_monolith_combat_ignore}\n"
    end

    -- rpg, svd, machine-gun
    local id = {11, 12, 14}
	pred = {m_predicate_s_rpg, m_predicate_s_svd, m_predicate_e_rpg}
	for i, v in pairs({"rpg", "svd", "machine_gun"}) do
        --- state: main
	    t = { section = "logic@" .. gname .. "_stalker_" .. v, 
		    idle = 0,
		    prior = 14, state = {0},
		    squad = squad, group = groups[8],
		    in_rest = in_r, out_rest = "",
		    predicate = pred[i]
	    }
	    table.insert(sj, t)
	    ltx = ltx.."[logic@" .. gname .. "_stalker_" .. v .. "]\n" ..
                   "active              = camper@" .. gname .. "_stalker_" .. v .. "\n" ..
                   "combat_ignore       = combat_ignore\n" ..
                   
                   "[camper@" .. gname .. "_stalker_" .. v .. "]\n" ..
                   "path_walk                   = patrol" .. id[i] .. "_walk\n" ..
                   "path_look                   = patrol" .. id[i] .. "_look\n" ..
                   --"no_retreat                  = true\n" ..
                   "sniper                      = true\n" ..
                   "radius                      = 5\n" ..
                   "def_state_campering         = threat\n" ..
                   "def_state_campering_fire    = threat_fire\n" ..
                   "danger                      = danger@monolith\n" ..
                   "soundgroup                  = " .. gname .."_rpg_svd_sg\n" ..
                   "combat_ignore_cond          = {=pri_monolith_combat_ignore}\n"
        --if i == 2 then
        --    ltx = ltx.."sniper = true\n"
        --else
        --    ltx = ltx.."no_retreat = true\n"
        --end
	end

    -- kamps
    prior = {{11, 11, 11, 3}, {10, 10, 10, 2}, {11, 11, 11}, {9, 9, 9}, {13, 13, 1}}
    pred = {{m_predicate_s, m_predicate_s, m_predicate_s, m_predicate_s},
            {m_predicate_s, m_predicate_s, m_predicate_s, m_predicate_s},
            {m_predicate_e, m_predicate_e, m_predicate_e},
            {m_predicate_s, m_predicate_s, m_predicate_s},
            {m_predicate_e, m_predicate_e, m_predicate_s}}
    local pr, pd
	for i, v in pairs({4, 4, 3, 3, 3}) do
	    pr = prior[i]
	    pd = pred[i]
	    for j = 1, v do
            --- state: main
	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_soldier", 
		        idle = 0,
		        prior = pr[j], state = {0},
		        squad = squad, group = groups[5],
		        in_rest = in_r, out_rest = "",
		        predicate = pd[j]
	        }
	        table.insert(sj, t)
	    end
	    ltx = ltx.."[logic@" .. gname .. "_kamp" .. i .. "_soldier]\n" ..
                   "active              = kamp@" .. gname .. "_kamp" .. i .. "_soldier\n" ..
                   "combat_ignore       = combat_ignore\n" ..
                   
                   "[kamp@" .. gname .. "_kamp" .. i .. "_soldier]\n" ..
                   "center_point        = kamp" .. i .. "\n" ..
                   "danger               = danger@monolith\n" ..
                   "def_state_moving    = run\n" ..
                   "soundgroup          = " .. gname .."_kamp" .. i .. "\n" ..
                   "combat_ignore_cond  = {=pri_monolith_combat_ignore}\n"
	end

    -- snipers
    for i = 1, 2 do
	    t = { section = "logic@" .. gname .. "_sniper" .. i, 
		    idle = 0,
		    prior = 14, state = {0}, squad = squad, group = groups[9],
		    in_rest = in_r, out_rest = "",
		    predicate = m_predicate_s_svd
	    }
	    table.insert(sj, t)
        ltx = ltx.."[logic@" .. gname .. "_sniper" .. i .. "]\n" ..
                    "active     = camper@" .. gname .. "_sniper" .. i .. "_wait\n" ..

                    "[camper@" .. gname .. "_sniper" .. i .. "_wait]\n" ..
                    "path_walk                  = balcony_sniper" .. i .. "_walk\n" ..
                    "path_look                  = balcony_sniper" .. i .. "_look\n" ..
                    "def_state_campering        = threat\n" ..
                    "def_state_campering_fire   = threat_fire\n" ..
                    "sniper                     = true\n" ..
                    ";no_retreat                = true\n" ..
                    "radius                     = 0\n" ..
                    "on_info                    = {+" .. gname .. "_snipers_free} walker@" .. gname .. "_sniper" .. i .. "_free\n" ..
                    "combat_ignore_cond         = {=pri_monolith_combat_ignore}\n" ..

                    "[walker@" .. gname .. "_sniper" .. i .. "_free]\n" ..
                    "path_walk                  = balcony_sniper" .. i .. "_free_walk\n" ..
                    "path_look                  = balcony_sniper" .. i .. "_free_look\n" ..
                    "on_info                    = {-" .. gname .. "_snipers_free} camper@" .. gname .. "_sniper" .. i .. "_wait\n" ..
                    "combat_ignore_cond         = {=pri_monolith_combat_ignore}\n"
    end

    gulags.pri_monolith.ltx = ltx
end


--------------------------------------------------------------------------
-- Stadium
--------------------------------------------------------------------------
-- Jobs ------------------------------------------------------------------
gulags.pri_stadium.job = function(sj, gname, type, squad, groups)
    local i, j, v = 0, 0, 0
    local restr = {"", "_kill_restr", "_restr"}
    local logic = {"wait", "heli", "free"}
    local ltx = ""

    for i, v in pairs(logic) do
        for j = 1, 10 do
	        t = { section = "logic@" .. gname .. "_gigant_" .. v,
		        idle = 0,
		        prior = 1, state = {i - 1},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = gname .. restr[i]
	        }
	        table.insert(sj, t)
        end
        ltx = ltx.."[logic@" .. gname .. "_gigant_" .. v .. "]\n" ..
                   "active     = mob_home@" .. gname .. "_gigant_" .. v .. "\n" ..

                   "[mob_home@" .. gname .. "_gigant_" .. v .. "]\n" ..
                   "path_home               = home" .. i .. "\n"
    end

    gulags.pri_stadium.ltx = ltx
end

-- States ----------------------------------------------------------------
gulags.pri_stadium.state = function(gulag)
	--local state = gulag.state
	local actor = db.actor
	if actor:has_info("pri_stadium_scene_start") then
	    if actor:has_info("pri_stadium_scene_end") then
	        return 2
	    else
	        return 1
	    end
	else
	    return 0
	end
end

-------------------------------------------------------------------------------------------------------------------------
--printf("gulag <pri>: table -")
--print_table(gulags)
