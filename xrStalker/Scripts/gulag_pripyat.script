
--------------------------------------------------------------------------
-- Member counts
--------------------------------------------------------------------------
local mob_spring_count = 10
local st_snorks_count = 10
local st_tushkanos_count = 8

--------------------------------------------------------------------------
-- States
--------------------------------------------------------------------------
local state_wait  = 0
local state_wave1 = 1
local state_wave2 = 2
local state_wave3 = 3
local state_wave4 = 4
local state_wave5 = 5
local state_wave6 = 6
local state_wave7 = 7
local state_wave8 = 8

local state_zombied_wait  = 0
local state_zombied_scene = 1
local state_zombied_fight = 2
local state_zombied_guard = 3

zombied_in_combat = {}

function is_zombied_in_combat()
    local k, v = 0, 0
    for k,v in pairs(zombied_in_combat) do
        return true
    end
    return false
end

local t = {}
local gulags = {}

--------------------------------------------------------------------------
-- General
--------------------------------------------------------------------------
-- Job -------------------------------------------------------------------
function load_job(sj, gname, type, squad, groups)
    local g = gulags[type]
    if g then
        g[1](sj, gname, type, squad, groups)
    end
end

-- State -----------------------------------------------------------------
function load_states(gname, type)
    local g = gulags[type]

    if g then
        return g[2]
    end

	return nil
end
	    
-- Dynamic ltx -----------------------------------------------------------
function load_ltx(gname, type)
    local g = gulags[type]
    if g and g[4] then
        return g[4](gname, type)
    end

	return nil
end

-- Check communities -----------------------------------------------------
local function checkCommon(npc_community, gulag_type, npc_rank, se_obj, stalker)
    local g = gulags[gulag_type]
    if g then
        if g[3] then
            if type(g[3]) == "function" then
                return g[3](npc_community, gulag_type, npc_rank, se_obj, stalker)
            end

            local i, v = 0, 0
            for i, v in pairs(g[3]) do
                if npc_community == v then
                    return true
                end
            end
            if i > 0 then
                return false
            end
        end
        return true
    end
	return false
end

function checkStalker(npc_community, gulag_type, npc_rank, se_obj)
	return checkCommon(npc_community, gulag_type, npc_rank, se_obj, true)
end

function checkMonster(npc_community, gulag_type, npc_rank, se_obj)
	return checkCommon(npc_community, gulag_type, npc_rank, se_obj, false)
end

local function obj_has_item(data, item_name, def_val)
    local se_obj = data.se_obj
    local t = true

    if def_val then
        t = def_val
    end

    if se_obj.online then
        local obj = level.object_by_id(se_obj.id)
        if obj then
            t = obj:object(item_name) ~= nil
        end
	end

	return t
end

--------------------------------------------------------------------------
-- Predicates
--------------------------------------------------------------------------
function f_predicate1(data)
	return data.profile_name == "pri_followers"
end

function f_predicate2(data)
	return data.profile_name == "pri_followers" and obj_has_item(data, "wpn_rpg7")
end

function f_predicate3(data)
	return data.class_id == clsid.controller_s
end

function f_predicate4(data)
    if data.class_id == clsid.script_stalker or data.class_id == clsid.stalker then
        local prof = data.profile_name
	    return prof == "pri_zombied" or prof == "pri_zombied_veteran"
	end
	return false
end

function f_predicate4_1(data)
    if data.class_id == clsid.script_stalker or data.class_id == clsid.stalker then
        local prof = data.profile_name
	    return prof == "pri_soldier_suicide"
	end
	return false
end

function f_predicate5(data)
	return data.profile_name == "pri_monolith_regular"
end

function f_predicate6(data)
	return data.profile_name == "pri_monolith_specnaz"
end

function f_predicate7(data)
	return data.profile_name == "pri_monolith_exo"
end

function f_predicate8(data)
	return data.profile_name == "pri_monolith_specnaz" and obj_has_item(data, "wpn_rpg7")
end

function f_predicate9(data)
	return data.profile_name == "pri_monolith_specnaz" and obj_has_item(data, "wpn_svd")
end

function f_predicate10(data)
	return data.profile_name == "pri_monolith_exo" and obj_has_item(data, "wpn_rpg7")
end

function st_predicate1(data) -- snorks
    return data.class_id == clsid.snork_s
end

function st_predicate2(data) -- tushkanos
    return data.class_id == clsid.tushkano_s
end

--------------------------------------------------------------------------
-- Gulags
--------------------------------------------------------------------------

--------------------------------------------------------------------------
-- Followers
--------------------------------------------------------------------------
-- Jobs ------------------------------------------------------------------
function load_job_followers(sj, gname, type, squad, groups)
    local i, v, j = 0, 0, 0

    -- gulag members
    local followers = {"leader", "bomber", "nap1", "nap2", "nap3"}

    -- states name
    local states_str = {"wait", "wave1", "wave2", "wave3", "wave4", "wave5", "wave6", "wave7", "wave8"}

    -- states num
    local states = {state_wait, state_wave1, state_wave2, state_wave3, state_wave4, state_wave5, state_wave6, state_wave7, state_wave8}

    -- out restrictors for the each state
    local restr = {"",                              "pri_followers_wave1_out_restr", "pri_followers_wave2_out_restr",
                   "pri_followers_wave3_out_restr", "pri_followers_wave4_out_restr", "pri_followers_wave5_out_restr",
                   "pri_followers_wave6_out_restr", "pri_followers_wave7_out_restr", "pri_followers_wave7_out_restr"}

    -- priorities
    local prior = {{2, 2, 2, 2, 2, 2, 2, 2, 3}, -- leader
                   {3, 3, 3, 3, 3, 3, 3, 3, 2}, -- bomber
                   {1, 1, 1, 1, 1, 1, 1, 1, 1}, -- nap1
                   {1, 1, 1, 1, 1, 1, 1, 1, 1}, -- nap2
                   {1, 1, 1, 1, 1, 1, 1, 1, 1}  -- nap3
                  }
    -- predicates
    local pred = {f_predicate1, f_predicate2, f_predicate1, f_predicate1, f_predicate1}

    local pr, pd
    for i, v in pairs(followers) do
        pr = prior[i]
        pd = pred[i]
        for j = 1, 9 do
	        t = { section = "logic@" .. gname .. "_" .. v .. "_" .. states_str[j],
		        idle = 0,
		        prior = pr[j], state = { states[j] },
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = restr[j],
		        position_threshold = 100,
		        online = true,
		        predicate = pd
	        }
	        table.insert(sj, t)
        end
    end
end

-- States ----------------------------------------------------------------
function check_state_followers(gulag)
	local state = gulag.state
	local actor = db.actor
    --printf("gulag <state>: prip followers check state(%d).", state)
	if state == state_wait and actor:has_info("pri_followers_start") then
		return state_wave1
	end
	if state == state_wave1 and
		actor:has_info("pri_wave1_monolith1_dead") and
		actor:has_info("pri_wave1_monolith2_dead") and
		actor:has_info("pri_wave1_monolith3_dead") --and
		--actor:has_info("pri_wave1_monolith4_dead")
	then
		actor:give_info_portion("pri_wave1_end")
		return state_wave2
	end
	if state == state_wave2 and
		actor:has_info("pri_wave2_monolith1_dead") and
		actor:has_info("pri_wave2_monolith2_dead") and
		--actor:has_info("pri_wave2_monolith3_dead") and
		actor:has_info("pri_wave2_monolith4_dead") and
		--actor:has_info("pri_wave2_monolith5_dead") and
		actor:has_info("pri_wave2_monolith6_dead") --and
		--actor:has_info("pri_wave2_monolith7_dead") and
		--actor:has_info("pri_wave2_monolith8_dead") and
		--actor:has_info("pri_wave2_monolith9_dead")
	then
		actor:give_info_portion("pri_wave2_end")
		--actor:give_info_portion("pri_wave3_end") -- FAKE
		return state_wave3 --4
	end
	if state == state_wave3 and actor:has_info("pri_wave3_btr_dead") then
		actor:give_info_portion("pri_wave3_end")
		return state_wave4
	end
	if state == state_wave4 and
		actor:has_info("pri_wave4_monolith1_dead") and
		actor:has_info("pri_wave4_monolith2_dead") and
		actor:has_info("pri_wave4_monolith3_dead") and
		--actor:has_info("pri_wave4_monolith4_dead") and
		actor:has_info("pri_wave4_monolith5_dead") and
		--actor:has_info("pri_wave4_monolith6_dead") and
		--actor:has_info("pri_wave4_monolith7_dead") and
		actor:has_info("pri_wave4_monolith8_dead")
	then
		actor:give_info_portion("pri_wave4_end")
		return state_wave5
	end
	if state == state_wave5 and
		actor:has_info("pri_wave5_monolith1_dead") and
		actor:has_info("pri_wave5_monolith2_dead") and
		actor:has_info("pri_wave5_monolith3_dead") and
		actor:has_info("pri_wave5_monolith4_dead")
	then
	    --if actor:dont_has_info("pri_wave5_leader_phrase_end") then
		--    actor:give_info_portion("pri_wave5_leader_phrase_start")
		--    return state_wave5
	    --else
		    actor:give_info_portion("pri_wave5_end")
		    return state_wave6
		--end
	end
	if state == state_wave6 and
		--actor:has_info("pri_wave6_monolith1_dead") and
		actor:has_info("pri_wave6_monolith2_dead") and
		actor:has_info("pri_wave6_monolith3_dead")
	then
		actor:give_info_portion("pri_wave6_end")
		return state_wave7
	end
	if state == state_wave7 and
        xr_gulag.getGulagPopulation("pri_ambush7") == 0
    then
        actor:give_info_portion("pri_wave7_end")
        return state_wave8
    end
    return state
end

--------------------------------------------------------------------------
-- Ambush7
--------------------------------------------------------------------------
-- Jobs ------------------------------------------------------------------
function load_job_ambush7(sj, gname, type, squad, groups)
    local i = 0
    for i = 1, 7 do
        --- state 0
	    t = { section = "logic@" .. gname .. "_monolith" .. i .. "_hide", 
		    idle = 0,
		    prior = 1, state = {0}, squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_out_restr"
	    }
	    table.insert(sj, t)
        --- state 1
	    t = { section = "logic@" .. gname .. "_monolith" .. i, 
		    idle = 0,
		    prior = 1, state = {1}, squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_out_restr"
	    }
        table.insert(sj, t)
    end
end

-- States ----------------------------------------------------------------
function check_state_ambush7(gulag)
	if db.actor:has_info("pri_wave7_start") then
        return 1
    else
	    return 0
	end
end

-- Dynamic ltx -----------------------------------------------------------
function load_ltx_ambush7(gname, type)
    local i, res = 0, ""
    
    for i = 1, 7 do
        res = res.."[logic@" .. gname .. "_monolith" .. i .. "_hide]\n" ..
                   "active              = walker@" .. gname .. "_monolith" .. i .. "_hide\n" ..
                   "combat_ignore       = combat_ignore\n" ..

                   "[walker@" .. gname .. "_monolith" .. i .. "_hide]\n" ..
                   "path_walk           = monolith" .. i .. "_hide_walk\n" ..
                   "path_look           = monolith" .. i .. "_hide_look\n" ..
                   "combat_ignore_cond  = always\n" ..
                   "show_spot           = false\n" ..

                   "[logic@" .. gname .. "_monolith" .. i .. "]\n" ..
                   "active              = walker@" .. gname .. "_monolith" .. i .. "\n" ..

                   "[walker@" .. gname .. "_monolith" .. i .. "]\n" ..
                   "path_walk           = monolith" .. i .. "_walk\n" ..
                   "path_look           = monolith" .. i .. "_look\n"
    end
    return res
end

--------------------------------------------------------------------------
-- Wave
--------------------------------------------------------------------------
-- Jobs ------------------------------------------------------------------
function load_job_wave(sj, gname, type, squad, groups)
    local i, j, v = 0, 0, 0

    for i = 1, 10 do
	    t = { section = "logic@" .. gname .. "_monolith" .. i, 
		    idle = 0,
		    prior = 1, state = {0}, squad = squad, group = groups[1],
		    in_rest = "", out_rest = gname .. "_out_restr"
	    }
	    table.insert(sj, t)
    end
end

-- States ----------------------------------------------------------------
function check_state_wave(gulag)
    return 0
end

-- Dynamic ltx -----------------------------------------------------------
function load_ltx_wave(gname, type)
    local i, j, v, res = 0, 0, 0, ""
    local stalk_num = {4, 9, 0, 8, 4, 2}
    
    for i = 1, 7 do
        for j = 1, 7 do
            res = res.."[logic@" .. gname .. "_monolith" .. i .. "]\n" ..
                    "active              = walker@" .. gname .. "_monolith" .. i .. "_hide\n" ..
                    "combat_ignore       = combat_ignore\n" ..

                    "[walker@" .. gname .. "_monolith" .. i .. "_hide]\n" ..
                    "path_walk           = monolith" .. i .. "_hide_walk\n" ..
                    "path_look           = monolith" .. i .. "_hide_look\n" ..
                    "on_info             = {+pri_wave7_start} walker@" .. gname .. "_monolith" .. i .. "\n" ..
                    "combat_ignore_cond  = always\n" ..

                    "[walker@" .. gname .. "_monolith" .. i .. "]\n" ..
                    "path_walk           = monolith" .. i .. "_walk\n" ..
                    "path_look           = monolith" .. i .. "_look\n"
        end
    end
    return res
end

--------------------------------------------------------------------------
-- Corners
--------------------------------------------------------------------------
-- Jobs ------------------------------------------------------------------
function load_job_corner(sj, gname, type, squad, groups)
    local i = 0
    for i = 1, 3 do
	    t = { section = "logic@" .. gname .. "_monolith", 
		    idle = 0,
		    prior = 1, state = {0}, squad = squad, group = groups[1],
		    in_rest = "", out_rest = ""
	    }
	    table.insert(sj, t)
    end
end

-- States ----------------------------------------------------------------
function check_state_corner(gulag)
    return 0
end

-- Dynamic ltx -----------------------------------------------------------
function load_ltx_corner(gname, type)
    local i, res = 0, ""
    
    res = res.."[logic@" .. gname .. "_monolith]\n" ..
               "active              = patrol@" .. gname .. "_monolith_wait\n" ..
               "combat_ignore       = combat_ignore\n" ..

               "[patrol@" .. gname .. "_monolith_wait]\n" ..
               "path_walk           = monolith_wait_walk\n" ..
               "path_look           = monolith_wait_look\n" ..
               "formation           = back\n" ..
               "on_info             = {+pri_corner_start} patrol@" .. gname .. "_monolith_go\n" ..
               "combat_ignore_cond  = always\n" ..

               "[patrol@" .. gname .. "_monolith_go]\n" ..
               "path_walk           = monolith_walk\n" ..
               "path_look           = monolith_look\n" ..
               "on_signal           = arrived | %+pri_corner_end%\n" 
    return res
end

--------------------------------------------------------------------------
-- Zombied
--------------------------------------------------------------------------
-- Jobs ------------------------------------------------------------------
function load_job_zombied(sj, gname, type, squad, groups)
    local i, j, v

    local states_str = {"wait", "scene", "fight", "guard"}
    local logic_str = {"wait", "scene", "fg", "fg"}
    local states = {state_zombied_wait, state_zombied_scene, state_zombied_fight, state_zombied_guard}

    local restr
    for i = 1, 3 do
        for j, v in pairs(states_str) do
	        t = { section = "logic@" .. gname .. "_controller" .. i .. "_" .. v, 
		        idle = 0,
		        prior = 1, state = {states[j]},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = gname .. "_base_restr",
		        predicate = f_predicate3
	        }
	        table.insert(sj, t)
        end
    end

    -- out restrictors for the each state of zombied stalkers
    restr = {gname .. "_base_restr", gname .. "_base_big_restr", "", gname .. "_base_restr"}

    for i = 1, 7 do
        for j, v in pairs(states_str) do
	        t = { section = "logic@" .. gname .. "_soldier" .. i .. "_" .. logic_str[j], 
		        idle = 0,
		        prior = 1, state = {states[j]},
		        squad = squad, group = groups[1],
		        in_rest = "", out_rest = restr[j],
		        predicate = f_predicate4
	        }
	        table.insert(sj, t)
        end
    end
end

-- States ----------------------------------------------------------------
function check_state_zombied(gulag)
	local state = gulag.state
	local actor = db.actor
    if actor:has_info("pri_zombied_scene_start") then
        if actor:dont_has_info("pri_zombied_scene_end") then
            return state_zombied_scene -- suicide scene
        elseif is_zombied_in_combat() then --table.getn(zombied_in_combat) > 0 then
            if state_zombied_fight ~= state then
                printf("gulag <state>: pri_zombied - fight")
            end
            return state_zombied_fight
        else
            if state_zombied_guard ~= state then
                printf("gulag <state>: pri_zombied - guard")
            end
            return state_zombied_guard
        end
    else
        return state_zombied_wait
    end
    return state
end

-- Dynamic ltx -----------------------------------------------------------
function load_ltx_zombied(gname, type)
    local i, res

    res = "[" .. gname .. "_death]\n" ..
          "on_info                 = %=pri_zombied_in_combat_dec%\n" ..

          "[mob_camp@" .. gname .. "_controllers_wait]\n" ..
          "path_look               = controllers_look\n" ..
          "path_home               = controllers_home\n" ..
          "time_change_point       = 10000\n" ..
          "home_min_radius         = 1\n" ..
          "home_max_radius         = 2\n" ..

          "[mob_camp@" .. gname .. "_controllers_scene1]\n" ..
          "path_look               = controllers_look\n" ..
          "path_home               = controllers_home\n" ..
          "time_change_point       = 5000\n" ..
          "home_min_radius         = 1\n" ..
          "home_max_radius         = 2\n" ..
          "on_timer                = 10000 | mob_camp@" .. gname .. "_controllers_scene2\n" ..

          "[mob_camp@" .. gname .. "_controllers_scene2]\n" ..
          "path_look               = controllers_look\n" ..
          "path_home               = controllers_home\n" ..
          "time_change_point       = 5000\n" ..

          "[mob_remark@" .. gname .. "_controllers_fight]\n" ..
          "path_home               = controllers_home\n" ..
          "anim                    = stand_idle_0, stand_idle_1, stand_idle_2, stand_idle_3\n" ..
          "on_actor_dist_le_nvis   = 25 | %=pri_zombied_in_combat_inc%\n" ..
          "on_actor_dist_ge_nvis   = 40 | %=pri_zombied_in_combat_dec%\n" ..

          "[mob_camp@" .. gname .. "_controllers_guard]\n" ..
          "path_look               = controllers_look\n" ..
          "path_home               = controllers_home\n" ..
          "time_change_point       = 10000\n" ..
          "on_actor_dist_le_nvis   = 25 | %=pri_zombied_in_combat_inc%\n" ..
          "on_actor_dist_ge_nvis   = 40 | %=pri_zombied_in_combat_dec%\n"

    for i = 1, 3 do
        res = res.."[logic@" .. gname .. "_controller" .. i .. "_wait]\n" ..
                    "active     = mob_camp@" .. gname .. "_controllers_wait\n" ..

                    "[logic@" .. gname .. "_controller" .. i .. "_scene]\n" ..
                    "active     = mob_camp@" .. gname .. "_controllers_scene1\n" ..

                    "[logic@" .. gname .. "_controller" .. i .. "_fight]\n" ..
                    "active     = mob_remark@" .. gname .. "_controllers_fight\n" ..
                    "mob_death  = " .. gname .. "_death\n" ..

                    "[logic@" .. gname .. "_controller" .. i .. "_guard]\n" ..
                    "active     = mob_camp@" .. gname .. "_controllers_guard\n" ..
                    "mob_death  = " .. gname .. "_death\n"
    end

    res = res.."[combat_zombied]\n" ..
               "combat_type           = zombied\n" ..

               "[danger@zombied]\n" ..
               "ignore_distance_corpse  = 1\n" ..
               "ignore_distance_hit     = 1\n"

    for i = 1, 7 do
        res = res.."[logic@" .. gname .. "_soldier" .. i .. "_wait]\n" ..
                   "active              = walker@" .. gname .. "_soldier" .. i .. "\n" ..
                   "on_combat           = combat_zombied\n" ..
                   "combat_ignore       = combat_ignore\n" ..

                   "[logic@" .. gname .. "_soldier" .. i .. "_scene]\n" ..
                   "active              = walker@" .. gname .. "_soldier" .. i .. "_scene\n" ..
                   "on_combat           = combat_zombied\n" ..
                   "combat_ignore       = combat_ignore\n" ..

                   "[walker@" .. gname .. "_soldier" .. i .. "_scene]\n" ..
                   "path_walk           = scene_walk" .. i .. "\n" ..
                   "on_signal           = arrived | nil\n" ..
                   "combat_ignore_cond  = {=check_fighting(813:814)}\n" ..
                   "danger              = danger@zombied\n" ..

                   "[logic@" .. gname .. "_soldier" .. i .. "_fg]\n" ..
                   "active              = walker@" .. gname .. "_soldier" .. i .. "\n" ..
                   "on_death            = " .. gname .. "_death\n" ..
                   "on_combat           = combat_zombied\n" ..

                   "[walker@" .. gname .. "_soldier" .. i .. "]\n" ..
                   "path_walk             = free" .. i .. "_walk\n" ..
                   "on_actor_dist_le_nvis = 25 | {+pri_zombied_scene_start} %=pri_zombied_in_combat_inc%\n" ..
                   "on_actor_dist_ge_nvis = 40 | {+pri_zombied_scene_start} %=pri_zombied_in_combat_dec%\n" ..
                   "danger                = danger@zombied\n"
--[[
                   "[remark@" .. gname .. "_soldier" .. i .. "]\n" ..
                   "path_walk             = free_walk" .. i .. "\n" ..
                   "anim                  = threat\n" ..
                   "on_actor_dist_le_nvis = 25 | {+pri_zombied_scene_start} %=pri_zombied_in_combat_inc%\n" ..
                   "on_actor_dist_ge_nvis = 40 | {+pri_zombied_scene_start} %=pri_zombied_in_combat_dec%\n" ..
                   "show_spot             = false\n" ..
                   "danger                = danger@zombied\n"
--]]
    end

    return res
end

--------------------------------------------------------------------------
-- Monolith
--------------------------------------------------------------------------
-- Jobs ------------------------------------------------------------------
function load_job_monolith(sj, gname, type, squad, groups)
    local i, j, v, prior, pred

    -- walkers
    prior = {6, 7, 8, 12, 12, 5}
    for i, v in pairs({1, 3, 4, 5, 6, 8}) do
        --- state: main
	    t = { section = "logic@" .. gname .. "_patrol" .. v, 
		    idle = 0,
		    prior = prior[i], state = {0},
		    squad = squad, group = groups[6],
		    in_rest = "pri_snork_nest1_big_restr, pri_snork_nest2_big_restr",
		    out_rest = "",
		    predicate = f_predicate6
	    }
	    table.insert(sj, t)
	end

	-- followers
    prior = {6, 6, 4, 4}
    for i = 1, 2 do
        for j = 1, 2 do
            --- state: main
	        t = { section = "logic@" .. gname .. "_group_patrol" .. i, 
		        idle = 0,
		        prior = prior[i + 2 * (j - 1)], state = {0},
		        squad = squad, group = groups[7],
		        in_rest = "pri_snork_nest1_big_restr, pri_snork_nest2_big_restr",
		        out_rest = "",
		        predicate = f_predicate6
	        }
	        table.insert(sj, t)
	    end
    end

	pred = {f_predicate8, f_predicate9, f_predicate10}
	for i, v in pairs({"rpg", "svd", "machine_gun"}) do
        --- state: main
	    t = { section = "logic@" .. gname .. "_stalker_" .. v, 
		    idle = 0,
		    prior = 14, state = {0},
		    squad = squad, group = groups[8],
		    in_rest = "pri_snork_nest1_big_restr, pri_snork_nest2_big_restr",
		    out_rest = "",
		    predicate = pred[i]
	    }
	    table.insert(sj, t)
	end

    -- kamps
    prior = {{11, 11, 11, 3}, {10, 10, 10, 2}, {11, 11, 11}, {9, 9, 9}, {13, 13, 1}}
    pred = {{f_predicate6, f_predicate6, f_predicate6, f_predicate6},
            {f_predicate6, f_predicate6, f_predicate6, f_predicate6},
            {f_predicate7, f_predicate7, f_predicate7},
            {f_predicate6, f_predicate6, f_predicate6},
            {f_predicate7, f_predicate7, f_predicate6}}
    local pr, pd
	for i, v in pairs({4, 4, 3, 3, 3}) do
	    pr = prior[i]
	    pd = pred[i]
	    for j = 1, v do
            --- state: main
	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_soldier", 
		        idle = 0,
		        prior = pr[j], state = {0},
		        squad = squad, group = groups[5],
		        in_rest = "pri_snork_nest1_big_restr, pri_snork_nest2_big_restr",
		        out_rest = "",
		        predicate = pd[j]
	        }
	        table.insert(sj, t)
	    end
	end

    -- snipers
    for i = 1, 2 do
	    t = { section = "logic@" .. gname .. "_sniper" .. i, 
		    idle = 0,
		    prior = 14, state = {0}, squad = squad, group = groups[9],
		    in_rest = "pri_snork_nest1_big_restr, pri_snork_nest2_big_restr",
		    out_rest = "",
		    predicate = f_predicate9
	    }
	    table.insert(sj, t)
    end
end

-- States ----------------------------------------------------------------
function check_state_monolith(gulag)
    return 0
end

-- Dynamic ltx -----------------------------------------------------------
function load_ltx_monolith(gname, type)
    local i, v, res = 0, 0, ""
    local id
    
    res = "[danger@monolith]\n" ..
          "ignore_distance_sound = 150\n"

    -- alone patrol soldiers
    for i, v in pairs({1, 3, 4, 5, 6, 8}) do
        res = res.."[logic@" .. gname .. "_patrol" .. v .. "]\n" ..
                   "active              = walker@" .. gname .. "_patrol" .. v .. "\n" ..
                   "combat_ignore       = combat_ignore\n" ..

                   "[walker@" .. gname .. "_patrol" .. v .. "]\n" ..
                   "path_walk           = patrol" .. v .. "_walk\n" ..
                   "path_look           = patrol" .. v .. "_look\n" ..
                   "danger              = danger@monolith\n" ..
                   "combat_ignore_cond  = {=pri_monolith_combat_ignore}\n"
    end

    -- group patrol soldiers 7, 10 (9, 13)
    for i, v in pairs({7, 10}) do
        res = res.."[logic@" .. gname .. "_group_patrol" .. i .. "]\n" ..
                   "active              = patrol@" .. gname .. "_group_patrol" .. i .. "\n" ..
                   "combat_ignore       = combat_ignore\n" ..
                   
                   "[patrol@" .. gname .. "_group_patrol" .. i .. "]\n" ..
                   "path_walk           = patrol" .. v .. "_walk\n" ..
                   "path_look           = patrol" .. v .. "_look\n" ..
                   "formation           = line\n" ..
                   "danger              = danger@monolith\n" ..
                   "soundgroup          = " .. gname .."_group_patrol" .. i .. "_sg\n" ..
                   "combat_ignore_cond  = {=pri_monolith_combat_ignore}\n"
    end

    -- rpg, svd, machine-gun
    id = {11, 12, 14}
	for i, v in pairs({"rpg", "svd", "machine_gun"}) do
	    res = res.."[logic@" .. gname .. "_stalker_" .. v .. "]\n" ..
                   "active              = camper@" .. gname .. "_stalker_" .. v .. "\n" ..
                   "combat_ignore       = combat_ignore\n" ..
                   
                   "[camper@" .. gname .. "_stalker_" .. v .. "]\n" ..
                   "path_walk                   = patrol" .. id[i] .. "_walk\n" ..
                   "path_look                   = patrol" .. id[i] .. "_look\n" ..
                   --"no_retreat                  = true\n" ..
                   "radius                      = 5\n" ..
                   "def_state_campering         = threat\n" ..
                   "def_state_campering_fire    = threat_fire\n" ..
                   "danger                      = danger@monolith\n" ..
                   "soundgroup                  = " .. gname .."_rpg_svd_sg\n" ..
                   "combat_ignore_cond          = {=pri_monolith_combat_ignore}\n"
        if i == 2 then
            res = res.."sniper = true\n"
        end
	end

    -- kamps
	for i = 1, 5 do
	    res = res.."[logic@" .. gname .. "_kamp" .. i .. "_soldier]\n" ..
                   "active              = kamp@" .. gname .. "_kamp" .. i .. "_soldier\n" ..
                   "combat_ignore       = combat_ignore\n" ..
                   
                   "[kamp@" .. gname .. "_kamp" .. i .. "_soldier]\n" ..
                   "center_point        = kamp" .. i .. "\n" ..
                   "danger               = danger@monolith\n" ..
                   "def_state_moving    = run\n" ..
                   "soundgroup          = " .. gname .."_kamp" .. i .. "\n" ..
                   "combat_ignore_cond  = {=pri_monolith_combat_ignore}\n"
	end

    -- snipers
    for i = 1, 2 do
        res = res.."[logic@" .. gname .. "_sniper" .. i .. "]\n" ..
                    "active     = camper@" .. gname .. "_sniper" .. i .. "_wait\n" ..

                    "[camper@" .. gname .. "_sniper" .. i .. "_wait]\n" ..
                    "path_walk                  = balcony_sniper" .. i .. "_walk\n" ..
                    "path_look                  = balcony_sniper" .. i .. "_look\n" ..
                    "def_state_campering        = threat\n" ..
                    "def_state_campering_fire   = threat_fire\n" ..
                    "sniper                     = true\n" ..
                    ";no_retreat                = true\n" ..
                    "radius                     = 0\n" ..
                    "on_info                    = {+" .. gname .. "_snipers_free} walker@" .. gname .. "_sniper" .. i .. "_free\n" ..
                    "combat_ignore_cond         = {=pri_monolith_combat_ignore}\n" ..

                    "[walker@" .. gname .. "_sniper" .. i .. "_free]\n" ..
                    "path_walk                  = balcony_sniper" .. i .. "_free_walk\n" ..
                    "path_look                  = balcony_sniper" .. i .. "_free_look\n" ..
                    "on_info                    = {-" .. gname .. "_snipers_free} camper@" .. gname .. "_sniper" .. i .. "_wait\n" ..
                    "combat_ignore_cond         = {=pri_monolith_combat_ignore}\n"
    end

    return res
end

--------------------------------------------------------------------------
-- Stadium
--------------------------------------------------------------------------
-- Jobs ------------------------------------------------------------------
function load_job_stadium(sj, gname, type, squad, groups)
    local i, j, v = 0, 0, 0
    local restr = {"_small_restr", "_kill_restr", "_restr"}
    local logic = {"wait", "heli", "free"}
    for i = 1, 10 do
        for j, v in pairs(restr) do
	        t = { section = "logic@" .. gname .. "_gigant_" .. logic[j],
		        idle = 0,
		        prior = 1, state = {j - 1}, squad = squad, group = groups[1],
		        in_rest = "", out_rest = gname .. v
	        }
	        table.insert(sj, t)
	    end
   end
end

-- States ----------------------------------------------------------------
function check_state_stadium(gulag)
	--local state = gulag.state
	local actor = db.actor
	if actor:has_info("pri_stadium_scene_start") then
	    if actor:has_info("pri_stadium_scene_end") then
	        return 2
	    else
	        return 1
	    end
	else
	    return 0
	end
end

-- Dynamic ltx -----------------------------------------------------------
function load_ltx_stadium(gname, type)
    local i, v = 0, 0
    local res = ""
    local logic = {"wait", "heli", "free"}

    for i, v in pairs(logic) do
	    res = res.."[logic@" .. gname .. "_gigant_" .. v .. "]\n" ..
                   "active     = mob_home@" .. gname .. "_gigant_" .. v .. "\n" ..

                   "[mob_home@" .. gname .. "_gigant_" .. v .. "]\n" ..
                   "path_home               = home" .. i .. "\n" ..
                   ";time_change_point       = 5000\n"
	end
   return res
end


-------------------------------------------------------------------------------------------------------------------------
--                         -- job_func          -- check_state func     -- communities                          -- dynamic ltx func
gulags.pri_followers    = {load_job_followers,  check_state_followers,  {"stalker"}}
gulags.pri_ambush7      = {load_job_ambush7,    check_state_ambush7,    {"monolith"},                           load_ltx_ambush7}
gulags.pri_corner       = {load_job_corner,     check_state_corner,     {"monolith"},                           load_ltx_corner}
gulags.pri_zombied      = {load_job_zombied,    check_state_zombied,    {"zombied", "military", "controller"},  load_ltx_zombied}
gulags.pri_monolith     = {load_job_monolith,   check_state_monolith,   {"monolith"},                           load_ltx_monolith}
gulags.pri_stadium      = {load_job_stadium,    check_state_stadium,    {"pseudo_gigant"},                      load_ltx_stadium}

--printf("gulag <pri>: table -")
--print_table(gulags)
