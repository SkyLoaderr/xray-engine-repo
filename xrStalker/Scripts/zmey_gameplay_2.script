class "SoundSet"
-- Получает набор имен звуковых файлов. Создает звуковые объекты и получает время звучания, которое
-- запоминается.

function SoundSet:__init (is_randomized, ...)
	self.cur_snd = 0
	self.snd_list = {}      -- Список звуков
	self.snd_times = {}     -- Время длительности звуков
	
end

function AnimationSet:add_animation (name, flag, move_type, anim_snd, anim_snd_prob)
	printf ("Add animation %s", name)
	table.insert (self.anims_list, anim (name, flag))
	
	if move_type then
		table.insert (self.move_types_list, move_type)
	else
		table.insert (self.move_types_list, move.stand)
	end
	
	if anim_snd then
		table.insert (self.anim_snd_list, sound (anim_snd, "bip01_head", vector():set(0,0,0), vector():set(0,0,0), false))
	else
		table.insert (self.anim_snd_list, nil)
	end

	if anim_snd_prob then
		table.insert (self.anim_snd_prob_list, anim_snd_prob)
	else
		table.insert (self.anim_snd_prob_list, 100)
	end
end

-- Возвращает следующую в очереди анимацию, движение, звук, вероятность проигрывания звука
function AnimationSet:next_anim()
	local size = table.getn (self.anims_list)
	if size == 0 then
		return nil, 0, nil, 0
	end
	if self.flags == 0 then
		self.current_animation = self.current_animation + 1
		if self.current_animation > size then
			self.current_animation = 1
		end
		printf("AnimationSet:next_anim(): current_animation == %d", self.current_animation)
	else
		self.current_animation = math.random (1, size)
		printf("AnimationSet:next_anim(): current_animation = math.random (1, %d) == %d", size, self.current_animation)
	end
	return self.anims_list[self.current_animation], self.move_types_list[self.current_animation],
	       self.anim_snd_list[self.current_animation], self.anim_snd_prob_list[self.current_animation]
end

-- // УСТАРЕЛА, ИСПОЛЬЗУЙТЕ next_anim()
-- Возвращает следующую в очереди анимацию
function AnimationSet:get_animation ()
	local size = table.getn (self.anims_list)
	if size == 0 then
		return nil
	end
	if self.flags == 0 then
	   self.current_animation = self.current_animation + 1
	   if self.current_animation > size then
		   self.current_animation = 1
	   end
   	   return self.anims_list[self.current_animation]
	end
	self.current_animation = math.random (1, size)
	return self.anims_list[self.current_animation]
end

----------------------------------------------------------------------------------------------------
class "Soldier"

function Soldier:__init(npc_name)
	debug_log(zmey_gameplay_2.script_name(), "Soldier: waiting for get_level_object(\"%s\")...", npc_name)
	self.npc = get_level_object(npc_name)
	debug_log(zmey_gameplay_2.script_name(), "Done")

	-- FINITE STATE MACHINE:
	self.state = self.nothing_happened_yet
end

function Soldier:nothing_happened_yet()
	debug_log(zmey_gameplay_2.script_name(), "Nothing happened yet ... " .. game.time())
end

-- "Мотор" всего класса, должна вызываться периодически
-- Возвращает:
-- 	true, если сценарий все еще выполняется
-- 	false, в случае завершения
function Soldier:heartbeat ()
	if self.state ~= nil then
		self.state()
		return true
	end
	return false
end

----------------------------------------------------------------------------------------------------
function main ()
	debug_script_name = zmey_gameplay_2.script_name()

	debug_log(zmey_gameplay_2.script_name(), "SCRIPT ACTIVATED: zmey_gameplay_2")

	walker = zmey_gameplay_2.Soldier("m_stalker_pes")
	
	while walker:heartbeat() do
		wait()
	end

	walker:script (true, zmey_gameplay_2.script_name())

	debug_log(zmey_gameplay_2.script_name(), "SCRIPT STOPPED: zmey_gameplay_2")
end

----------------------------------------------------------------------------------------------------
