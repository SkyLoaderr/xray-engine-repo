-- Управление вертолётом
-- Чугай Саша

local active = false
local enemy

--------------------------------------------------------------------------------------------------------------------
-- функции для рейда
--------------------------------------------------------------------------------------------------------------------

function activate()
	active = true
end

function deactivate()
	active = false
end

function set_enemy( obj )
	enemy = obj
end

--------------------------------------------------------------------------------------------------------------------
-- класс управления
--------------------------------------------------------------------------------------------------------------------

class "HeliManager"

function HeliManager:__init()
end

function HeliManager:__finalize()
end

function HeliManager:Init()
	self.m_heli       = get_level_object( "heli" )
	self.m_heliObject = self.m_heli:get_helicopter()

	self.m_heli:AddEventCallback( CHelicopter.on_point, self, "HeliOnPoint" )
	self.m_heli:AddEventCallback( CHelicopter.on_hit, self,   "HeliOnHit" )
end

function HeliManager:HeliOnHit( p )
	printf( "HeliOnHit" )
	if self.m_heliObject:GetState() == CHelicopter.eMovingByAttackTraj then
		return --already on attack trajectory
	end

--	format:
	local power      = p:r_float()
	local impulse    = p:r_float()
	local hit_type   = p:r_u32()
	local enemy_name = p:r_stringZ()

	local enemy = level.object( enemy_name )
	if enemy then
		printf( "heli attack %s", enemy:name() )
		self.m_heliObject:SetEnemy( enemy )
		self.m_heliObject:SetDestPosition( enemy:position() )
		self.m_heliObject:SetState( CHelicopter.eMovingByAttackTraj )
		self.m_heliObject:SetCurrVelocity( 30.0 ) -- m/sec (max)
	end
end

function HeliManager:HeliOnPoint(p)
--	format:
--	local dist_to_point =	p:r_float()
--	local point  = p:r_vec3()
--	local path_idx = p:r_s16() ; -- ==-1 if no path moving

	if self.m_heliObject:GetState() == CHelicopter.eMovingToPoint then
		--select next point
	end

	if self.m_heliObject:GetState() == CHelicopter.eMovingByAttackTraj then
		-- если пролетел над позицией врага, то закончить атаку
		self.m_heliObject:GoPatrolByPatrolPath( "way_raid_heli", 0 )  --0==from_idx
		printf( "[heli] attack pass finished" )
--		self.m_heliObject:SetCurrVelocity(35)  -- m/sec (max)
	end
end

function HeliManager:Run()
	self.m_b_exploded        = false
	self.m_b_prepered_to_die = false
	self.m_run               = true

	local state, health, altitude

	while self.m_run do
		state = self.m_heliObject:GetState()

		if state == CHelicopter.eIdleState then
			self.m_heliObject:GoPatrolByPatrolPath( "way_raid_heli", 0 ) --0==from_idx
			self.m_heliObject:SetCurrVelocity( 20.0 ) -- m/sec (max)
		end

		health = self.m_heliObject:GetfHealth()

		if self.m_b_prepered_to_die == false and state ~= CHelicopter.eDead and health < 30.0 then
			self.m_b_prepered_to_die = true
			self.m_heliObject:PrepareDie()
		end

		if state ~= CHelicopter.eDead and health <= 0.0 then
			printf( "[heli] DIE" )
			self.m_heliObject:Die()
		end

		if self.m_b_exploded == false and state == CHelicopter.eDead then
			altitude = self.m_heliObject:GetRealAltitude()

			if altitude < 3.0 then
				self.m_b_exploded = true
				printf("[heli] EXPLODE")
				self.m_heliObject:Explode()
				self.m_heliObject:TurnLighting( true )
				self.m_end_lighting = device():time_global() + 15000
			end
		end

		if self.m_b_exploded and self.m_end_lighting < device():time_global() then
			self.m_heliObject:TurnLighting( false )
			self.m_run = false
		end

		wait()
	end
end

function main()
	local heli_mngr = HeliManager()
	heli_mngr:Init()
	heli_mngr:Run()
end
