-- Управление вертолётом
-- Чугай Саша

local active = false
local enemy

--------------------------------------------------------------------------------------------------------------------
-- функции для рейда
--------------------------------------------------------------------------------------------------------------------

function activate()
	active = true
end

function deactivate()
	active = false
end

function set_enemy( obj )
	enemy = obj
end

--------------------------------------------------------------------------------------------------------------------
-- класс управления
--------------------------------------------------------------------------------------------------------------------

class "HeliManager"

function HeliManager:__init()
end

function HeliManager:__finalize()
end

function HeliManager:Init()
	self.m_heli       = get_level_object( "heli" )
	self.m_heliObject = self.m_heli:get_helicopter()

	self.m_heli:AddEventCallback( CHelicopter.on_point, self, "HeliOnPoint" )
	self.m_heli:AddEventCallback( CHelicopter.on_hit, self,   "HeliOnHit" )
end

function HeliManager:HeliOnHit( p )
	printf( "HeliOnHit" )

	-- количество оставшихся заходов для атаки
	self.attack_passes = 3

	if self.m_heliObject:GetState() == CHelicopter.eMovingByAttackTraj then
		return --already on attack trajectory
	end

--	format:
	local power      = p:r_float()
	local impulse    = p:r_float()
	local hit_type   = p:r_u32()
	local enemy_name = p:r_stringZ()

	enemy = level.object( enemy_name )
	if enemy then
		printf( "[heli] attack %s", enemy_name )
		self.m_heliObject:SetEnemy( enemy )
		self.m_heliObject:SetDestPosition( enemy:position() )
		self.m_heliObject:SetState( CHelicopter.eMovingByAttackTraj )
		self.m_heliObject:SetCurrVelocity( 40.0 ) -- m/sec (max)
	end
end

function HeliManager:HeliOnPoint(p)
--	format:
--	local dist_to_point =	p:r_float()
--	local point  = p:r_vec3()
--	local path_idx = p:r_s16() ; -- ==-1 if no path moving

	if self.m_heliObject:GetState() == CHelicopter.eMovingToPoint then
		--select next point
	end

	-- если пролетел над позицией врага
	if self.m_heliObject:GetState() == CHelicopter.eMovingByAttackTraj then
		if self.attack_passes > 0 then
			if not self.attack_dest_away then
				-- отлетаем чуть-чуть
				self.m_heliObject:SetDestPosition( self.m_heli:position():add( self.m_heli:direction():mul( 100 ) ) )
				self.attack_dest_away = true
				self.attack_passes = self.attack_passes - 1
			else
				-- опять летим на врага
				self.m_heliObject:SetDestPosition( enemy:position() )
				self.attack_dest_away = false
			end
		else
			-- закончить атаку
			self.m_heliObject:GoPatrolByPatrolPath( "way_raid_heli", 0 )  --0==from_idx
			self.attack_dest_away = false
			printf( "[heli] attack finished" )
		end
--		self.m_heliObject:SetCurrVelocity(35)  -- m/sec (max)
	end
end

function HeliManager:Run()
	self.m_b_exploded        = false
	self.m_b_prepered_to_die = false
--	self.m_run               = true

	local state, health, altitude, last_alt, alt_check_time

--	while self.m_run do
	while not self.m_b_exploded do
		state = self.m_heliObject:GetState()

		if state == CHelicopter.eIdleState then
			self.m_heliObject:GoPatrolByPatrolPath( "way_raid_heli", 0 ) --0==from_idx
			self.m_heliObject:SetCurrVelocity( 30.0 ) -- m/sec (max)
		end

		health = self.m_heliObject:GetfHealth()

		if self.m_b_prepered_to_die == false and state ~= CHelicopter.eDead and health < 30.0 then
			self.m_b_prepered_to_die = true
			self.m_heliObject:PrepareDie()
		end

		if state ~= CHelicopter.eDead and health <= 0.0 then
			printf( "[heli] DIE" )
			self.m_heliObject:Die()

			last_alt       = self.m_heliObject:GetRealAltitude()
			alt_check_time = device():time_global() + 1000
		end

		if state == CHelicopter.eDead then
			-- вертолёт должен взорваться, если высота меньше 3 м или он замедлил падение (меньше 1 м за 0.5 с)
			altitude = self.m_heliObject:GetRealAltitude()

			if altitude < 3.0 then
				self.m_b_exploded = true
				printf("[heli] EXPLODE")
				self.m_heliObject:Explode()
--				self.m_heliObject:TurnLighting( true )
--				self.m_end_lighting = device():time_global() + 15000
			end

			if alt_check_time < device():time_global() then
				alt_check_time = device():time_global() + 500

				if last_alt - altitude < 1 then
					self.m_b_exploded = true
					printf("[heli] EXPLODE (hanged)")
					self.m_heliObject:Explode()
--					self.m_heliObject:TurnLighting( true )
--					self.m_end_lighting = device():time_global() + 15000
				end

				last_alt = altitude
			end
		end

--[[		if self.m_b_exploded == false and state == CHelicopter.eDead then
			altitude = self.m_heliObject:GetRealAltitude()

			if altitude < 3.0 then
				self.m_b_exploded = true
				printf("[heli] EXPLODE")
				self.m_heliObject:Explode()
--				self.m_heliObject:TurnLighting( true )
--				self.m_end_lighting = device():time_global() + 15000
			end
		end]]

--[[		if self.m_b_exploded and self.m_end_lighting < device():time_global() then
			self.m_heliObject:TurnLighting( false )
			self.m_run = false
		end]]

		wait()
	end
end

function main()
	local heli_mngr = HeliManager()
	heli_mngr:Init()
	heli_mngr:Run()
end
