----------------------------------------------------------------------------------------------------
-- Mob Jump
----------------------------------------------------------------------------------------------------
-- Разработчик: Jim
----------------------------------------------------------------------------------------------------

local STATE_CAMP					= 1
local STATE_ALIFE					= 2
local STATE_MOVE_HOME				= 3

class "mob_camp"

----------------------------------------------------------------------------------------------------
-- CONSTRUCTION SCHEME
----------------------------------------------------------------------------------------------------
function mob_camp:__init(obj, storage)
	self.object = obj
	self.st		= storage
end

----------------------------------------------------------------------------------------------------
-- RESET SCHEME
----------------------------------------------------------------------------------------------------
function mob_camp:reset_scheme()
    printf("Jump: reset_scheme: %s", self.object:name())
	xr_logic.mob_capture		(self.object, true)

	-- initialize look point
	if self.st.look_point then
		self.look_path = patrol(self.st.look_point)
		if not self.look_path then
			utils.abort("object '%s': unable to find look_point '%s' on the map",
				self.object:name(), self.st.look_point)
		end
	else
		self.look_path = nil
	end

	-- initialize home point
	if self.st.home_point then
		self.home_path = patrol(self.st.home_point)
		if not self.home_path then
			utils.abort("object '%s': unable to find home_point '%s' on the map",
				self.object:name(), self.st.home_point)
		end
	else
		self.home_path = nil
	end

	-- checkings
	if (self.home_path == nil) or (self.look_path == nil) then
		utils.abort("object '%s': you must setup home path and look path!", self.object:name())
	end
	
	if (self.home_path:count() ~= self.look_path:count()) then
		utils.abort("object '%s': you must setup home path points count must be equal to look path points count!", self.object:name())	
	end
	
	

	self.state_current		= STATE_CAMP
	self.state_prev			= self.state_current
	
	self.cur_point_index	= math.random(0, self.home_path:count() - 1)
	self.time_point_changed = device():time_global()
end

----------------------------------------------------------------------------------------------------
-- UPDATE
----------------------------------------------------------------------------------------------------

function mob_camp:update(delta)
	
	if xr_logic.try_switch_to_another_section(self.object, self.st, db.actor) then
		return
	end

	-- update point changer
	if (self.time_point_changed + self.st.time_change_point < device():time_global()) then
		self.cur_point_index	= math.random(0, self.home_path:count() - 1)
		self.time_point_changed = device():time_global()
	end
	
	-- update fsm
	self:select_state	()	
	self:execute_state  ()	

end

----------------------------------------------------------------------------------------------------
-- SERVICE FUNCTIONS
----------------------------------------------------------------------------------------------------
function mob_camp:select_state()

	self.state_prev = self.state_current
		
	-- if enemy
	local enemy = self.object:get_enemy()
	
	
	if enemy ~= nil then
		
		local dist = enemy:position():distance_to(self.home_path:point(self.cur_point_index))
		if (self.state_prev == STATE_MOVE_HOME) and (dist > self.st.home_min_radius) then 
			return 
		elseif (self.state_prev == STATE_ALIFE) and (dist > self.st.home_max_radius) then
			self.state_current = STATE_MOVE_HOME
			return
		elseif (self.state_prev == STATE_CAMP) and (dist > self.st.home_min_radius) then
			return
		else 
			self.state_current = STATE_ALIFE
		end
		
	else -- no enemy
		-- check if we go home
		if (self.home_path ~= nil) and 
			(self.home_path:point(self.cur_point_index):distance_to(self.object:position()) > 1) and
			(self.home_path:level_vertex_id(self.cur_point_index) ~= self.object:level_vertex_id()) then
			self.state_current = STATE_MOVE_HOME
		else 
			-- we are on place - camp!
			self.state_current = STATE_CAMP
		end
					
	end
end

----------------------------------
-- EXECUTE_STATE
function mob_camp:execute_state()
	
	-- DBG
	if (self.state_current ~= self.state_prev) then
		local str1 = ""
		local str2 = ""
		
		if self.state_current == STATE_CAMP then str1 = "STATE_CAMP" end
		if self.state_current == STATE_JUMP then str1 = "STATE_JUMP" end
		if self.state_current == STATE_ALIFE then str1 = "STATE_ALIFE" end
		if self.state_current == STATE_MOVE_HOME then str1 = "STATE_MOVE_HOME" end
		
		if self.state_prev == STATE_CAMP then str2 = "STATE_CAMP" end
		if self.state_prev == STATE_JUMP then str2 = "STATE_JUMP" end
		if self.state_prev == STATE_ALIFE then str2 = "STATE_ALIFE" end
		if self.state_prev == STATE_MOVE_HOME then str2 = "STATE_MOVE_HOME" end
		
		printf("~MOB_CAMP: From [%s] To [%s]", str2, str1)		
	end
		
	
	
	
	if (self.state_current == STATE_ALIFE) and (self.state_prev == STATE_ALIFE) then
		return
	end
	
	if (self.state_current == STATE_ALIFE) and (self.state_prev ~= STATE_ALIFE) then
		xr_logic.mob_release(self.object)
		return
	end

	if (self.state_current ~= STATE_ALIFE) and (self.state_prev == STATE_ALIFE) then
		xr_logic.mob_capture(self.object, true)
	end
	
	
	-- STATE_CAMP
	if self.state_current == STATE_CAMP then
		-- handle look point
		if self.look_path then 
			if not self.object:action() then
				action(	self.object, 
						look(look.point, self.look_path:point(self.cur_point_index)), 
						cond(cond.look_end)
				)
			end
		end
	
		return
	end
	
	-- STATE_MOVE_HOME
	if self.state_current == STATE_MOVE_HOME then
		if not self.object:action() then
			action(	self.object, 
					move(move.run_fwd, 
					self.home_path:level_vertex_id(self.cur_point_index), 
					self.home_path:point(self.cur_point_index), 0.2), 
					cond(cond.move_end))
		end
		return
	end

end

----------------------------------------------------------------------------------------------------
-- ADD_TO_BINDER
----------------------------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
	printf("DEBUG: add_to_binder: npc:name()='%s', scheme='%s', section='%s'", npc:name(), scheme, section)

	local new_action = mob_camp(npc, storage)

	-- Зарегистрировать все actions, в которых должен быть вызван метод reset_scheme при изменении настроек схемы:
	xr_logic.subscribe_action_for_events(npc, storage, new_action)
end

----------------------------------------------------------------------------------------------------
-- SET_SCHEME
----------------------------------------------------------------------------------------------------

function set_scheme(npc, ini, scheme, section, gulag_name)
	local storage				= xr_logic.assign_storage_and_bind(npc, ini, scheme, section)

	storage.logic				= xr_logic.cfg_get_switch_conditions(ini, section, npc)
	
	storage.look_point			= utils.cfg_get_string(ini, section, "path_look",			npc, false, gulag_name)
	storage.home_point			= utils.cfg_get_string(ini, section, "path_home",			npc, false, gulag_name)
	storage.time_change_point	= utils.cfg_get_number(ini, section, "time_change_point",	npc, false, 10000)
	storage.home_min_radius		= utils.cfg_get_number(ini, section, "home_min_radius",		npc, false, 30)
	storage.home_max_radius		= utils.cfg_get_number(ini, section, "home_max_radius",		npc, false, 40)
	
	if	storage.home_min_radius > storage.home_max_radius then
		utils.abort("Mob_Camp : Home Min Radius MUST be < Max Radius")
	end 
end

