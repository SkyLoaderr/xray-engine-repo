
--------------------------------------------------------------------------
-- Member counts
--------------------------------------------------------------------------
local bandits_kamp_count = 6

--------------------------------------------------------------------------
-- States
--------------------------------------------------------------------------


--------------------------------------------------------------------------
-- General
--------------------------------------------------------------------------
local gulags = {}

-- Job -------------------------------------------------------------------
function load_job(sj, gname, type, squad, groups)
    local g = gulags[type]
    if g then
        g[1](sj, gname, type, squad, groups)
    end
end

-- State -----------------------------------------------------------------
function load_states(gname, type)
    local g = gulags[type]

    if g then
        return g[2]
    end

	return nil
end
	    
-- Dynamic ltx -----------------------------------------------------------
function load_ltx(gname, type)
    local g = gulags[type]
    if g and g[4] then
        return g[4](gname, type)
    end

	return nil
end

-- Check communities -----------------------------------------------------
local function checkCommon(npc_community, g)
    local not_exist = true
    local i, v

    for i, v in pairs(g[3]) do
        if npc_community == v then
            return true
        end
        not_exist = false
    end

    return not_exist
end

function checkStalker(npc_community, gulag_type)
    local g = gulags[gulag_type]
    if g then
        return checkCommon(npc_community, g)
    end

	return false
end

function checkMonster(npc_community, gulag_type)
    local g = gulags[gulag_type]
    if g then
        return checkCommon(npc_community, g)
    end

    return false
end


--------------------------------------------------------------------------
-- Gulags
--------------------------------------------------------------------------

--------------------------------------------------------------------------
-- Killers
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function k_predicate_e(obj)
	return obj:profile_name() == "cit_killer_exo"
end

function k_predicate_v(obj)
	return obj:profile_name() == "cit_killer_veteran"
end

function k_predicate_g(obj)
	return obj:profile_name() == "cit_killer_general"
end

function k_predicate_n(obj)
	return obj:profile_name() == "cit_killer_nauchniy"
end

-- Jobs ------------------------------------------------------------------
function load_job_killers(sj, gname, type, squad, groups)
    local t = 0
    local i, v, j = 0, 0, 0
    local prior, pred, gr = 0, 0, 0

    -- leader
	t = { section = "logic@" .. gname .. "_leader",
		idle = 0,
		prior = 15, state = {0},
		squad = squad, group = groups[5],
		in_rest = "", out_rest = "",
		predicate = k_predicate_e
	}
	table.insert(sj, t)

    -- jail guard
	t = { section = "logic@" .. gname .. "_jail_guard",
		idle = 0,
		prior = 13, state = {0},
		squad = squad, group = groups[5],
		in_rest = "", out_rest = "",
		predicate = k_predicate_v
	}
	table.insert(sj, t)

    -- base guard
	t = { section = "logic@" .. gname .. "_base_guard",
		idle = 0,
		prior = 12, state = {0},
		squad = squad, group = groups[6],
		in_rest = "", out_rest = "",
		predicate = k_predicate_v
	}
	table.insert(sj, t)

    -- base patrols
    for i = 1, 2 do
	    t = { section = "logic@" .. gname .. "_base_patrol" .. i,
		    idle = 0,
		    prior = 11, state = {0},
		    squad = squad, group = groups[6],
		    in_rest = "", out_rest = "",
		    predicate = k_predicate_v
	    }
	    table.insert(sj, t)
    end

    -- walkers between kamps
    for i = 1, 2 do
	    t = { section = "logic@" .. gname .. "_free" .. i .. "_in_kamp",
		    idle = 0,
		    prior = 9, state = {0},
		    squad = squad, group = groups[6],
		    in_rest = "", out_rest = "",
		    predicate = k_predicate_e
	    }
	    table.insert(sj, t)
    end

    -- patrols in kamp
    prior = {3, 5, 7}
    local kamps = {1, 2, 4}
    for i, v in pairs({2, 1, 2}) do
        for j = 1, v do
	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_patrol",
		        idle = 0,
		        prior = prior[i], state = {0},
		        squad = squad, group = groups[kamps[i]],
		        in_rest = "", out_rest = "",
		        predicate = k_predicate_g
	        }
	        table.insert(sj, t)
	    end
    end

    -- free stalkers
    for i = 1, 4 do
	    t = { section = "logic@" .. gname .. "_free_stalker" .. i,
		    idle = 0,
		    prior = 14, state = {0},
		    squad = squad, group = groups[5],
		    in_rest = "", out_rest = "",
		    predicate = k_predicate_e
	    }
	    table.insert(sj, t)
    end

    -- kamps
    prior = {2, 4, 1, 6}
    for i, v in pairs({2, 2, 3, 2}) do
        for j = 1, v do
	        t = { section = "logic@" .. gname .. "_kamp" .. i,
		        idle = 0,
		        prior = prior[i], state = {0},
		        squad = squad, group = groups[i],
		        in_rest = "", out_rest = "",
		        predicate = k_predicate_v
	        }
	        table.insert(sj, t)
        end
    end

    -- gate guards
    pred = {k_predicate_e, k_predicate_v}
    for i = 1, 2 do
	    t = { section = "logic@" .. gname .. "_gate2_guard" .. i,
		    idle = 0,
		    prior = 8, state = {0},
		    squad = squad, group = groups[7 + i],
		    in_rest = "", out_rest = "",
		    predicate = pred[i]
	    }
	    table.insert(sj, t)
    end

    -- road patrols
    for i = 1, 3 do
	    t = { section = "logic@" .. gname .. "_road_patrol" .. i,
		    idle = 0,
		    prior = 10, state = {0},
		    squad = squad, group = groups[7],
		    in_rest = "", out_rest = "",
		    predicate = k_predicate_v
	    }
	    table.insert(sj, t)
    end
end

-- States ----------------------------------------------------------------
function check_state_killers(gulag)
    return 0
end

-- Dynamic ltx -----------------------------------------------------------
function load_ltx_killers(gname, type)
    local i, j, res = 0, 0, ""

    -- leader
	res = res.."[logic@" .. gname .. "_leader]\n" ..
               "active      = walker@" .. gname .. "_leader\n" ..
               "combat_ignore   = combat_ignore\n" ..

               "[walker@" .. gname .. "_leader]\n" ..
               "path_walk  = leader_walk\n" ..
               "path_look  = leader_look\n" ..
               "combat_ignore_cond  = always\n"

    -- jail guard
	res = res.."#include \"scripts\\cit\\cit_jail_guard1.ltx\"\n"

    -- base guard
	res = res.."#include \"scripts\\cit\\cit_jail_guard2.ltx\"\n"

    -- base patrols
    for i = 1, 2 do
	    res = res.."[logic@" .. gname .. "_base_patrol" .. i .. "]\n" ..
                   "active      = walker@" .. gname .. "_base_patrol" .. i .. "\n" ..
                   "combat_ignore   = combat_ignore\n" ..

                   "[walker@" .. gname .. "_base_patrol" .. i .. "]\n" ..
                   "path_walk  = base_patrol" .. i .. "_walk\n" ..
                   "path_look  = base_patrol" .. i .. "_look\n" ..
                   "combat_ignore_cond  = always\n"
    end

    -- walkers between kamps
    local start_kamp = {1, 2}
    local kamp_change = {{2, 3, 1}, {4, 3, 2}}
    local delays = {{18, 30, 20}, {25, 40, 20}}
    local d, kc = 0, 0

    for i = 1, 2 do
        d = delays[i]
        kc = kamp_change[i]
        res = res.."[logic@" .. gname .. "_free" .. i .. "_in_kamp]\n" ..
                   "active          = walker@" .. gname .. "_free" .. i .. "_to_kamp" .. start_kamp[i] .. "\n" ..
                   "combat_ignore   = combat_ignore\n"

        for j, v in pairs(kc) do
            res = res.."[walker@" .. gname .. "_free" .. i .. "_to_kamp" .. j .. "]\n" ..
                       "path_walk           = near_kamp" .. j .. "_walk\n" ..
                       "path_look           = kamp" .. j .. "\n" ..
                       "def_state_moving1   = patrol\n" ..
                       "def_state_moving2   = patrol\n" ..
                       "def_state_moving3   = patrol\n" ..
                       "on_signal           = arrived | kamp@" .. gname .. "_free" .. i .. "_in_kamp" .. j .. "\n" ..
                       "combat_ignore_cond  = always\n" ..

                       "[kamp@" .. gname .. "_free" .. i .. "_in_kamp" .. j .. "]\n" ..
                       "center_point        = kamp" .. j .. "\n" ..
                       "def_state_moving    = patrol\n" ..
                       "on_timer            = " .. d[j] .. "000 | walker@" .. gname .. "_free" .. i .. "_to_kamp" .. v .. "\n" ..
                       "combat_ignore_cond  = always\n"
        end
    end

    -- patrols in kamp
    delays = {40, 30, 60}
    for i, v in pairs({1, 2, 4}) do
	    res = res.."[logic@" .. gname .. "_kamp" .. i .. "_patrol]\n" ..
                   "active      = patrol@" .. gname .. "_kamp" .. i .. "_patrol\n" ..
                   "combat_ignore   = combat_ignore\n" ..

                   "[patrol@" .. gname .. "_kamp" .. i .. "_patrol]\n" ..
                   "path_walk  = kamp" .. v .. "_patrol_walk\n" ..
                   --"path_look  = kamp" .. v .. "\n" ..
                   "formation  = line\n" ..
                   "on_signal  = arrived | kamp@" .. gname .. "_kamp" .. v .. "_patrol\n" ..
                   "combat_ignore_cond  = always\n" ..

                   "[kamp@" .. gname .. "_kamp" .. v .. "_patrol]\n" ..
                   "center_point        = kamp" .. v .. "\n" ..
                   "on_timer            = " .. delays[i] .. "000 | patrol@" .. gname .. "_kamp" .. i .. "_patrol\n" ..
                   "combat_ignore_cond  = always\n"
    end

    -- free stalkers
    for i = 1, 4 do
        res = res.."[logic@" .. gname .. "_free_stalker" .. i .. "]\n" ..
                   "active          = walker@" .. gname .. "_free_stalker" .. i .. "\n" ..
                   "combat_ignore   = combat_ignore\n" ..

                   "[walker@" .. gname .. "_free_stalker" .. i .. "]\n" ..
                   "path_walk           = free_stalker" .. i .. "_walk\n" ..
                   "path_look           = free_stalker" .. i .. "_look\n" ..
                   "combat_ignore_cond  = always\n"
    end

    -- kamps
    for i = 1, 4 do
        res = res.."[logic@" .. gname .. "_kamp" .. i .. "]\n" ..
                   "active          = kamp@" .. gname .. "_kamp" .. i .. "\n" ..
                   "combat_ignore   = combat_ignore\n" ..

                   "[kamp@" .. gname .. "_kamp" .. i .. "]\n" ..
                   "center_point        = kamp" .. i .. "\n" ..
                   "combat_ignore_cond  = always\n"
    end
    
    -- gate guards
    for i = 1, 2 do
	    res = res.."[logic@" .. gname .. "_gate2_guard" .. i .. "]\n" ..
                   "active      = walker@" .. gname .. "_gate2_guard" .. i .. "\n" ..
                   "combat_ignore   = combat_ignore\n" ..

                   "[walker@" .. gname .. "_gate2_guard" .. i .. "]\n" ..
                   "path_walk  = gate2_guard" .. i .. "_walk\n" ..
                   "path_look  = gate2_guard" .. i .. "_look\n" ..
                   "combat_ignore_cond  = always\n"
    end

    -- road patrols
    for i = 1, 3 do
	    res = res.."[logic@" .. gname .. "_road_patrol" .. i .. "]\n" ..
                   "active              = walker@" .. gname .. "_road_patrol" .. i .. "\n" ..
                   "combat_ignore   = combat_ignore\n" ..

                   "[walker@" .. gname .. "_road_patrol" .. i .. "]\n" ..
                   "path_walk           = road_patrol" .. i .. "_walk\n" ..
                   "path_look           = road_patrol" .. i .. "_look\n" ..
                   "def_state_moving1   = patrol\n" ..
                   "def_state_moving2   = patrol\n" ..
                   "def_state_moving3   = patrol\n" ..
                   "combat_ignore_cond  = always\n"
    end

    return res
end


--------------------------------------------------------------------------
-- Followers
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function b_predicate_vb(obj)
	return obj:profile_name() == "cit_bandit_veteran_best"
end

function b_predicate_v(obj)
	return obj:profile_name() == "cit_bandit_veteran"
end

function b_predicate_g(obj)
	return obj:profile_name() == "cit_bandit_general"
end

function b_predicate_d(obj)
	return obj:profile_name() == "cit_bandit_drunk"
end

-- Jobs ------------------------------------------------------------------
function load_job_bandits(sj, gname, type, squad, groups)
    local t = 0
    local i, v, j = 0, 0, 0
    local prior, pred, gr = 0, 0, 0

    -- leader
	t = { section = "logic@" .. gname .. "_leader",
		idle = 0,
		prior = 17, state = {0},
		squad = squad, group = groups[6],
		in_rest = "", out_rest = "",
		predicate = b_predicate_vb
	}
	table.insert(sj, t)

    -- leader guards
    for i, v in pairs({16, 15}) do
	    t = { section = "logic@" .. gname .. "_leader_guard" .. i,
		    idle = 0,
		    prior = v, state = {0},
		    squad = squad, group = groups[6],
		    in_rest = "", out_rest = "",
		    predicate = b_predicate_vb
	    }
	    table.insert(sj, t)
    end

    -- walkers between kamps
    for i = 1, 3 do
	    t = { section = "logic@" .. gname .. "_free" .. i .. "_in_kamp",
		    idle = 0,
		    prior = 9, state = {0},
		    squad = squad, group = groups[11],
		    in_rest = "", out_rest = "",
		    predicate = b_predicate_v
	    }
	    table.insert(sj, t)
    end

    -- patrols in kamp
    prior = {9, 4, 6}
    local kamps = {1, 3, 4}
    for i, v in pairs({2, 1, 1}) do
        for j = 1, v do
	        t = { section = "logic@" .. gname .. "_kamp" .. i .. "_patrol",
		        idle = 0,
		        prior = prior[i], state = {0},
		        squad = squad, group = groups[kamps[i]],
		        in_rest = "", out_rest = "",
		        predicate = b_predicate_v
	        }
	        table.insert(sj, t)
	    end
    end

    -- kamps
    prior = {8, 3, 4, 5, 2}
    for i, v in pairs({2, 3, 2, 2, 3}) do
        for j = 1, v do
	        t = { section = "logic@" .. gname .. "_kamp" .. i,
		        idle = 0,
		        prior = prior[i], state = {0},
		        squad = squad, group = groups[i],
		        in_rest = "", out_rest = "",
		        predicate = b_predicate_g
	        }
	        table.insert(sj, t)
        end
    end

    -- base guards
    pred = {b_predicate_vb, b_predicate_v}
    for i, v in pairs({13, 14}) do
	    t = { section = "logic@" .. gname .. "_base_guard" .. i,
		    idle = 0,
		    prior = v, state = {0},
		    squad = squad, group = groups[7],
		    in_rest = "", out_rest = "",
		    predicate = pred[i]
	    }
	    table.insert(sj, t)
    end

    -- patrol in center
    for i = 1, 2 do
	    t = { section = "logic@" .. gname .. "_center_patrol",
		    idle = 0,
		    prior = 10, state = {0},
		    squad = squad, group = groups[8],
		    in_rest = "", out_rest = "",
		    predicate = b_predicate_v
	    }
	    table.insert(sj, t)
    end

    -- gate guards
    prior = {12, 7}
    pred = {b_predicate_vb, b_predicate_v}
    gr = {10, 9}
    for i, v in pairs({3, 2}) do
        for j = 1, v do
	        t = { section = "logic@" .. gname .. "_gate" .. i .. "_guard" .. j,
		        idle = 0,
		        prior = prior[i], state = {0},
		        squad = squad, group = groups[gr[i]],
		        in_rest = "", out_rest = "",
		        predicate = pred[i]
	        }
	        table.insert(sj, t)
        end
    end

    -- drunken
    for i = 1, 2 do
	    t = { section = "logic@" .. gname .. "_drunken" .. i,
		    idle = 0,
		    prior = 1, state = {0},
		    squad = squad, group = groups[12],
		    in_rest = "", out_rest = "",
		    predicate = b_predicate_d
	    }
	    table.insert(sj, t)
    end
end

-- States ----------------------------------------------------------------
function check_state_bandits(gulag)
    return 0
end

-- Dynamic ltx -----------------------------------------------------------
function load_ltx_bandits(gname, type)
    local i, j, res = 0, 0, ""

    -- leader
	res = res.."[logic@" .. gname .. "_leader]\n" ..
               "active              = walker@" .. gname .. "_leader\n" ..
               "combat_ignore       = combat_ignore\n" ..

               "[walker@" .. gname .. "_leader]\n" ..
               "path_walk           = leader_walk\n" ..
               "path_look           = leader_look\n" ..
               "combat_ignore_cond  = always\n"

    -- leader guards
    for i = 1, 2 do
	    res = res.."[logic@" .. gname .. "_leader_guard" .. i .. "]\n" ..
                   "active              = walker@" .. gname .. "_leader_guard" .. i .. "\n" ..
                   "combat_ignore       = combat_ignore\n" ..

                   "[walker@" .. gname .. "_leader_guard" .. i .. "]\n" ..
                   "path_walk           = leader_guard" .. i .. "_walk\n" ..
                   "path_look           = leader_guard" .. i .. "_look\n" ..
                   "combat_ignore_cond  = always\n"
    end

    -- walkers between kamps
    local start_kamp = {1, 3, 5}
    local kamp_change = {{3, 2, 5, 4, 1}, {1, 4, 2, 5, 3}, {3, 4, 1, 2, 5}}
    local delays = {{20, 30, 24, 22, 28}, { 25, 10, 14, 26, 12}, {11, 17, 19, 24, 13}}
    local d, kc = 0, 0

    for i = 1, 3 do
        d = delays[i]
        kc = kamp_change[i]
        res = res.."[logic@" .. gname .. "_free" .. i .. "_in_kamp]\n" ..
                   "active          = walker@" .. gname .. "_free" .. i .. "_to_kamp" .. start_kamp[i] .. "\n" ..
                   "combat_ignore   = combat_ignore\n"
        for j, v in pairs(kc) do
            res = res.."[walker@" .. gname .. "_free" .. i .. "_to_kamp" .. j .. "]\n" ..
                       "path_walk           = near_kamp" .. j .. "_walk\n" ..
                       "path_look           = kamp" .. j .. "\n" ..
                       "def_state_moving1   = patrol\n" ..
                       "def_state_moving2   = patrol\n" ..
                       "def_state_moving3   = patrol\n" ..
                       "on_signal           = arrived | kamp@" .. gname .. "_free" .. i .. "_in_kamp" .. j .. "\n" ..
                       "combat_ignore_cond  = always\n" ..

                       "[kamp@" .. gname .. "_free" .. i .. "_in_kamp" .. j .. "]\n" ..
                       "center_point        = kamp" .. j .. "\n" ..
                       "def_state_moving    = patrol\n" ..
                       "on_timer            = " .. d[j] .. "000 | walker@" .. gname .. "_free" .. i .. "_to_kamp" .. v .. "\n" ..
                       "combat_ignore_cond  = always\n"
        end
    end

    -- patrols in kamp
    delays = {40, 30, 60}
    for i, v in pairs({1, 3, 4}) do
	    res = res.."[logic@" .. gname .. "_kamp" .. i .. "_patrol]\n" ..
                   "active      = patrol@" .. gname .. "_kamp" .. i .. "_patrol\n" ..
                   "combat_ignore   = combat_ignore\n" ..

                   "[patrol@" .. gname .. "_kamp" .. i .. "_patrol]\n" ..
                   "path_walk  = kamp" .. v .. "_patrol_walk\n" ..
                   --"path_look  = kamp" .. v .. "\n" ..
                   "formation  = line\n" ..
                   "on_signal  = arrived | kamp@" .. gname .. "_kamp" .. v .. "_patrol\n" ..
                   "combat_ignore_cond  = always\n" ..

                   "[kamp@" .. gname .. "_kamp" .. v .. "_patrol]\n" ..
                   "center_point        = kamp" .. v .. "\n" ..
                   "on_timer            = " .. delays[i] .. "000 | patrol@" .. gname .. "_kamp" .. i .. "_patrol\n" ..
                   "combat_ignore_cond  = always\n"
    end

    -- kamps
    for i = 1, 5 do
        res = res.."[logic@" .. gname .. "_kamp" .. i .. "]\n" ..
                   "active          = kamp@" .. gname .. "_kamp" .. i .. "\n" ..
                   "combat_ignore   = combat_ignore\n" ..

                   "[kamp@" .. gname .. "_kamp" .. i .. "]\n" ..
                   "center_point        = kamp" .. i .. "\n" ..
                   "combat_ignore_cond  = always\n"
    end
    
    -- base guards
    for i = 1, 2 do
	    res = res.."[logic@" .. gname .. "_base_guard" .. i .. "]\n" ..
                   "active          = walker@" .. gname .. "_base_guard" .. i .. "\n" ..
                   "combat_ignore   = combat_ignore\n" ..

                   "[walker@" .. gname .. "_base_guard" .. i .. "]\n" ..
                   "path_walk           = base_guard" .. i .. "_walk\n" ..
                   --"path_look           = base_guard" .. i .. "_look\n" ..
                   "combat_ignore_cond  = always\n"
    end

    -- patrol in center
	res = res.."[logic@" .. gname .. "_center_patrol]\n" ..
               "active      = patrol@" .. gname .. "_center_patrol\n" ..
               "combat_ignore   = combat_ignore\n" ..

               "[patrol@" .. gname .. "_center_patrol]\n" ..
               "path_walk  = center_patrol_walk\n" ..
               --"path_look  = center_patrol_look\n" ..
               "formation  = line\n" ..
               "combat_ignore_cond  = always\n"

    -- gate guards
    for i, v in pairs({3, 2}) do
        for j = 1, v do
	        res = res.."[logic@" .. gname .. "_gate" .. i .. "_guard" .. j .. "]\n" ..
                       "active      = walker@" .. gname .. "_gate" .. i .. "_guard" .. j .. "\n" ..
                       "combat_ignore   = combat_ignore\n" ..

                       "[walker@" .. gname .. "_gate" .. i .. "_guard" .. j .. "]\n" ..
                       "path_walk  = gate" .. i .. "_guard" .. j .. "_walk\n" ..
                       "path_look  = gate" .. i .. "_guard" .. j .. "_look\n" ..
                       "combat_ignore_cond  = always\n"
        end
    end

    -- drunken
    for i = 1, 2 do
	    res = res.."[logic@" .. gname .. "_drunken" .. i .. "]\n" ..
                   "active          = walker@" .. gname .. "_drunken" .. i .. "\n" ..
                   "combat_ignore   = combat_ignore\n" ..

                   "[walker@" .. gname .. "_drunken" .. i .. "]\n" ..
                   "path_walk           = drunken" .. i .. "_walk\n" ..
                   --"path_look           = drunken" .. i .. "_look\n"..
                   "def_state_moving1   = walk\n" ..
                   "def_state_moving2   = walk\n" ..
                   "def_state_moving3   = walk\n" ..
                   "combat_ignore_cond  = always\n"
    end

    return res
end


-------------------------------------------------------------------------------------------------------------------------
--                         -- job_func          -- check_state func     -- communities  -- dynamic ltx func
gulags.cit_bandits      = {load_job_bandits,    check_state_bandits,    {"bandit"},     load_ltx_bandits}
gulags.cit_killers      = {load_job_killers,    check_state_killers,    {"killer"},     load_ltx_killers}

--printf("gulag <pri>: table -")
--print_table(gulags)
