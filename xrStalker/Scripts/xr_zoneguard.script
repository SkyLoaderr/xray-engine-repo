----------------------------------------------------------------------------------------------------
-- Охранники
----------------------------------------------------------------------------------------------------
-- Разработчик: Andrey Fidrya (Zmey) af@svitonline.com
----------------------------------------------------------------------------------------------------

teams = {}

local state_none = 0
local state_walking = 1
local state_going_to_plr = 2
local state_standing = 3

----------------------------------------------------------------------------------------------------------------------
class "evaluator_need_zoneguard" (property_evaluator)

function evaluator_need_zoneguard:__init(storage) super()
	self.st = storage
end

function evaluator_need_zoneguard:evaluate()
	if not self.st.team then
		return false
	end

	if not teams[self.st.team] then
		teams[self.st.team] = {}
	end
	
	return self.st.enabled == true
end

---------------------------------------------------------------------------------------------------------------------
class "action_zoneguard_activity" (action_base)

function action_zoneguard_activity:__init(npc_name, action_name, storage) super(nil, action_name)
	self.st = storage
	self.move_mgr = move_mgr.move_mgr()
end

function action_zoneguard_activity:initialize()
	--printf("_bp: action_zoneguard_activity: initialize")
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()

	--xr_reactions.add_rule(self.object, "ignore")

	self.move_mgr:initialize(self.object)

	self.initialized = true

	self:reset_scheme()
end

function action_zoneguard_activity:reset_scheme()
	if not self.initialized then
		return
	end

	self:reset_trigger()

	self.object:clear_animations()
	
	if self.st.path_walk_info == nil then
		self.st.path_walk_info = utils.path_parse_waypoints(self.st.path_walk)
	end
	if self.st.path_look_info == nil then
		self.st.path_look_info = utils.path_parse_waypoints(self.st.path_look)
	end

	self.zone_guard_obj = level.object(self.st.zone_guard)
	if not self.zone_guard_obj then
		utils.abort("object '%s': unable to find zone_guard '%s' on the map",
			self.object:name(), self.st.zone_guard)
	end

	self.zone_warn_obj = level.object(self.st.zone_warn)
	if not self.zone_warn_obj then
		utils.abort("object '%s': unable to find zone_warn '%s' on the map",
			self.object:name(), self.st.zone_warn)
	end

	self.move_mgr:reset(self.st.path_walk, self.st.path_walk_info, self.st.path_look, self.st.path_look_info, self.st.team)

	self.state = state_walking
end	

function action_zoneguard_activity:reset_trigger()
	local who_triggered = teams[self.st.team].triggered
	if who_triggered and who_triggered == self.object:id() then
		teams[self.st.team].triggered = nil
	end
end

function action_zoneguard_activity:execute()
	action_base.execute(self)

	local actor = level.actor()
	if not actor then
		return
	end
	
	if self.state == state_walking then
		if self.object:see(actor) and xr_zones.is_in_zone(actor, self.zone_warn_obj:id()) and
				teams[self.st.team].triggered == nil then
			self.object:set_path_type(game_object.level_path)
			self.object:set_desired_direction(actor:direction())
			self.object:set_dest_level_vertex_id(actor:level_vertex_id())
			self.object:set_movement_type(move.run)
			self.object:set_mental_state(anim.danger)
			utils.stalker_look_at_stalker(self.object, actor)

			teams[self.st.team].triggered = self.object:id()
			self.state = state_going_to_plr
		else
			self.move_mgr:update()
		end
		return
	end

	if self.state ~= state_walking and not xr_zones.is_in_zone(actor, self.zone_warn_obj:id()) then
		self.move_mgr:reset(self.st.path_walk, self.st.path_walk_info,
				self.st.path_look, self.st.path_look_info, self.st.team)
		self:reset_trigger()
		self.state = state_walking
		return
	end

	self.object:set_item(object.idle, self.object:best_weapon())
	utils.stalker_look_at_stalker(self.object, actor)

	if self.state == state_standing then
		if distance_between(self.object, actor) >= 4 then
			self.object:set_movement_type(move.run)
			self.object:set_desired_direction(actor:direction())
			self.object:set_dest_level_vertex_id(actor:level_vertex_id())
			self.state = state_going_to_plr
		end
		return
	end

	if self.state == state_going_to_plr then
		if distance_between(self.object, actor) >= 3 then
			self.object:set_movement_type(move.run)
			self.object:set_desired_direction(actor:direction())
			self.object:set_dest_level_vertex_id(actor:level_vertex_id())
		else
			self.object:set_movement_type(move.stand)
			self.state = state_standing
		end
		return
	end
end

function action_zoneguard_activity:finalize()
	self:reset_trigger()
	self.move_mgr:finalize()
	self.object:clear_animations()
	action_base.finalize(self)
end

---------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, char_ini)
	if char_ini == nil or char_ini:section_exist ("zoneguard") == true then
		local operators    = {}
		local properties  = {}

		npc:add_sound("Scripts\\trader\\pryach_orujie", 20, snd_type.talk, 2, 1, xr_sounds_id.zmey_zoneguard_base)

		local manager = npc:motivation_action_manager()

		properties["need_zoneguard"] = xr_evaluators_id.zmey_zoneguard_base + 1
		operators["action_zoneguard"]  = xr_actions_id.zmey_zoneguard_base + 1

		-- // evaluators
		manager:add_evaluator(properties["need_zoneguard"],
			this.evaluator_need_zoneguard(xr_motivator.storage[npc:id()].zoneguard))

		local new_action = this.action_zoneguard_activity(npc, "action_zoneguard_activity",
			xr_motivator.storage[npc:id()].zoneguard)
		new_action:add_precondition(world_property(stalker_ids.property_alive, true))
		new_action:add_precondition(world_property(stalker_ids.property_enemy, false))
		new_action:add_precondition(world_property(properties["need_zoneguard"], true))
		new_action:add_effect(world_property(properties["need_zoneguard"], false))
		manager:add_action(operators["action_zoneguard"], new_action)

		new_action = manager:action(stalker_ids.action_puzzle_solver)
		new_action:add_precondition(world_property(properties["need_zoneguard"], false))
	
		if char_ini ~= nil then
			xr_zoneguard.set_zoneguard(npc)
		end
	end
end

-- enable - будет ли работать схема в принципе
function set_zoneguard(object, enable, path_walk, path_look, team, zone_guard, zone_warn)
	local char_ini = object:spawn_ini()
	local st = xr_motivator.storage[object:id()].zoneguard

	st.enabled = utils.conf_get_bool(char_ini, "zoneguard", "enabled", enable, object, true)
	st.path_walk = utils.conf_get_string(char_ini, "zoneguard", "path_walk", path_main, object, true)
	st.path_look = utils.conf_get_string(char_ini, "zoneguard", "path_look", path_side, object, false)
	st.team = utils.conf_get_string(char_ini, "zoneguard", "team", path_center, object, true)
	st.zone_guard = utils.conf_get_string(char_ini, "zoneguard", "zone_guard", zone_guard, object, true)
	st.zone_warn = utils.conf_get_string(char_ini, "zoneguard", "zone_warn", block_warn, object, true)

	if st.action ~= nil then
		st.action.reset_scheme(st.action)
	end
	xr_motivator.checkStorage(object)
end

