----------------------------------------------------------------------------------------------------
-- Cameras
----------------------------------------------------------------------------------------------------
-- »сходный скрипт: Oleg Hryptul (Haron) haronk@ukr.net
----------------------------------------------------------------------------------------------------

class "action_camera_activity"

----------------------------------------------------------------------------------------------------
-- Constructor
----------------------------------------------------------------------------------------------------
function action_camera_activity:__init(obj, storage)
	self.object = obj
	self.st     = storage

	self.path   = nil
	self.num_wp = 0  -- количество вейпоинтов, между которыми будем двигать камеру
	self.cur_wp = -1 -- текущий вейпоинт, к которому мы двигаемс€
	self.move_direction = 1 -- направление движени€ по вейпоинтам: 1 - вперед, (-1) - назад
    self.track_enemy = nil -- вражеский сталкер
	self.ocular_joint = nil -- джоинт окул€ра камеры
	
	printf("_hr: action_camera_activity:__init")
end

function action_camera_activity:reset_scheme()
	printf("_hr: action_camera_activity:reset_scheme: self.object:name()='%s'", self.object:name())
	
	--self.st.signals = {}

	xr_logic.mob_capture(self.object, true)

    --if self.st.enemy_stalker then
    --    self.enemy = get_stalker(self.st.enemy_stalker)
    --end
    --db.obj_by_id[id]

	if self.st.state == "path_tracking" then
	    if self.path == nil then
		    self.path = patrol(self.st.path_look)
	    end
	    self.num_wp = self.path:count()
	    self.cur_wp = self.st.start_wp
    	
	    --action(self.object, look(look.point, self.path:point(self.cur_wp)), anim(anim.turn, 0), cond(cond.look_end))
	    action(self.object, look(self.path:point(self.cur_wp), self.st.speed_h, self.st.speed_v), cond(cond.look_end))
	--elseif self.st.state == "range_tracking" then
    end
end

function action_camera_activity:update(delta)
	--printf("_hr: action_camera_activity:update()")

	if not xr_logic.is_active(self.object, self.st) then
		return
	end

	local actor = level.actor()
	if not actor then
		return
	end

	if xr_logic.try_switch_to_another_section(self.object, self.st, actor) then
		return
	end
	
	--  амера после выхода из alife может уже быть не под скриптом, поэтому вз€ть оп€ть под скрипт
	if not xr_logic.mob_captured(self.object) then
		self:reset_scheme()
		return
	end
--[[
	if not self.ocular_joint then
		local ps = self.object:get_physics_shell()
		printf("_ttt: %s", if_then_else(ps ~= nil, "ps not nil", "ps nil"))
		self.ocular_joint = ps:get_joint_by_bone_name("bone_light")
	end
--]]
    -- —ледим за сталкером
    local dist = self.object:bone_position("bone_light"):distance_to(actor:position())
    --local diff_angle_h = 
    --local diff_angle_v = 

	if dist <= self.st.warn_distance
	   --and diff_angle_h < self.st.view_range_h / 2
	   --and diff_angle_v < self.st.view_range_v / 2
	then
		self.track_enemy = actor
		xr_logic.mob_capture(self.object, true)
		action(self.object, look(actor:position(), self.st.speed_h, self.st.speed_v), cond(cond.look_end))
	elseif self.track_enemy then
		self.track_enemy = nil
		if self.object:action() then
			xr_logic.mob_capture(self.object, true)
		end
	end

    if not self.track_enemy and not self.object:action() then
        -- ƒвигаем камеру по пути
        if self.st.state == "path_tracking" then
		    if self.cur_wp == 0 then
			    self.move_direction = 1
		    elseif self.cur_wp == self.num_wp - 1 then
			    self.move_direction = -1
		    end
            
		    self.cur_wp = self.cur_wp + self.move_direction
            
		    --printf("_hr: action_camera_activity:update: cur_wp = %d", self.cur_wp)
		    --action(self.object, look(look.point, self.path:point(self.cur_wp)), anim(anim.turn, 0), cond(cond.look_end))
		    action(self.object, look(self.path:point(self.cur_wp), self.st.speed_h, self.st.speed_v), cond(cond.look_end))
        -- ƒвигаем камеру в диапазоне
        //elseif self.st.state == "range_tracking" then
        end
	end
end

---------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
	printf("DEBUG: add_to_binder: scheme='%s', section='%s'", scheme, section)

	local new_action = action_camera_activity(npc, storage)

	-- «арегистрировать все actions, в которых должен быть вызван метод reset_scheme при изменении настроек схемы:
	xr_logic.subscribe_action_for_events(npc, storage, new_action)
end

function set_scheme(npc, ini, scheme, section, gulag_name)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
	
	st.logic = xr_logic.cfg_get_switch_conditions(ini, section, npc)
	
    // state:
    //  off - камера выключена,
    //  path_tracking - движение по пути,
    //  range_tracking - движение камеры в определенных угловых границах
	st.state = utils.cfg_get_string(ini, section, "state", npc, false, "", "path_tracking")

    if st.state == "path_tracking" then
        // path_look - путь, по которому будет поворачиватьс€ камера
        // start_wp - вейпоинт, с которого будет начинатьс€ движение камеры
	    st.path_look = utils.cfg_get_string(ini, section, "path_look", npc, true, "")
	    st.start_wp  = utils.cfg_get_number(ini, section, "start_wp", npc, false, 0)
--[[	elseif st.state == "range_tracking" then
        // angle_h1, angle_h2 - начальный и конечный углы по горизонтали
        // angle_v - угол наклона камеры
	    st.angle_h1 = utils.cfg_get_number(ini, section, "angle_h1", npc, false, -45)
	    st.angle_h2 = utils.cfg_get_number(ini, section, "angle_h2", npc, false, 45)
	    st.angle_v  = utils.cfg_get_number(ini, section, "angle_v", npc, false, 0)
--]]
    else
        st.state = "off"
    end

    // speed_h, speed_v - скорость поворота камеры по горизонтали и вертикали
	st.speed_h = utils.cfg_get_number(ini, section, "speed_h", npc, false, 1)
	st.speed_v = utils.cfg_get_number(ini, section, "speed_v", npc, false, 1)

    // view_range_h, view_range_v - угол видимости камеры по горизонтали и вертикали
	st.view_range_h = utils.cfg_get_number(ini, section, "view_range_h", npc, false, 90)
	st.view_range_v = utils.cfg_get_number(ini, section, "view_range_v", npc, false, 90)

    // enemy_stalker - им€ вражеского сталкера, за которым камера будет следить
    // с самого начала
	--st.enemy_stalker = utils.cfg_get_string(ini, section, "enemy_stalker", npc, false, "")

	// рассто€ние, на котором "замечаютс€" враги
    st.warn_distance = utils.cfg_get_number(ini, section, "warn_distance", npc, false, 10)
end
