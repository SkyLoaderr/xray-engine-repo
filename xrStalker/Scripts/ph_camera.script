----------------------------------------------------------------------------------------------------
-- Cameras
----------------------------------------------------------------------------------------------------
-- »сходный скрипт: Oleg Hryptul (Haron) haronk@ukr.net
----------------------------------------------------------------------------------------------------

class "action_camera_activity"

----------------------------------------------------------------------------------------------------
-- Constructor
----------------------------------------------------------------------------------------------------
function action_camera_activity:__init(obj, storage)
	self.object = obj
	self.st     = storage

	self.path   = nil
	self.num_wp = 0  -- количество вейпоинтов, между которыми будем двигать камеру
	self.cur_wp = -1 -- текущий вейпоинт, к которому мы двигаемс€
	self.move_direction = 1 -- направление движени€ по вейпоинтам: 1 - вперед, (-1) - назад
    self.track_enemy = nil -- вражеский сталкер
	self.ocular_joint = nil -- джоинт окул€ра камеры
	self.pause = false
	self.pause_start = 0
	
	printf("_hr: action_camera_activity:__init")
end

function action_camera_activity:reset_scheme()
	printf("_hr: action_camera_activity:reset_scheme: self.object:name()='%s'", self.object:name())
	
	--self.st.signals = {}

	xr_logic.mob_capture(self.object, true)

	if self.st.state == "path_tracking" then
	    if self.path == nil then
		    self.path = patrol(self.st.path_look)
	    end
	    self.num_wp = self.path:count()
	    self.cur_wp = self.st.start_wp
    	
	    --action(self.object, look(look.point, self.path:point(self.cur_wp)), anim(anim.turn, 0), cond(cond.look_end))
	    action(self.object, look(self.path:point(self.cur_wp), self.st.speed_h, self.st.speed_p), cond(cond.look_end))
	--elseif self.st.state == "range_tracking" then
    end
    
    self.st.signals = {}
end

function angle_diff(a1, a2)
	local b1 = a1:normalize()
	local b2 = a2:normalize()
	local dotp = b1:dotproduct(b2)

	return math.acos(dotp) * 180.0 / math.pi
end

function angle_diff_hp(a1, a2)
	local res = {}
	local b1 = vector():set(a1.x, 0, a1.z)
	local b2 = vector():set(a2.x, 0, a2.z)
	res.h = angle_diff(b1, b2)
	b1 = vector():set(0, a1.y, a1.z)
	b2 = vector():set(0, a2.y, a2.z)
	res.p = angle_diff(b1, b2)
	
	return res
end

function action_camera_activity:update(delta)
	--printf("_hr: action_camera_activity:update()")

	if not xr_logic.is_active(self.object, self.st) then
		return
	end

	local actor = level.actor()
	if not actor then
		return
	end

	if xr_logic.try_switch_to_another_section(self.object, self.st, actor) then
		return
	end
	
	--  амера после выхода из alife может уже быть не под скриптом, поэтому вз€ть оп€ть под скрипт
	if not xr_logic.mob_captured(self.object) then
		self:reset_scheme()
		return
	end

    -- —ледим за сталкером
    local ocular_pos = self.object:bone_position("bone_light")
    local dist = ocular_pos:distance_to(actor:bone_position("bip01_head"))
    
    local a1 = self.object:direction() --:getHP()
    local a2 = actor:bone_position("bip01_head"):sub(ocular_pos)
    
    local diff_angle = nil
    local in_focus = false
    
    if self.st.focus_type == "rect" then
		diff_angle = angle_diff_hp(a1, a2)
		--printf("_hr: cam_dir(%f,%f,%f) diff_angle(%f)", a1.x, a1.y, a1.z, diff_angle)
		if diff_angle.h < self.st.focus_angle_h / 2 and
		   diff_angle.p < self.st.focus_angle_p / 2 then
			in_focus = true
		end
    else -- cone - default
		diff_angle = angle_diff(a1, a2)
		--printf("_hr: cam_dir(%f,%f,%f) diff_angle(%f)", a1.x, a1.y, a1.z, diff_angle)
		if diff_angle < self.st.focus_angle / 2 then
			in_focus = true
		end
    end

	if dist <= self.st.warn_distance
	   --and actor:see(self.object)
	   and in_focus
	then
		if not self.st.signals["enemy_tracking"] then
			self.st.signals["enemy_tracking"] = true
		end
		self.track_enemy = actor
		xr_logic.mob_capture(self.object, true)
		action(self.object, look(actor:position(), self.st.speed_h, self.st.speed_p), cond(cond.look_end))
		self.focus = false
	elseif self.track_enemy then
		self.track_enemy = nil
		if self.object:action() then
			xr_logic.mob_capture(self.object, true)
		end
		
		-- ѕровер€ем нужно ли делать паузу
		if self.st.pause_after_lost_target > 0 then
			self.pause = true
			self.pause_start = device():time_global()
			return
		elseif self.st.signals["enemy_tracking"] then
			self.st.signals["enemy_tracking"] = false
		end
	end

    -- ѕровер€ем не в паузе ли мы
    if self.pause then
		if self.pause_start + self.st.pause_after_lost_target > device():time_global()
		then
			return
		end

		self.pause = false
		if self.st.signals["enemy_tracking"] then
			self.st.signals["enemy_tracking"] = false
		end
    end
    
    if not self.track_enemy and not self.object:action() then
        -- ƒвигаем камеру по пути
        if self.st.state == "path_tracking" then
		    if self.cur_wp == 0 then
			    self.move_direction = 1
		    elseif self.cur_wp == self.num_wp - 1 then
			    self.move_direction = -1
		    end
            
		    self.cur_wp = self.cur_wp + self.move_direction
            
		    --printf("_hr: action_camera_activity:update: cur_wp = %d", self.cur_wp)
		    --action(self.object, look(look.point, self.path:point(self.cur_wp)), anim(anim.turn, 0), cond(cond.look_end))
		    action(self.object, look(self.path:point(self.cur_wp), self.st.speed_h, self.st.speed_p), cond(cond.look_end))
        -- ƒвигаем камеру в диапазоне
        //elseif self.st.state == "range_tracking" then
        end
	end
end

---------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
	printf("DEBUG: add_to_binder: scheme='%s', section='%s'", scheme, section)

	local new_action = action_camera_activity(npc, storage)

	-- «арегистрировать все actions, в которых должен быть вызван метод reset_scheme при изменении настроек схемы:
	xr_logic.subscribe_action_for_events(npc, storage, new_action)
end

function set_scheme(npc, ini, scheme, section, gulag_name)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
	
	st.logic = xr_logic.cfg_get_switch_conditions(ini, section, npc)
	
    // state:
    //  off - камера выключена,
    //  path_tracking - движение по пути,
    //  range_tracking - движение камеры в определенных угловых границах
	st.state = utils.cfg_get_string(ini, section, "state", npc, false, "", "path_tracking")

    if st.state == "path_tracking" then
        // path_look - путь, по которому будет поворачиватьс€ камера
        // start_wp - вейпоинт, с которого будет начинатьс€ движение камеры
	    st.path_look = utils.cfg_get_string(ini, section, "path_look", npc, true, "")
	    st.start_wp  = utils.cfg_get_number(ini, section, "start_wp", npc, false, 0)
--[[	elseif st.state == "range_tracking" then
        // angle_h1, angle_h2 - начальный и конечный углы по горизонтали
        // angle_p - угол наклона камеры
	    st.angle_h1 = utils.cfg_get_number(ini, section, "angle_h1", npc, false, -45)
	    st.angle_h2 = utils.cfg_get_number(ini, section, "angle_h2", npc, false, 45)
	    st.angle_p  = utils.cfg_get_number(ini, section, "angle_p", npc, false, 0)
--]]
    else
        st.state = "off"
    end

    // speed_h, speed_p - скорость поворота камеры по горизонтали и вертикали
	st.speed_h = utils.cfg_get_number(ini, section, "speed_h", npc, false, 1)
	st.speed_p = utils.cfg_get_number(ini, section, "speed_p", npc, false, 1)

	// focus_type - тип фокуса: cone - конический, rect - квадратный
	st.focus_type = utils.cfg_get_string(ini, section, "focus_type", npc, false, "", "cone")

    if st.focus_type == "rect" then
		// focus_angle_h, focus_angle_p - угол видимости камеры по горизонтали и вертикали
		st.focus_angle_h = utils.cfg_get_number(ini, section, "focus_angle_h", npc, false, 90)
		st.focus_angle_p = utils.cfg_get_number(ini, section, "focus_angle_p", npc, false, 90)
	else
		// focus_angle - конический угол видимости
		st.focus_type = "cone"
		st.focus_angle = utils.cfg_get_number(ini, section, "focus_angle", npc, false, 135)
	end

    // enemy_stalker - им€ вражеского сталкера, за которым камера будет следить
    // с самого начала
	--st.enemy_stalker = utils.cfg_get_string(ini, section, "enemy_stalker", npc, false, "")

	// рассто€ние, на котором "замечаютс€" враги
    st.warn_distance = utils.cfg_get_number(ini, section, "warn_distance", npc, false, 10)
    
    // pause_after_lost_target - пауза после того, как цель вышла из пол€ зрени€
    st.pause_after_lost_target = utils.cfg_get_number(ini, section, "pause_after_lost_target", npc, false, 5000)
end
