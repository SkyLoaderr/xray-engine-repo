----------------------------------------------------------------------------------------------------
-- Cameras
----------------------------------------------------------------------------------------------------
-- Исходный скрипт: Oleg Hryptul (Haron) haronk@ukr.net
----------------------------------------------------------------------------------------------------

class "action_camera_activity"

----------------------------------------------------------------------------------------------------
-- Constructor
----------------------------------------------------------------------------------------------------
function action_camera_activity:__init(obj, storage)
	self.object = obj
	self.st     = storage

	self.path   = nil
	self.num_wp = 0  -- количество вейпоинтов, между которыми будем двигать камеру
	self.cur_wp = -1 -- текущий вейпоинт, к которому мы двигаемся
	self.move_direction = 1 -- направление движения по вейпоинтам: 1 - вперед, (-1) - назад
end

function action_camera_activity:reset_scheme()
	printf("_hr: action_camera_activity:reset_scheme: self.object:name()='%s'", self.object:name())
	
	xr_logic.mob_capture(self.object, true)
	
	if self.path == nil then
		self.path = patrol(self.st.path_look)
	end
	self.num_wp = self.path:count()
	self.cur_wp = self.st.start_wp
	
	action(self.object, look(look.point, self.path:point(self.cur_wp)), anim(anim.turn, 0), cond(cond.look_end))
	--action(self.object, look(self.path:point(self.cur_wp), self.st.speed_h, self.st.speed_v), cond(cond.look_end))
end

function action_camera_activity:update(delta)
	--printf("_hr: action_camera_activity:update()")

	if not xr_logic.is_active(self.object, self.st) then
		return
	end

	local actor = level.actor()
	if not actor then
		return
	end

	if xr_logic.try_switch_to_another_section(self.object, self.st, actor) then
		return
	end
	
	-- Камера после выхода из alife может уже быть не под скриптом, поэтому взять опять под скрипт
	if not xr_logic.mob_captured(self.object) then
		self:reset_scheme()
		return
	end

	if not self.object:action() then
		if self.cur_wp == 0 then
			self.move_direction = 1
		elseif self.cur_wp == self.num_wp - 1 then
			self.move_direction = -1
		end
		
		self.cur_wp = self.cur_wp + self.move_direction
		
		printf("_hr: action_camera_activity:update: cur_wp = %d", self.cur_wp)
		action(self.object, look(look.point, self.path:point(self.cur_wp)), anim(anim.turn, 0), cond(cond.look_end))
		--action(self.object, look(self.path:point(self.cur_wp), self.st.speed_h, self.st.speed_v), cond(cond.look_end))
	end
end

---------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
	printf("DEBUG: add_to_binder: scheme='%s', section='%s'", scheme, section)

	local new_action = action_camera_activity(npc, storage)

	-- Зарегистрировать все actions, в которых должен быть вызван метод reset_scheme при изменении настроек схемы:
	xr_logic.subscribe_action_for_events(npc, storage, new_action)
end

function set_scheme(npc, ini, scheme, section, gulag_name)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
	
	st.logic = xr_logic.cfg_get_switch_conditions(ini, section, npc)
	
	st.state       = utils.cfg_get_string(ini, section, "state", npc, false, "", "off")
	st.path_look   = utils.cfg_get_string(ini, section, "path_look", npc, true, "")
	st.start_wp    = utils.cfg_get_number(ini, section, "start_wp", npc, false, 0)
	st.speed_h     = utils.cfg_get_number(ini, section, "speed_h", npc, false, 10)
	st.speed_v     = utils.cfg_get_number(ini, section, "speed_v", npc, false, 10)
	st.moving_type = utils.cfg_get_number(ini, section, "moving_type", npc, false, "", "path")
end
