----------------------------------------------------------------------------------------------------
-- Mob Eluder
----------------------------------------------------------------------------------------------------
-- Разработчик: Jim
----------------------------------------------------------------------------------------------------

-- константы
local TIME_RELEASE	=	10000		-- время, которое монстр находится под унисхемой
local TIME_CAPTURE	=	10000		-- время, которое монстр находится под скриптом
local MIN_DIST		=	20			-- расстояние до актера, меньше которого, монстр переходит в унисхему
local MAX_DIST		=	30			-- расстояние до актера, больше которого, монстр переходит в унисхему
local DIST_TO_END	=	2			-- расстояние до конца пути


class "mob_eluder"

----------------------------------------------------------------------------------------------------
-- CONSTRUCTION SCHEME
----------------------------------------------------------------------------------------------------
function mob_eluder:__init(obj, storage)
	self.object = obj
	self.st		= storage
end

----------------------------------------------------------------------------------------------------
-- RESET SCHEME
----------------------------------------------------------------------------------------------------
function mob_eluder:reset_scheme()
    printf("Eluder: reset_scheme: %s", self.object:name())
	
	xr_logic.mob_capture		(self.object, true)

	self.st.signals				= {}
	
	self.self_distances			= {}
	self.actor_distances		= {}
	
	self.prev_point_id			= 0
	
	self.time_released			= 0
	self.time_captured			= 0
end

----------------------------------------------------------------------------------------------------
-- UPDATE
----------------------------------------------------------------------------------------------------

function mob_eluder:update(delta)
	
	-- Check for alife control 
	if not self:check_script_control() then	return end
	
	if xr_logic.try_switch_to_another_section(self.object, self.st, db.actor) then
		return
	end

	if not self.object:action() then
		-- Select point here
		self:update_distances	()
		
		action(self.object, move(move.run_fwd, patrol(self.st.path):point(self.best_point_id), DIST_TO_END), cond(cond.move_end))
	end
	
end

----------------------------------------------------------------------------------------------------
-- SERVICE FUNCTIONS
----------------------------------------------------------------------------------------------------
function mob_eluder:update_distances()
	
	local max_self_dist		= 0
	local max_actor_dist	= 0
	
	for i = 1, patrol(self.st.path):count() do
		-- вычислить свое расстояние
		self.self_distances[i]	= patrol(self.st.path):point(i-1):distance_to(self.object:position())
		
		-- запомнить максимальное свое расстояние
		if self.self_distances[i] > max_self_dist then
			max_self_dist = self.self_distances[i]
		end
		
		-- вычислить расстояние от актера
		self.actor_distances[i]	= patrol(self.st.path):point(i-1):distance_to(db.actor:position())
		
		-- запомнить максимальное расстояние от актера
		if self.actor_distances[i] > max_actor_dist then
			max_actor_dist = self.actor_distances[i]
		end
	end
	
	local max_value		= 0
	self.best_point_id	= 0
	
	local k_self		= 1
	local k_actor		= 2
	
	-- пересчитать в соответствии с максимальным расстоянием
	for i = 1, patrol(self.st.path):count() do
		self.self_distances[i]	= 1 - self.self_distances[i] / max_self_dist
		self.actor_distances[i]	= self.actor_distances[i] / max_actor_dist
		
		-- сохранить результат
		self.self_distances[i]	= self.actor_distances[i]*k_actor + self.self_distances[i]*k_self
		
		-- show
		
		if max_value < self.self_distances[i] and self.prev_point_id ~= i-1 then
			max_value			= self.self_distances[i]
			self.best_point_id	= i-1
		end
		
	end
	
	self.prev_point_id = self.best_point_id
end


----------------------------------------------------------------------------------------------------
-- Check Script Control
function mob_eluder:check_script_control()
	
	local cur_time = device():time_global()

	if xr_logic.mob_captured(self.object) then
		-- check for release conditions	

		-- if near actor
		-- if far from actor and its time to release for a while
		if  (self.object:position():distance_to(db.actor:position()) < MIN_DIST) or
			(self.time_captured + TIME_CAPTURE < cur_time) then
			
			xr_logic.mob_release(self.object)
			self.time_released = cur_time
		end

	else 
		-- check for capture conditions
		
		-- if far from actor
		if self.object:position():distance_to(db.actor:position()) > MAX_DIST then
			-- if its time to capture for a while
			if self.time_released + TIME_RELEASE < cur_time then
				-- check if it can_capture
				if self.object:can_script_capture() then 
					xr_logic.mob_capture(self.object, true)
					self.time_captured = cur_time
				end
			end
		end
	end
	
	if not xr_logic.mob_captured(self.object) then
		return false
	else
		return true
	end

end



----------------------------------------------------------------------------------------------------
-- ADD_TO_BINDER
----------------------------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
	printf("DEBUG: add_to_binder: npc:name()='%s', scheme='%s', section='%s'", npc:name(), scheme, section)

	local new_action = mob_eluder(npc, storage)

	-- Зарегистрировать все actions, в которых должен быть вызван метод reset_scheme при изменении настроек схемы:
	xr_logic.subscribe_action_for_events(npc, storage, new_action)
end

----------------------------------------------------------------------------------------------------
-- SET_SCHEME
----------------------------------------------------------------------------------------------------

function set_scheme(npc, ini, scheme, section, gulag_name)
	local storage				= xr_logic.assign_storage_and_bind(npc, ini, scheme, section)

	storage.logic				= xr_logic.cfg_get_switch_conditions(ini, section, npc)
	
	storage.path				= utils.cfg_get_string(ini, section, "path",	npc,	false, "")
end

