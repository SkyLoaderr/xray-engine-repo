----------------------------------------------------------------------------------------------------
-- Mob Eluder
----------------------------------------------------------------------------------------------------
-- Разработчик: Jim
----------------------------------------------------------------------------------------------------

class "mob_eluder"

----------------------------------------------------------------------------------------------------
-- CONSTRUCTION SCHEME
----------------------------------------------------------------------------------------------------
function mob_eluder:__init(obj, storage)
	self.object = obj
	self.st		= storage
end

----------------------------------------------------------------------------------------------------
-- RESET SCHEME
----------------------------------------------------------------------------------------------------
function mob_eluder:reset_scheme()
    printf("Eluder: reset_scheme: %s", self.object:name())
	
	xr_logic.mob_capture(self.object, true)

	self.tip_sent				= false
	
	self.st.signals				= {}
	self.action_end_signalled	= false
	
	self.need_reselect			= true
	
	self.self_distances			= {}
	self.actor_distances		= {}
	
	self.prev_point_id			= 0
end

----------------------------------------------------------------------------------------------------
-- UPDATE
----------------------------------------------------------------------------------------------------

function mob_eluder:update(delta)
	 --printf("Eluder update: %d", device():time_global())
	
	if xr_logic.try_switch_to_another_section(self.object, self.st, db.actor) then
		return
	end

	
	if not self.object:action() then
		self.need_reselect		= false
		
		-- Select point here
		self:update_distances	()
		
		xr_logic.mob_capture(self.object, true)
		
		action(self.object, move(move.run_fwd, patrol(self.st.path):point(self.best_point_id), 3), cond(cond.move_end))
	end
	
	
--	if self.object:get_script() and not self.object:action() then
--		action(self.object, move("stand_idle_0"), cond(cond.time_end, 20000))
--	end

--	if self.object:get_script() and not self.object:action() then
--		if not self.action_end_signalled then
--			self.action_end_signalled		= true
--			self.st.signals["action_end"]	= true
--			printf("mob_eluder: signalling action_end")
--		end
--	end
end

----------------------------------------------------------------------------------------------------
-- WAYPOINT_CALLBACK
----------------------------------------------------------------------------------------------------
function mob_eluder:waypoint_callback(obj, action_type, index)
	printf("mob_eluder:waypoint_callback(): name=%s, index=%d", self.object:name(), index)
	
	self.need_reselect = true
end


----------------------------------------------------------------------------------------------------
-- SERVICE FUNCTIONS
----------------------------------------------------------------------------------------------------
function mob_eluder:update_distances()
	
	local max_self_dist		= 0
	local max_actor_dist	= 0
	
	for i = 1, patrol(self.st.path):count() do
		-- вычислить свое расстояние
		self.self_distances[i]	= patrol(self.st.path):point(i-1):distance_to(self.object:position())
		
		-- запомнить максимальное свое расстояние
		if self.self_distances[i] > max_self_dist then
			max_self_dist = self.self_distances[i]
		end
		
		-- вычислить расстояние от актера
		self.actor_distances[i]	= patrol(self.st.path):point(i-1):distance_to(db.actor:position())
		
		-- запомнить максимальное расстояние от актера
		if self.actor_distances[i] > max_actor_dist then
			max_actor_dist = self.actor_distances[i]
		end
	end
	
	local max_value		= 0
	self.best_point_id	= 0
	
	-- temp PRE MAX
	local pre_max_value	= 0
	local pre_max_id	= 0
	
	-- пересчитать в соответствии с максимальным расстоянием
	for i = 1, patrol(self.st.path):count() do
		self.self_distances[i]	= 1 - self.self_distances[i] / max_self_dist
		self.actor_distances[i]	= self.actor_distances[i] / max_actor_dist
		
		-- сохранить результат
		self.self_distances[i]	= self.actor_distances[i] * self.self_distances[i]
		
		-- show
--		printf("P[%u] = [%f]", i-1, self.self_distances[i])
		
		if max_value < self.self_distances[i] and self.prev_point_id ~= i-1 then
			max_value			= self.self_distances[i]
			self.best_point_id	= i-1
		end
		
		-- temp PRE MAX
		if pre_max_value < self.self_distances[i] and self.self_distances[i] < max_value then
			pre_max_value	= self.self_distances[i]
			pre_max_id		= i-1
		end
		
	end
	
	-- temp PRE MAX
	--self.best_point_id = pre_max_id
	
	self.prev_point_id = self.best_point_id
	
	printf("Best Point ID = [%u] Value = [%f]", self.best_point_id, max_value)
end



----------------------------------------------------------------------------------------------------
-- ADD_TO_BINDER
----------------------------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
	printf("DEBUG: add_to_binder: npc:name()='%s', scheme='%s', section='%s'", npc:name(), scheme, section)

	local new_action = mob_eluder(npc, storage)

	-- Зарегистрировать все actions, в которых должен быть вызван метод reset_scheme при изменении настроек схемы:
	xr_logic.subscribe_action_for_events(npc, storage, new_action)
end

----------------------------------------------------------------------------------------------------
-- SET_SCHEME
----------------------------------------------------------------------------------------------------

function set_scheme(npc, ini, scheme, section, gulag_name)
	local storage       = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)

	storage.logic       = xr_logic.cfg_get_switch_conditions(ini, section, npc)
	
	storage.path		= utils.cfg_get_string(ini, section, "path",	npc,	false, "")
	storage.time        = utils.cfg_get_string(ini,	section, "time",	npc,	false, "")
end
