
function is_food_present (npc)
    if npc:object ("bread") ~= nil or npc:object ("kolbasa") ~= nil or npc:object ("vodka") ~= nil then
       return true
    end    
    return false
end


----------------------------------------------------------------------------------------------------------------------
class "evaluator_rest" (property_evaluator)
----------------------
function evaluator_rest:__init (name, storage) super (nil, name)
    self.st = storage
end
----------------------
function evaluator_rest:evaluate ()
  	return xr_logic.is_active (self.object, self.st)
end
----------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------
class "evaluator_food" (property_evaluator)
----------------------
function evaluator_food:__init (name, storage) super (nil, name)
    self.st = storage
end
----------------------
function evaluator_food:evaluate ()
    return this.is_food_present (self.object)
end
----------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------
class "evaluator_pos" (property_evaluator)
----------------------
function evaluator_pos:__init (name, storage) super (nil, name)
    self.st = storage
end
----------------------
function evaluator_pos:evaluate ()
    return self.st.on_position
end
----------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------
class "action_position" (action_base)
----------------------
function action_position:__init (name, storage) super (nil, name)
    self.st = storage
	self.move_mgr = move_mgr.move_mgr (self.st.npc)
	self.on_position = false
	self.set = false
end    
----------------------
function action_position:initialize ()
    action_base.initialize (self)
    
	self.object:set_node_evaluator ()
	self.object:set_path_evaluator ()
	self.object:set_desired_position ()
	self.object:set_desired_direction ()
	self.move_mgr:initialize ()
	self:reset_scheme ()
	self.set = false
end
----------------------
function action_position:execute ()
    action_base.execute (self)
	self.move_mgr:update ()
	
	if self.on_position == false then return end
	
	if self.object:active_item () ~= nil then
       self.object:set_item (object.deactivate, self.object:active_item ())
       return
    else 
       if self.set == false then 
          xr_state.change_state (self.object, 3)
          --printf ("Change state at %d", device ():time_global ())
          self.set = true
          return
       end   
    end   
	
	if xr_state.finish_state (self.object) ~= true then 
	   return 
	end
	--printf ("End of change state at %d", device ():time_global ())
	self.st.on_position = true    
	
end
----------------------
function action_position:finalize ()
	self.move_mgr:finalize ()
    action_base.finalize (self)
end            
----------------------
function action_position:reset_scheme ()
	self.object:clear_animations()
	if self.st.path_walk_info == nil then
		self.st.path_walk_info = utils.path_parse_waypoints(self.st.path_rest)
	end
	if self.st.path_look_info == nil then
		self.st.path_look_info = utils.path_parse_waypoints(self.st.path_rest)
	end
	self.move_mgr:reset(self.st.path_rest, self.st.path_walk_info, self.st.path_rest, self.st.path_look_info, nil, nil, {obj = self, func = self.callback})
end	

----------------------------------------------------------------------------------------------------------------------
function action_position:callback (mode, number)
    if self.on_position == true then return end
    if number == 1 then 
       self.on_position = true
       self.object:set_movement_type (move.stand)
       self.object:set_item (object.deactivate, self.object:active_item ())
       return true
    end    
end



----------------------------------------------------------------------------------------------------------------------
class "action_rest" (action_base) 
----------------------
function action_rest:__init (name, storage) super (nil, name)
    self.eat_enable = false
    self.drink_enable = false
    self.eat_object = nil
    self.drink_object = nil
    self.state = 0
    self.time_to_eat = 0
    self.stage = 0
    self.st = storage
    self.st.signals = {}
end
----------------------
function action_rest:initialize ()
    action_base.initialize (self)
    
    self.rest_end_signalled = false
    
    if self.state == 2 then return end
    
    self.eat_object = self.object:object ("bread")
    if self.eat_object == nil then
       self.eat_object = self.object:object ("kolbasa") 
    end
    
    self.eat_enable = self.eat_object ~= nil
    self.drink_object = self.object:object ("vodka")
    self.drink_enable = self.drink_object ~= nil
   
    if self.state == 0 then
       self.state = 1  
       return 
    end
    
    self.stage = 0
    
end
----------------------
function action_rest:execute ()
    action_base.execute (self)

    local hand_object = self.object:active_item ()
    
    if self.eat_enable == true then
       if self.stage == 0 then  
         if hand_object ~= nil and hand_object:id () == self.eat_object:id () then
            self.time_to_eat = device ():time_global () + 30000
            self.object:clear_animations () 
            self.stage = 1
          end   
          --printf ("ENABLE BREAD 1")
          self.object:set_item (object.use, self.eat_object)
          self.time_to_eat = device ():time_global () + 30000
          return
       end   
       --printf ("ENABLE BREAD 2")
       if device ():time_global () - self.time_to_eat > 0 then
          self.eat_enable = false
          self.stage = 0
          self.time_to_eat = device ():time_global () + 20000
       end
       return
    end   
    
    if self.drink_enable == true then
       if self.stage == 0 then  
         if hand_object ~= nil and hand_object:id () == self.drink_object:id () then
            self.object:clear_animations () 
            self.stage = 1
          end   
          --printf ("ENABLE VODKA 1")
          self.object:set_item (object.use, self.drink_object)
          self.time_to_eat = device ():time_global () + 20000
          return
       end   
       --printf ("ENABLE VODKA 2")
       if device ():time_global () - self.time_to_eat > 0 then
          self.object:set_item (object.deactivate, self.drink_object)
          self.drink_enable = false
          self.state = 2
          --xr_state.change_state (self.object, 0)
       end
       return
    end   
    
    --if xr_state.finish_state (self.object) ~= true then return end

    if self.rest_end_signalled == false then
       --printf ("ON SIGNAL !") 
       self.st.signals["rest_end"] = true
       self.rest_end_signalled = true
    end   
        
    xr_logic.try_switch_to_another_section (self.object, self.st)
    self.object:set_item (object.activate, self.object:best_weapon ())
end
----------------------
function  action_rest:finalize ()
    action_base.finalize (self)
end    
----------------------


----------------------------------------------------------------------------------------------------------------------
function add_to_binder (npc, ini, scheme, section, st)

    local operators		= {}
    local properties	= {}
	
    properties["food"]              = xr_evaluators_id.sidor_rest      + 0
    properties["on_position"]       = xr_evaluators_id.sidor_rest      + 1
    properties["rest"]              = xr_evaluators_id.sidor_rest      + 2
    properties["state"]             = xr_evaluators_id.state_change 
    
    operators["action_position"]    = xr_actions_id.sidor_act_rest     + 0
    operators["action_rest"]        = xr_actions_id.sidor_act_rest     + 1

	local manager  = npc:motivation_action_manager ()
   	
    manager:add_evaluator (properties["food"], this.evaluator_food ("evaluator_food", st))
    manager:add_evaluator (properties["on_position"], this.evaluator_pos ("evaluator_position", st))
    manager:add_evaluator (properties["rest"], this.evaluator_rest ("evaluator_rest", st))
    
    local action = this.action_position ("action_position", st)
    action:add_precondition     (world_property (stalker_ids.property_alive,    true))
   	action:add_precondition     (world_property (stalker_ids.property_enemy,    false))
   	action:add_precondition     (world_property (properties["food"],            true))
   	action:add_precondition     (world_property (properties["rest"],            true))
   	action:add_precondition     (world_property (properties["on_position"],     false))
   	action:add_effect           (world_property (properties["on_position"],     true))
   	manager:add_action          (operators["action_position"], action)
   	
	xr_logic.subscribe_action_for_events (npc, storage, action)
    
    action = this.action_rest ("action_rest", st)
    action:add_precondition     (world_property (stalker_ids.property_alive,    true))
   	action:add_precondition     (world_property (stalker_ids.property_enemy,    false))
   	action:add_precondition     (world_property (properties["food"],            true))
   	action:add_precondition     (world_property (properties["rest"],            true))
   	action:add_precondition     (world_property (properties["on_position"],     true))
   	action:add_effect           (world_property (properties["rest"],            false))
   	manager:add_action          (operators["action_rest"], action)
   	     	   
    manager:action (xr_actions_id.alife):add_precondition (world_property (properties["rest"],  false))
    
end
----------------------------------------------------------------------------------------------------------------------
function set_scheme (npc, ini, scheme, section, gulag_name)

	local st = xr_logic.assign_storage_and_bind (npc, ini, scheme, section)
	st.logic = xr_logic.cfg_get_switch_conditions (ini, section, npc)
	st.path_rest = utils.cfg_get_string(ini, section, "path_rest", npc, true,  gulag_name)
    st.on_position = false	
	st.path_walk_info = nil
	st.path_look_info = nil 
end

