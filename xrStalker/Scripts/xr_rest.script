local operators		= {}
local properties	= {}
	
properties["rest"]             = xr_evaluators_id.sidor_rest      + 0
properties["food"]             = xr_evaluators_id.sidor_rest      + 1
properties["state"]            = xr_evaluators_id.state_change 
operators["action_rest"]       = xr_actions_id.sidor_act_rest     + 0


----------------------------------------------------------------------------------------------------------------------
class "evaluator_satiety" (property_evaluator)
----------------------
function evaluator_satiety:__init (treshold, name) super ()
    self.treshold = treshold
    self.value = false
end
----------------------
function evaluator_satiety:evaluate ()
    if self.object.satiety < self.treshold then
       self.value = true
    end    
    return self.value
end
----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------
class "evaluator_food" (property_evaluator)
----------------------
function evaluator_food:__init (name) super ()
end
----------------------
function evaluator_food:evaluate ()
    if self.object:object ("bread") ~= nil or 
       self.object:object ("kolbasa") ~= nil or 
       self.object:object ("conserva") ~= nil or
       self.object:object ("vodka") ~= nil then
       --printf ("FOOD PRESENT")
       return true
    end    
    --printf ("NO FOOD")
    return false
end
----------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------
class "action_sit_down" (action_base)
----------------------
function action_sit_down:__init (name) super (nil, name)
end
----------------------
function action_sit_down:initialize ()
    action_base.initialize (self)
    xr_state.change_state (self.object, 3)
end    
----------------------
function action_sit_down:execute ()
    action_base.execute (self)
    if xr_state.finish_state (self.object) == false then return end
    
end    
----------------------
function action_sit_down:finalize ()
    action_base.finalize (self)
end    

----------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------
class "action_rest" (action_base) 
----------------------
function action_rest:__init (name) super (nil, name)
    self.eat_enable = false
    self.drink_enable = false
    self.eat_object = nil
    self.drink_object = nil
    self.state = 0
    self.time_to_eat = 0
    self.stage = 0
end
----------------------
function action_rest:initialize ()
    action_base.initialize (self)
    
    if self.state == 2 then return end
    
    self.object:set_movement_type (move.stand)
    if self.state == 0 then
       if xr_state.change_state (self.object, xr_state.sit_wait) == true then
          if self.object:active_item () ~= nil then
             self.object:set_item (object.deactivate, self.object:active_item ())
          end   
          return
       end   
    end   
    
    self.eat_object = self.object:object ("bread")
    if self.eat_object == nil then
       self.eat_object = self.object:object ("kolbasa") 
       if self.eat_object == nil then
          self.eat_object = self.object:object ("conserva") 
       end
    end
    
    self.eat_enable = self.eat_object ~= nil
    self.drink_object = self.object:object ("vodka")
    self.drink_enable = self.drink_object ~= nil
    
    if self.state == 0 then
       self.state = 1  
       return 
    end
    
    self.time_to_eat = device ():time_global () + 30000
    self.stage = 0
    
end
----------------------
function action_rest:execute ()
    action_base.execute (self)

    local hand_object = self.object:active_item ()
    
    if self.eat_enable == true then
       if self.stage == 0 then  
         if hand_object ~= nil and hand_object:name () == self.eat_object:name () then
             self.object:clear_animations () 
             self.stage = 1
             self.object:set_callback (self, "anim_callback", game_object.animation)
          end   
          self.object:set_item (object.use, self.eat_object)
       end   
       if device ():time_global () - self.time_to_eat > 0 then
          self.eat_enable = false
          self.stage = 0
          self.time_to_eat = device ():time_global () + 20000
       end
       return
    end   
    
    if self.drink_enable == true then
       if self.stage == 0 then  
         if hand_object ~= nil and hand_object:name () == self.drink_object:name () then
            self.object:clear_animations () 
            self.stage = 1
          end   
          self.object:set_item (object.use, self.drink_object)
       end   
       if device ():time_global () - self.time_to_eat > 0 then
          self.object:set_item (object.deactivate, self.drink_object)
          self.drink_enable = false
          self.state = 2
          xr_state.change_state (self.object, 0)
          self.object:clear_callback (game_object.animation)
       end
       return
    end   
    
    self.object:motivation_action_manager ():evaluator (properties["rest"]).value = false
    self.object:set_item (object.activate, self.object:best_weapon ())
end
----------------------
function  action_rest:finalize ()
    action_base.finalize (self)
    if self.state == 0 then 
       self.state = 1 
       return
    end
    self.object:clear_callback (game_object.animation)
end    
----------------------
function action_rest:anim_callback (obj, action_type, index)
    --if action_type ~= game_object.animation then return end
    printf ("ANIMATION CALLBACK 1")
    if self.object:active_item () == nil then
       printf ("ANIMATION CALLBACK 2") 
       self.object:add_animation ("item_1_draw_0", true)
    end        
end


----------------------------------------------------------------------------------------------------------------------
function add_to_binder (obj, property_id)

	local manager  = obj:motivation_action_manager ()

   	local ini = obj:spawn_ini ()
   	if ini == nil or ini:section_exist ("rest") == false or ini:line_exist ("rest", "satiety_threshold") == false then return end
    local satiety = ini:r_u32 ("rest", "satiety_threshold") / 100.0
   	
    manager:add_evaluator (properties["rest"], this.evaluator_satiety (satiety, "evaluator_satiety"))
    manager:add_evaluator (properties["food"], this.evaluator_food ("evaluator_food"))
    
    local action = this.action_rest ("action_rest")
    action:add_precondition     	(world_property (stalker_ids.property_alive,    true))
   	action:add_precondition     	(world_property (stalker_ids.property_enemy,    false))
   	action:add_precondition         (world_property (properties["food"],            true))
   	action:add_precondition         (world_property (properties["rest"],            true))
   	action:add_precondition         (world_property (properties["state"],           true))
   	action:add_effect               (world_property (properties["rest"],            false))
   	manager:add_action              (operators["action_rest"], action)
   	     	   
    manager:action (property_id):add_precondition (world_property (properties["rest"],  false))
    
end
----------------------------------------------------------------------------------------------------------------------
