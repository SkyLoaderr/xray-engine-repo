----------------------------------------------------------------------
--	created:	2005/02/09
--	created:	9:2:2005   18:50
--	filename: 	x:\gamedata\scripts\xr_attendant.script
--	file path:	x:\gamedata\scripts
--	file base:	xr_attendant
--	file ext:	script
--	author:		“ундук ¬ладимир aka Sidorovich
--	
--	purpose:	схема сопровождающего.
----------------------------------------------------------------------

-----------------------------------------------------------------------------------
-- Ёвалуатор ожидани€ лидера
class "evaluator_leader" (property_evaluator)
--------
function evaluator_leader:__init (name, storage) super (nil, name)
    self.st = storage
    self.time = 0
end
--------
function evaluator_leader:evaluate ()
    -- Ћидер уже есть
    if self.st.leader_id ~= nil then return true end

    -- ≈сли задан story id лидера, то будем его щупать. 
    -- ¬ результате должны получить его id
    if self.st.leader ~= nil then 
       local sim = alife ()
       if sim then
          local se_obj = sim:story_object (tonumber(self.st.leader))
          if se_obj then
             if db.obj_by_id[se_obj.id] ~= nil then
                self.st.leader_id = se_obj.id
                return true
             end
          end
       end
       return false 
    end         

    -- ¬ противном случае будем требовать лидера из гулага
    local gulag = xr_gulag.isUnderFraction (self.object)
    if gulag == nil then return false end
    
    local t = xr_gulag.fraction[gulag]:getJob (self.object)
    if t ~= nil and t.leader ~= nil then 
       self.st.leader_id = xr_gulag.fraction[gulag]:idStalkerOnJob (t.leader)
       if self.st.leader_id ~= nil then 
          return true
       end   
    end
    
    if self.time == 0 then self.time = device ():time_global () 
    else
       if device ():time_global () - self.time > 10000 then
          printf ("!!! ERROR !!! Leader for object %s not defined from GULAG system", self.object:name ())
          xr_gulag.resetJob (gulag, self.object)
       end
    end      
    return false
end
-----------------------------------------------------------------------------------


-----------------------------------------------------------------------------------
-- Ёвалуатор следовани€ за лидером
class "evaluator_follow" (property_evaluator)
--------
function evaluator_follow:__init (name, storage) super (nil, name)
    self.st = storage
end
--------
function evaluator_follow:evaluate ()
    return xr_logic.is_active (self.object, self.st)
end
-----------------------------------------------------------------------------------

-----------------------------------------------------------------------------------
-- Ёкшен ожидани€ лидера
class "action_wait" (action_base)
--------
function action_wait:__init (name, storage) super (nil, name)
    self.st = storage
end
--------
function action_wait:initialize ()
    action_base.initialize (self)
end
--------
function action_wait:execute ()
    action_base.execute (self)
end
--------
function action_wait:finalize ()
    action_base.finalize (self)
end
-----------------------------------------------------------------------------------


-----------------------------------------------------------------------------------
-- Ёкшен движени€ за лидером
class "action_follow" (action_base)
--------
function action_follow:__init (name, storage) super (nil, name)
    self.st = storage
    self.vertex_id = nil
    self.index = nil
    self.state = 0 -- 0 - идем, 1 - стоим
end
--------
function action_follow:initialize ()
    action_base.initialize (self)
    self.st.signals = {}
end
--------
function action_follow:execute ()
    action_base.execute (self)
    -- проверим, а жив ли еще старшќй.
    if db.obj_by_id[self.st.leader_id] == nil or db.obj_by_id[self.st.leader_id]:alive () == false then
       self:free ()
       self.st.signals["leader_dead"] = true
       return 
    end 
    -- проверим нахождение нас в списке
    self:check_list ()
    
    if xr_logic.try_switch_to_another_section (self.object, self.st, db.actor) then
       self.st.leader_id = nil
       return 
    end
    
    --получим целевую точку, дистанцию до нее и позицию.
    local vid, vdist, vpos = self:calculate_position ()
    
    if self.state == 0 then
       if vdist > 1 then 
          self.object:set_desired_position (vpos)
          self.object:set_desired_direction (db.obj_by_id[self.st.leader_id]:direction ())
          self.object:set_detail_path_type (move.line)
          self.object:set_path_type (game_object.level_path)
          self.object:set_dest_level_vertex_id (vid)
          if vdist > 20 then
             state_mgr.set_state (self.object, "sprint")
          elseif vdist < 3 then
             state_mgr.set_state (self.object, "walk")
          elseif vdist > 5 then
             state_mgr.set_state (self.object, "run")
          end   
       else
          self.state = 1
       end        
    else
       if vdist > 3 then 
          self.state = 0
       else
       end   
    end    
        
end
--------
function action_follow:finalize ()
    action_base.finalize (self)
    if self.index ~= nil then
       table.remove (db.storage[self.st.leader_id].followers, self.index)
       self.index = nil
    end   
end
--------
function action_follow:calculate_position ()
    -- получим от лидера ноду и направление
    local leader = db.obj_by_id[self.st.leader_id]
    local l_vid = leader:level_vertex_id ()
    local l_dir = leader:direction ()
    -- а также количество народу.
    local size = table.getn (db.storage[self.st.leader_id].followers)
    
    local dir = vector ():set (0, 0, 0)
    local dist = self.st.distance
    -- если идем цепью, то одно, если обычным образом, то другое
    if self.st.formation == true then
       dir = vector_rotate_y (l_dir, 90.0)
       dir.y = 0
       dir:normalize ()
       local half = size / 2
       if bit_and (self.index, 1) == 1 then
          dir.x = -dir.x
          dir.z = -dir.z
       end
       dist = self.st.distance * half
    else 
       if size == 1 then
          dir = vector_rotate_y (l_dir, 179.0)
       else
          dir = vector_rotate_y (l_dir, 90.0 + (180 / (size + 1)) * self.index)
       end
    end
    
    local need_id = level.vertex_in_direction (l_vid, dir, dist)
    if need_id == -1 then
       need_id = l_vid
    end
    l_dir = level.vertex_position (need_id)
    return need_id, l_dir:distance_to (self.object:position ()), l_dir
end
--------
function action_follow:check_list ()
    -- возьмем хранилище лидера
    local storage = db.storage[self.st.leader_id]
    -- и наш айдишник
    local id = self.object:id ()
    -- если у лидера нет таблицы сопровождающих, то создадим ее 
    -- и занесем туда себ€ любимого под номером 1
    if storage.followers == nil then
       storage.followers = {}
       table.insert (storage.followers, self.object:id ())
       --printf ("SET OBJECT %s AS FOLLOWER 1", self.object:name ())
       self.index = 1
       return
    end
    -- иначе шаримс€ в таблице и ищем себ€
    for a = 1, table.getn (storage.followers), 1 do
        if storage.followers[a] == id then
           self.index = a
           return 
        end
    end
    -- не нашли... добавим.
    table.insert (storage.followers, self.object:id ())
    self.index = table.getn (storage.followers)
    --printf ("SET OBJECT %s AS FOLLOWER %d", self.object:name (), self.index)
end
--------
function action_follow:free ()
    -- если мы под гулагом, то запросим другую работу, иначе пр€ма€ дорога в logic
    if xr_gulag.isUnderFraction (self.object) ~= nil then
       xr_gulag.resetJob (gulag, self.object)
    else
       xr_logic.try_switch_to_another_section (self.object, self.st, db.actor)
    end
end
-----------------------------------------------------------------------------------



function  add_to_binder(npc, ini, scheme, section, storage)
    
    
	local operators		= {}
	local properties	= {}
	
	local manager = npc:motivation_action_manager ()
	
	properties["attendant_leader"]      =   xr_evaluators_id.sidor_attendant_eva + 0
	properties["attendant_follow"]      =   xr_evaluators_id.sidor_attendant_eva + 1

    operators["attendant_wait"] 	    =   xr_actions_id.sidor_attendant_act + 0
    operators["attendant_follow"]       =   xr_actions_id.sidor_attendant_act + 1
    
    manager:add_evaluator (properties["attendant_leader"], this.evaluator_leader ("attendant_leader", storage))
    manager:add_evaluator (properties["attendant_follow"], this.evaluator_follow ("attendant_follow", storage))

    local action = this.action_wait ("attendant_wait", storage)
    action:add_precondition     (world_property (stalker_ids.property_alive, true))
    action:add_precondition     (world_property (stalker_ids.property_enemy, false))
    action:add_precondition     (world_property (properties["attendant_leader"], false))
    action:add_effect           (world_property (properties["attendant_leader"], true))
    manager:add_action (operators["attendant_wait"], action)
    military_radio.add (npc, action)

    action = this.action_follow ("attendant_follow", storage)
    action:add_precondition     (world_property (stalker_ids.property_alive, true))
    action:add_precondition     (world_property (stalker_ids.property_enemy, false))
    action:add_precondition     (world_property (properties["attendant_leader"], true))
    action:add_precondition     (world_property (properties["attendant_follow"], true))
    action:add_effect           (world_property (properties["attendant_follow"], false))
    manager:add_action (operators["attendant_follow"], action)
    military_radio.add (npc, action)
    
    --xr_logic.subscribe_action_for_events (npc, storage, action)
    
    action = manager:action     (xr_actions_id.alife)
    action:add_precondition     (world_property (properties["attendant_follow"], false))
    
end

function set_scheme (npc, ini, scheme, section, gulag_name)
	local st = xr_logic.assign_storage_and_bind (npc, ini, scheme, section)
	st.logic = xr_logic.cfg_get_switch_conditions (ini, section, npc)
	
	st.leader = utils.cfg_get_string (ini, section, "leader",  npc, false, "")
	st.formation = utils.cfg_get_bool (ini, section, "formation_line", npc, false, false)
	st.distance = utils.cfg_get_number (ini, section, "distance", npc, false)
	if st.distance == nil then
	   if st.formation == false then
          st.distance = 1.5
	   else 
          st.distance = 5
	   end
	end   
    
end