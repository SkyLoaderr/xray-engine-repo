---------------------------------------------------------------------------------------------------------------------
--	Схема реакции на раздражители
--	автор: Диденко Руслан (Stohe)
--	TODO: после завершения схемы необходимо вывести глобальное свойство - нет новых раздражителей и всем скриптам поставить его в прекондишн
----------------------------------------------------------------------------------------------------------------------

local sounds = {}

----------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
-- Эвалуатор указывает что есть новый раздражитель
class "evaluator_new" (property_evaluator)
function evaluator_new:__init(name, storage) super()
	self.a = storage
end
function evaluator_new:evaluate()
	self.a.evn:calculate()
--	self.a.evn:print()
	-- если мы щас никого не обрабатываем и есть раздражители - нужно заполнить пробел
	if self.a.id == nil and self.a.evn:isEvents() then
		self.a.evn:get_event(self.a)
	end
	
	local tt = self.a.id ~= nil 
--	if tt then
--		printf("[EVA] Reactions: New TRUE")
--	else
--		printf("[EVA] Reactions: New FALSE")
--	end
	return tt
end

----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
-- Обработка раздражителя
class "action_wait" (action_base)
function action_wait:__init (npc_name,action_name, storage) super (nil, action_name)
	self.a = storage
end
function action_wait:initialize()
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()

	--временно время устанавливаем здесь
	self.a.time = device():time_global()

	self.t = nil
	self.time = nil

	self.sound_relax = {idle = 0,
		     begin = nil,
		     maxidle = 1, 
		     sumidle = 1,
   		     rnd = 100,
		     lastsound = nil,
		 	sounds = {      {pack = sounds["relax"], id = 0},
					{pack = sounds["relax"], id = 1} }}

	self.sound_search = {idle = 0,
		     begin = nil,
		     maxidle = 5, 
		     sumidle = 3,
   		     rnd = 100,
		     lastsound = nil,
		 	sounds = {      {pack = sounds["search"], id = 0},
					{pack = sounds["search"], id = 1},
					{pack = sounds["search"], id = 2},
					{pack = sounds["search"], id = 3} }}

	self.sound_wait = {idle = 0,
		     begin = nil,
		     maxidle = 5, 
		     sumidle = 3,
   		     rnd = 100,
		     lastsound = nil,
		 	sounds = {      {pack = sounds["wait"], id = 0},
					{pack = sounds["wait"], id = 1},
					{pack = sounds["wait"], id = 2},
					{pack = sounds["wait"], id = 3},
					{pack = sounds["wait"], id = 4},
					{pack = sounds["wait"], id = 5},
					{pack = sounds["wait"], id = 6},
					{pack = sounds["wait"], id = 7},
					{pack = sounds["wait"], id = 8} }}

end
function action_wait:execute ()
--	printf("[ACT] Reactions: Wait")

	-- если мы обрабатываем новый раздражитель, то нужно сресетить значения времени ожидания
	if self.a.evn:isEvents() then
		self.a.evn:get_event(self.a)
		self.a.time = device():time_global()
		self.a.evn:markAsWatch(self.a.id)
	end

	--идем проверять или стоим смотрим
	if ((self.a.isVisual ~= nil and self.a.isVisual > 0.75) or (self.a.isVisual == nil and self.a.watched == true)) then
		--обработка проверки
		if self.object:position():distance_to(level.vertex_position(self.a.position)) <= 3 then
			-- если мы уже стоим в радиусе 5 метров от раздражителя - просто стоим и оглядываемся
			if (self.time == nil) or (device():time_global()/1000 - self.time > self.t) then
				self.t = math.random(3)+4
				self.time = device():time_global()/1000

				local dir = vector():set(math.random(10)-5, 0, math.random(10)-5)
				self.object:set_sight(look.direction, dir, 0)
				self.object:set_body_state(move.standing)
				self.object:set_movement_type(move.stand)
				self.object:set_mental_state(anim.danger)
			end
		else
			self.object:set_mental_state(anim.danger)
			self.object:set_movement_type(move.walk)
			self.object:set_path_type(game_object.level_path)
			-- медленно подходим к раздражителю
			self.object:set_dest_level_vertex_id(self.a.position)
			local pos = level.vertex_position(self.a.position)
			pos.y = pos.y + 0.8
			self.object:set_sight(look.point, pos, 0)
	      		self.object:set_item(object.idle, self.object:best_weapon())
        	end
		-- озвучка на проверку
		globals.set_sound(self.object, self.sound_wait, false)

	else
		-- обрабатываем приглядывание
		self.object:set_movement_type(move.stand)
		self.object:set_sight(look.point, level.vertex_position(self.a.position), 0)
		-- озвучка на поиск
		globals.set_sound(self.object, self.sound_search, false)

	end


	-- надо проверять время на обработку раздражителя, если время закончилось - прекращать обработку
	if device():time_global() - self.a.time > self.a.time_wait then
		-- реплики что мы не нашли ничего
		globals.set_sound(self.object, self.sound_relax, true)

		self.a.evn:removeFromWatch(self.a.id)
		self.a.id = nil
	end

	-- если мы можем классифицировать объект, то нужно пометить его как обработанный и выйти
	if self.a.isVisual and self.a.isVisual >= 1 then
		self.a.evn:markAsUsed(self.a.id)
		self.a.evn:removeFromWatch(self.a.id)
		self.a.id = nil
	end

	action_base.execute (self)
end
function action_wait:finalize ()
	-- если у нас id = nil тогда мы не нашли чего ждали, иначе нашли врага
	if self.a.id ~= nil then
		-- реплики что мы что-то враждебное
		self.a.id = nil
	end

	action_base.finalize (self)
end

----------------------------------------------------------------------------------------------------------------------
-- binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(object)

	local operators		= {}
	local properties	= {}

	sounds["wait"] 		= xr_sounds_id.stohe_reaction_base + 0
	sounds["search"]	= xr_sounds_id.stohe_reaction_base + 1
	sounds["relax"] 	= xr_sounds_id.stohe_reaction_base + 2

	object:add_sound("script_replics\\soldier_1\\hear_something\\soldier_hear_", 10, snd_type.talk, 2, 1, sounds["wait"])
	object:add_sound("script_replics\\soldier_1\\search_enemy\\soldier_search_", 10, snd_type.talk, 2, 1, sounds["search"])
	object:add_sound("script_replics\\soldier_1\\idle\\soldier_idle_", 10, snd_type.talk, 2, 1, sounds["relax"])


	local manager = object:motivation_action_manager()

	properties["event"] 	= xr_evaluators_id.stohe_reactions_base + 0

	operators["wait"] 	= xr_actions_id.stohe_reactions_base + 0

	-- Evaluators
	manager:add_evaluator (properties["event"], 		this.evaluator_new		("evaluator_new", xr_motivator.storage[object:id()].reactions))

	-- Actions
	local action = this.action_wait (object:name(),"action_wait", xr_motivator.storage[object:id()].reactions)
	action:add_precondition		(world_property(stalker_ids.property_alive, 	true))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
	action:add_precondition		(world_property(properties["event"],		true))
	action:add_effect		(world_property(properties["event"],		false))
	manager:add_action (operators["wait"], action)


	action = manager:action (stalker_ids.action_free_no_alife)	
	action:add_precondition		(world_property(properties["event"],		false))

end

----------------------------------------------------------------------------------------------------------------------
-- Classs
----------------------------------------------------------------------------------------------------------------------
class "events"
function events:__init(npc)
	self.npc = npc
	self.arhive = {} -- массив дескрипторов раздражителей
	self.used = {} -- обработанные объекты, некоторое время раздражители по ним учитываться не будут
	self.watch = {}	-- раздражители, за которыми мы следим
	self.hear = {} 	-- звуки, которые мы слышали менее чем x секунду назад. Так как один и тот же звук может приходить несколько раз 
			-- то таким образом мы обрубаем повторное включение одного и того же звука


	self.descr = {	visibility = nil,  -- дескриптор раздражителей
			sound_kat = nil,
			sound_power = nil,
			object_type = nil,
			point = nil,
			time = nil,
			stalker = { corpse = nil,
				    relation = nil },
			monstr	= { corpse = nil,
				    power = nil },
			item 	= { power = nil }
			}

	self.stype3 = { snd_type.weapon,
			snd_type.shoot,
			snd_type.bullet_hit,
			snd_type.reload,
			snd_type.die,
			snd_type.injure,
			snd_type.attack,
			snd_type.object_explode,
			snd_type.world_object_explode
			}
	self.stype2 = {	snd_type.item,
			snd_type.talk,
			snd_type.world,
			snd_type.pick_up,
			snd_type.drop,
			snd_type.hide,
			snd_type.take,
			snd_type.use,
			snd_type.step,
			snd_type.eat,
			snd_type.object_break,
			snd_type.object_collide,
			snd_type.world_object_break,
			snd_type.world_object_collide
			}
	self.stype1 = {	snd_type.anomaly,
			snd_type.monster
			}
	self.time_reaction = 1500 	-- 1.5 секунд
	self.time_memory = 600000 	-- 5 минут
	self.visio	= 0.25 		-- если объект виден
end
function events:calculate()  -- Производить перерасчет и обновление раздражителей для текущего элемента
	self.arhive = {}	

	-- удалять обработанные устаревшие раздражители
	local dt = {}
	for k,v in self.used do
		if device():time_global() - v >= self.time_memory then
			table.insert(dt, k)
		end		
	end
	for k,v in dt do
		self:removeFromUsed(v)
	end

	-- удалять из self.hear звуки старше x секунд
	dt = {}
	for k,v in self.hear do
		if (device():time_global() - v) > 2*self.time_reaction then
			table.insert(dt, k)
		end
	end
	for k,v in dt do
		table.remove(self.hear, v)
	end

	-- определяем что нам известно о звуке объекта
	local stable = self.npc:memory_sound_objects()
	if stable == nil then return false end
	for s in stable do
		local so = s:object()
		local so_id = so:clsid()
		local continue = true
		local stime = s.level_time
	
		if self.hear[so:id()] ~= nil then
			if stime - self.hear[so:id()] < self.time_reaction then
				continue = false
			end
		end

		if self.used[so:id()] ~= nil then
			continue = false
		end

		if self.npc:position():distance_to(so:position()) > 30 then
			continue = false
		end

		if (so_id == clsid.stalker or so_id == clsid.actor) then
			if (so:squad() == self.npc:squad() and 
			   so:group() == self.npc:group()) or
                           (device():time_global() - stime > self.time_reaction)
			then
				continue = false
			end
		end

		if continue then
			if self.hear[so:id()] == nil then
				table.insert(self.hear, so:id(), stime)
			else
				self.hear[so:id()] = stime
			end
		end

		if continue then
		        local ll = "none"
			for j,i in self.stype1 do
				if bit_and (s:type(), i) == i then 
					ll = "type1"
					break
				end
			end
			for j,i in self.stype2 do
				if bit_and (s:type(), i) == i then 
					ll = "type2" 
					break
				end
			end
			for j,i in self.stype3 do
				if bit_and (s:type(), i) == i then 
					ll = "type3"
					break
				end
			end
			                                
			-- заносим раздражитель в память
			if self.arhive[so:id()] == nil then
				self.arhive[so:id()] = {visibility = self.descr.visibility,
							sound_kat = self.descr.sound_kat,
							sound_power = self.descr.sound_power,
							object_type = self.descr.object_type,
							point = self.descr.point,
							time = self.descr.time,
							stalker = { corpse = self.descr.stalker.corpse,
								    relation = self.descr.stalker.relation},
							monstr	= { corpse = self.descr.monstr.corpse,
								    power = self.descr.monstr.power},
							item 	= { power = self.descr.item.power}}
			end
			-- указываем, что нам о нем известно
			self.arhive[so:id()].sound_kat 		= ll
			self.arhive[so:id()].sound_power 	= s.power
			self.arhive[so:id()].point 		= so:level_vertex_id()
			self.arhive[so:id()].time		= stime
		end
	end

	-- определяем что нам известно о видимости объекта
	local vtable = self.npc:not_yet_visible_objects()
	if vtable == nil then return false end
	for v in vtable do
		local vo = v:object()
		local vo_id = vo:clsid()
		local continue = true

		if (vo_id == clsid.stalker or vo_id == clsid.actor) then
			if vo:squad() == self.npc:squad() and 
			   vo:group() == self.npc:group()
			then
				continue = false
			end
		end

		if self.used[vo:id()] ~= nil then
			continue = false
		end

		local pers_visio = v.value / self.npc:visibility_threshold()

		if pers_visio < self.visio then
			continue = false
		end

		if continue then
			-- заносим раздражитель в память
			if self.arhive[vo:id()] == nil then
				self.arhive[vo:id()] = {visibility = self.descr.visibility,
							sound_kat = self.descr.sound_kat,
							sound_power = self.descr.sound_power,
							object_type = self.descr.object_type,
							distance = self.descr.distance,
							time = self.descr.time,
							stalker = { corpse = self.descr.stalker.corpse,
								    relation = self.descr.stalker.relation},
							monstr	= { corpse = self.descr.monstr.corpse,
								    power = self.descr.monstr.power},
							item 	= { power = self.descr.item.power}}
			end
			-- указываем, что нам о нем известно
			self.arhive[vo:id()].point 		= vo:level_vertex_id()
			self.arhive[vo:id()].visibility		= pers_visio
			self.arhive[vo:id()].time		= device():time_global()
			if v.value >= self.npc:visibility_threshold() then
				self.arhive[vo:id()].object_type = self:type(vo)

				if self.arhive[vo:id()].object_type == "stalker" then
					self.arhive[vo:id()].stalker.corpse = not vo:alive()
					self.arhive[vo:id()].stalker.relation = self.npc:relation(vo)
				elseif self.arhive[vo:id()].object_type == "monstr" then
					self.arhive[vo:id()].monstr.corpse = not vo:alive()
					self.arhive[vo:id()].monstr.power = self:monstr_power(vo)
				elseif self.arhive[vo:id()].object_type == "item" then
					self.arhive[vo:id()].item.power = self:item_power(vo)
				end
			end
		end
	end
end
function events:get_event(tt)  -- Выдает наиболее приоритетный раздражитель
	local prior = nil

	for key,value in self.arhive do
		local cc = false

		-- Если он в уже отработанных - игнорировать
		for k,v in self.used do
			if key == k then
				cc = true
				break
			end
		end

		-- Проверяем есть ли у нас лучший
		if not cc and prior == nil then 
			prior = key
			cc = true
		end

		-- проверка по приоритету: нетруп(неитем) - труп - итем
		local is_this_item = value.object_type == "item"
		local is_this_corpse = (value.object_type == "stalker" and value.stalker.corpse == true) or
				       (value.object_type == "monstr" and value.monstr.corpse == true)

		local is_prior_item = self.arhive[prior].object_type == "item"
		local is_prior_corpse = (self.arhive[prior].object_type == "stalker" and self.arhive[prior].stalker.corpse == true) or
				      	(self.arhive[prior].object_type == "monstr" and self.arhive[prior].monstr.corpse == true)

		if not cc and (is_this_corpse and is_prior_item) or
		   (not is_this_item and not is_this_corpse and
			(is_prior_item or is_prior_corpse)) then
			prior = key
			cc = true
		end

		-- проверка по приоритету: сталкер - монстр (только если не итем)
		if not cc and not is_this_item and not is_prior_item then
			if value.object_type == "stalker" and self.arhive[prior].object_type == "monstr" then
				prior = key
				cc = true
			end
		end

		-- проверка по зрению - слуху
		local is_this_vision = value.visibility ~= nil
		local is_prior_vision = self.arhive[prior].visibility ~= nil

		if not cc and is_this_vision and not is_prior_vision then
			prior = key
			cc = true
		end                     

		-- проверка по качеству зрения
		if not cc and is_this_vision and is_prior_vision then
			if value.visibility > self.arhive[prior].visibility then
				prior = key
				cc = true
			end
		end
        
		-- проверка по качеству слуха
		if not cc and not is_this_vision and not is_prior_vision then
			-- проверка по типу звука
			if not cc and (value.sound_kat == "type3" and self.arhive[prior].sound_kat ~= "type3") or 
			    (value.sound_kat == "type2" and self.arhive[prior].sound_kat == "type1") then
				prior = key
				cc = true
			end

			if not cc and value.sound_power > self.arhive[prior].sound_power then
				prior = key
				cc = true
			end
		end
	end
	-- должна выдавать:
	if prior == nil then return end

	-- позицию раздражителя
	tt.position = self.arhive[prior].point
	-- id раздражителя
	tt.id = prior
	-- указатель, что мы получили раздражитель от объекта, за которым мы следим
	if self.watch[prior] ~= nil then
		tt.watched = true
	end
	-- визуальный или звуковой (в случае визуального передается процент его визуальности)
	tt.isVisual = self.arhive[prior].visibility
end
function events:markAsUsed(npc)
	if npc ~= nil then
		if self.used[npc] ~= nil then 
			self.used[npc] = device():time_global()
		else
			table.insert(self.used, npc, device():time_global())
		end
	end
end
function events:removeFromUsed(npc)
	if self.used[npc] ~= nil then
		table.remove(self.used, npc)	
	end
end
function events:markAsWatch(npc)
	if npc ~= nil then
		if self.watch[npc] == nil then 
			table.insert(self.watch, npc, npc)
		end
	end
end
function events:removeFromWatch(npc)
	if self.watch[npc] ~= nil then
		table.remove(self.watch, npc)	
	end
end
function events:isEvents()
	local tt = false
	for key,value in self.arhive do 
		local exst = false
		for k,v in self.used do
			if key == k then
				exst = true
				break
			end
		end		
		if not exst then
			tt = true
			break
		end
	end
	return tt
end
function events:print()
	for key,value in self.arhive do 
		printf("------------------------ Object: %d ------------------------", key)
		if value.visibility then 	printf("Visibility: %.3f", value.visibility)
					else 	printf("Visibility: nil") end
		if value.sound_power then 	printf("Sound power: %.3f", value.sound_power)
					else 	printf("Sound power: nil") end
		if value.sound_kat then 	printf("Sound kat: %s", value.sound_kat)
					else 	printf("Sound kat: nil") end
		if value.time then 		printf("Time: %d", value.time)
					else 	printf("Time: nil") end
		if value.point then 		printf("Point: %d", value.point)
					else 	printf("Point: nil") end
		if value.object_type then 	printf("Object type: %s", value.object_type)
					else 	printf("Object type: nil") end
		-- stalker print
		if value.stalker.corpse == true then	printf("Corpse") end
		if value.stalker.relation == game_object.friend then		printf("Relation: Friend") 
		elseif value.stalker.relation == game_object.neutral then	printf("Relation: Neutral") 
		elseif value.stalker.relation == game_object.enemy then		printf("Relation: Enemy") end

		-- monstr print
		if value.monstr.corpse == true then	printf("Corpse") end
		if value.monstr.power == true then	printf("Powerfull") end

		-- item print
		if value.item.power == true then	printf("Powerfull") end

        	-- watched print
		for k,v in self.watch do
			if key == v then
				printf("watch")
				break
			end
		end
	end
end
function events:type(obj)
	local otype = obj:clsid()

	if 	otype == clsid.actor or
  	   	otype == clsid.soldier or
	   	otype == clsid.stalker or
	   	otype == clsid.trader
	then 
		return "stalker"
	elseif 	otype == clsid.crow or
		otype == clsid.rat or
		otype == clsid.rat_group or
		otype == clsid.zombie or
		otype == clsid.flesh or
		otype == clsid.controller or
		otype == clsid.bloodsucker or
		otype == clsid.burer or
		otype == clsid.chimera or
		otype == clsid.boar or
		otype == clsid.idol or
		otype == clsid.flesh_group or
		otype == clsid.dog_red or
		otype == clsid.dog_black or
		otype == clsid.pseudo_gigant
	then 
		return "monstr"
	elseif	otype == clsid.wpn_fn2000 or
		otype == clsid.wpn_ak74 or
		otype == clsid.wpn_lr300 or
		otype == clsid.wpn_hpsa or
		otype == clsid.wpn_pm or
		otype == clsid.wpn_fort or
		otype == clsid.wpn_binocular or
		otype == clsid.wpn_shotgun or
		otype == clsid.wpn_svd or
		otype == clsid.wpn_svu or
		otype == clsid.wpn_rpg7 or
		otype == clsid.wpn_val or
		otype == clsid.wpn_vintorez or
		otype == clsid.wpn_walther or
		otype == clsid.wpn_usp45 or
		otype == clsid.wpn_groza or
		otype == clsid.wpn_knife or
		otype == clsid.wpn_scope or
		otype == clsid.wpn_silencer or
		otype == clsid.wpn_grenade_launcher or
		otype == clsid.obj_physic or
		otype == clsid.obj_breakable or
		otype == clsid.device_pda or
		otype == clsid.device_torch or
		otype == clsid.device_detector_simple or
		otype == clsid.obj_bolt or
		otype == clsid.obj_medkit or
		otype == clsid.obj_food or
		otype == clsid.obj_bottle or
		otype == clsid.obj_antirad or
		otype == clsid.obj_explosive or
		otype == clsid.obj_document or
		otype == clsid.obj_attachable or
		otype == clsid.wpn_grenade_f1 or
		otype == clsid.wpn_grenade_rpg7 or
		otype == clsid.wpn_grenade_rgd5 or
		otype == clsid.wpn_grenade_fake or
		otype == clsid.equ_scientific or
		otype == clsid.equ_stalker or
		otype == clsid.equ_military or
		otype == clsid.equ_exo or
		otype == clsid.wpn_ammo or
		otype == clsid.wpn_ammo_vog25 or
		otype == clsid.wpn_ammo_og7b or
		otype == clsid.wpn_ammo_m209
	then 
		return "item"
	else
		return "none"
	end
end
function events:monstr_power(obj)
	local otype = obj:clsid()

	if	otype == clsid.zombie or
		otype == clsid.flesh or
		otype == clsid.controller or
		otype == clsid.bloodsucker or
		otype == clsid.burer or
		otype == clsid.chimera or
		otype == clsid.boar or
		otype == clsid.idol or
		otype == clsid.flesh_group or
		otype == clsid.dog_red or
		otype == clsid.dog_black or
		otype == clsid.pseudo_gigant
	then 
		return true
	else 	
		return false
	end
end
function events:item_power(obj)
	local otype = obj:clsid()

	if	otype == clsid.wpn_fn2000 or
		otype == clsid.wpn_ak74 or
		otype == clsid.wpn_lr300 or
		otype == clsid.wpn_hpsa or
		otype == clsid.wpn_pm or
		otype == clsid.wpn_fort or
		otype == clsid.wpn_binocular or
		otype == clsid.wpn_shotgun or
		otype == clsid.wpn_svd or
		otype == clsid.wpn_svu or
		otype == clsid.wpn_rpg7 or
		otype == clsid.wpn_val or
		otype == clsid.wpn_vintorez or
		otype == clsid.wpn_walther or
		otype == clsid.wpn_usp45 or
		otype == clsid.wpn_groza or
		otype == clsid.wpn_knife or
		otype == clsid.wpn_scope or
		otype == clsid.wpn_silencer or
		otype == clsid.wpn_grenade_launcher or
		otype == clsid.device_pda or
		otype == clsid.device_torch or
		otype == clsid.device_detector_simple or
		otype == clsid.obj_food or
		otype == clsid.obj_medkit or
		otype == clsid.obj_bottle or
		otype == clsid.obj_antirad or
		otype == clsid.obj_explosive or
		otype == clsid.obj_document or
		otype == clsid.obj_attachable or
		otype == clsid.wpn_grenade_f1 or
		otype == clsid.wpn_grenade_rpg7 or
		otype == clsid.wpn_grenade_rgd5 or
		otype == clsid.wpn_grenade_fake or
		otype == clsid.equ_scientific or
		otype == clsid.equ_stalker or
		otype == clsid.equ_military or
		otype == clsid.equ_exo or
		otype == clsid.wpn_ammo or
		otype == clsid.wpn_ammo_vog25 or
		otype == clsid.wpn_ammo_og7b or
		otype == clsid.wpn_ammo_m209
	then 
		return true
	else 	
		return false
	end
end