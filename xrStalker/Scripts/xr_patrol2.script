local Patrols = {}

local animations = {
                   {anim = "stoya_ruje_ 0",       flag = true},
                   {anim = "vishka_3",            flag = false},
                   {anim = "norm_torso_2_idle_1", flag = false},
                   {anim = "norm_torso_2_idle_2", flag = true},
                   {anim = "norm_torso_2_idle_3", flag = false},
                   {anim = "norm_torso_2_idle_4", flag = true},
                   {anim = "norm_torso_2_idle_5", flag = false},
                   {anim = "norm_torso_2_idle_6", flag = false}
                   }


local anim_pris = {
                  {anim = "prisluh_0", flag = false},
                  {anim = "prisluh_1", flag = false},
                  {anim = "prisluh_2", flag = false}
                  }

function GetPatrolPath (name)
    local scheme, command, squad, member = str_split (name)
    local str = string.format ("%s_%s_%d_%d", "path", command, squad, member)
    return str
end

local property_pathend_comm             = xr_evaluators_id.sidor_pathend_commander_property
local property_pathend_sold             = xr_evaluators_id.sidor_pathend_soldier_property

local action_move                       = stalker_ids.action_script + 1
local action_check_snd                  = action_move + 2
local action_check_corpse               = action_move + 3
local action_check_corpse_s             = action_move + 4


local property_corpse                   = property_pathend_comm + 1
local property_snd                      = property_pathend_comm + 2
local property_snd_end                  = property_pathend_comm + 3

local property_corpse_s                 = property_pathend_sold + 1


--sounds
local commander_snd                     = xr_sounds_id.sound_patrol_base
local soldiers_idle_snd                 = commander_snd + 1
local soldiers_hear_snd                 = commander_snd + 2
local soldiers_idle2_snd                = commander_snd + 3
local soldiers_replics_snd              = commander_snd + 4
local soldiers_corpse_snd               = commander_snd + 5

local num_hear_phrases      =   9
local num_phrases_idle2     =   2




-- corpse code
local corpse_not_found      =   0
local corpse_present        =   1
local corpse_replace        =   2

--leader states
local leader_move       =   0               --leader move for path
local leader_check      =   1               --leader stop on checkpoint
local leader_wait       =   2               --leader wait for him command
local leader_alarm      =   3               --leader move to base
local leader_collect    =   4               --leader move to collect
local leader_rotate     =   5               --leader rotate
local leader_move_fwd   =   6
local leader_move_bwd   =   7

--soldier states
local soldier_move      =   0
local soldier_check     =   1
local soldier_ready     =   2
local soldier_collect   =   3
local soldier_rotate    =   4
local soldier_alarm     =   5

local num_phrases = 10



----------------------------------------------------------------------------------------------------------------------
function get_random_vertex_id (npc, max_dist)
    local dir = vector ():set (math.random (-1.0, 1.0), 0.0, math.random (-1.0, 1.0))
    dir:normalize ()
    if max_dist == 0.0 then max_dist = math.random (2.0, 5.0) end
    local v = npc:position ()
    v.x = v.x + dir.x * max_dist
    v.z = v.z + dir.z * max_dist
    local vid = level.vertex_in_direction (npc:level_vertex_id (), dir, max_dist)
    return vid, v
end
----------------------------------------------------------------------------------------------------------------------
function get_angle (v1, v2)
    v1:normalize ()
    v2:normalize ()
    return (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z)
end

----------------------------------------------------------------------------------------------------------------------
--Evaluator const
----------------------------------------------------------------------------------------------------------------------
class "evaluator_const"    (property_evaluator)
----------------------------------------------------------------------------------------------------------------------
function evaluator_const:__init(value) super()
  self.value = value
end
----------------------------------------------------------------------------------------------------------------------
function evaluator_const:evaluate()
  return self.value
end

----------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------
class "evaluator_corpse" (property_evaluator)
----------------------------------------------------------------------------------------------------------------------
function evaluator_corpse:__init () super ()
    self.vertex_id = -1
    self.corpse_present = false
    self.corpse = nil
    self.corpses = {}
end
----------------------------------------------------------------------------------------------------------------------
function evaluator_corpse:evaluate ()

    if self.corpse_present == true then return true end

    local vtable = self.object:memory_visible_objects ()
    if vtable == nil then return false end

    local time = device ():time_global ()

    for a in vtable do
        local go = a:object ()
        local id = go:clsid ()
        if id == clsid.soldier or id == clsid.stalker or id == clsid.actor then
           if go:alive () == false and a.level_time == time and self:is_corpse_present (go) == false then
              self.vertex_id = go:level_vertex_id ()
              self.corpse_present = true
              self.corpse = go
              table.insert (self.corpses, go)

              local act = self.object:motivation_action_manager ():action (xr_actions_id.sidor_act_commander)
              if act ~= nil and act.members ~= nil and table.getn (act.members) ~= 0 then
                 for a = 1, table.getn (act.members), 1 do
                     local eva = act.members[a].object:motivation_action_manager ():evaluator (property_corpse_s)
                     if eva ~= nil then
                        eva.vertex_id = go:level_vertex_id ()
                        eva.corpse = go
                        eva.corpse_present = true
                     end
                 end
              end
              return true
           end
        end
    end
    return false
end
----------------------------------------------------------------------------------------------------------------------
function evaluator_corpse:is_corpse_present (corpse)
    local size = table.getn (self.corpses)
    if size == 0 then return false end

    for a = 1, size, 1 do
        if self.corpses[a]:id () == corpse:id () then
           return true
        end
    end

    return false
end
----------------------------------------------------------------------------------------------------------------------
function evaluator_corpse:set_corpse (corpse)
    self.vertex_id = corpse:level_vertex_id ()
    self.corpse_present = true
    self.corpse = corpse
    table.insert (self.corpses, corpse)
end
----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------
class "evaluator_corpse_s" (property_evaluator)
----------------------------------------------------------------------------------------------------------------------
function evaluator_corpse_s:__init () super ()
    self.vertex_id = -1
    self.corpse_present = false
    self.corpse = nil
    self.first_view = false
end
----------------------------------------------------------------------------------------------------------------------
function evaluator_corpse_s:evaluate ()

    if self.corpse_present == true then return true end
    self.first_view = false

    local vtable = self.object:memory_visible_objects ()
    if vtable == nil then return false end

    local time = device ():time_global ()

    for a in vtable do
        local go = a:object ()
        local id = go:clsid ()
        if id == clsid.soldier or id == clsid.stalker or id == clsid.actor then
           if go:alive () == false and a.level_time == time then
              local res = self:is_corpse_present (go)
              if res == corpse_present then return false
              elseif res == corpse_replace or res == corpse_not_found then
                     return true
              end
           end
        end
    end
    return false
end
----------------------------------------------------------------------------------------------------------------------
function evaluator_corpse_s:is_corpse_present (corpse)
    local scheme, name, command, squad = str_split (self.object:name ())


    local index = this.FindLeader (name, command)

    if index == 0 then
       return corpse_not_found
    end

    if Patrols[index].npc:alive () == false then return corpse_not_found end

    local eva = Patrols[index].npc:motivation_action_manager ():evaluator (property_corpse)

    if eva == nil then return corpse_present end

    if eva:is_corpse_present (corpse) == true then
       return corpse_present
    end

    if eva.corpse_present == true then
       self.corpse = eva.corpse
       self.vertex_id = corpse:level_vertex_id ()
       self.corpse_present = true
       --printf ("Corpse replace")
       return corpse_replace
    end

    self.corpse = corpse
    self.vertex_id = corpse:level_vertex_id ()
    self.corpse_present = true
    eva:set_corpse (corpse)
    --printf ("Corpse not found")
    self.first_view = true
    return corpse_not_found
end
----------------------------------------------------------------------------------------------------------------------



local sound_unknown     =   -1
local sound_human       =   0
local sound_mutant      =   1
----------------------------------------------------------------------------------------------------------------------
class "evaluator_snd" (property_evaluator)
----------------------------------------------------------------------------------------------------------------------
function evaluator_snd:__init () super ()
    self.heared = false
    self.callback_set = false
    self.snd_type = sound_unknown
    self.old_snd_src = nil
    self.sound_source = nil
    self.power = 0.0
end
----------------------------------------------------------------------------------------------------------------------
function evaluator_snd:evaluate ()

    if self.callback_set == false then
       self.object:set_hear_callback (self, "hear_callback")
       self.callback_set = true
       return false
    end

    return self.heared
end
----------------------------------------------------------------------------------------------------------------------
function evaluator_snd:hear_callback (obj, who, sound_type, sound_position, sound_power)
    if who == nil or who:alive () == false then return end

    if sound_power < 0.2 then return end

    if who:team () == self.object:team () and who:squad () == self.object:squad () then
       return
    end

    if self.heared == true then return end

    if bit_and (sound_type, snd_type.weapon) == snd_type.weapon or bit_and (sound_type, snd_type.pick_up) == snd_type.pick_up then
       self.heared = true
       self.snd_type = sound_human
       --printf ("Sound received from %s, type %.8x, power %f", who:name (), sound_type, sound_power)
       self.sound_source = who
       self.power = sound_power
    end

    if bit_and (sound_type, snd_type.monster) == snd_type.monster then
       if self.old_snd_src ~= nil and self.old_snd_src:id () == who:id () then
          return
       end
       self.heared = true
       self.snd_type = sound_mutant
       --printf ("Sound received from %s, type %.8x, power %f", who:name (), sound_type, sound_power)
       self.sound_source = who
       self.power = sound_power
    end
end
----------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------
-- Action corpse
----------------------------------------------------------------------------------------------------------------------
class "action_corpse" (action_base)
----------------------------------------------------------------------------------------------------------------------
function action_corpse:__init (name) super (nil, name)
    self.corpse_vertex_id = -1
    self.corpse = nil
    self.stage = 0
    self.soldier_corpse = false
    self.dir = vector ():set (0, 0, 0)
    self.current_animation = 0
end
----------------------------------------------------------------------------------------------------------------------
function action_corpse:initialize ()

    action_base.initialize (self)
    local eva = self.object:motivation_action_manager ():evaluator (property_corpse)
    self.corpse_vertex_id = eva.vertex_id
    self.corpse = eva.corpse

    local id = self.corpse:clsid ()
    if id == clsid.stalker then
       self.soldier_corpse = false
    else
       self.soldier_corpse = true
    end

    local p1 = self.corpse:position ()
    local p2 = self.object:position ()
    local dir = vector ():set (p1.x - p2.x, p1.y - p2.y, p1.z - p2.z)
    dir:normalize ()

    self.object:set_node_evaluator        ()
    self.object:set_path_evaluator        ()
    self.object:set_desired_position      ()
    self.object:set_desired_direction     (dir)
    self.object:set_item                  (object.idle, self.object:best_weapon ())
    self.object:set_detail_path_type      (move.line)
    self.object:set_body_state            (move.standing)
    self.object:set_movement_type         (move.walk)
    self.object:set_path_type             (game_object.level_path)
    self.object:set_dest_level_vertex_id  (self.corpse_vertex_id)
    self.object:set_body_state(move.standing) -- added by Zmey: crash bug fix: always set body standing to standing when setting mental state to anim.free
    self.object:set_mental_state          (anim.free)
    self.object:set_sight                 (look.path_dir, nil, 0)
    self.stage = 0

    self.object:set_sound_mask (2147483647)
    self.object:set_sound_mask (0)
    self.object:play_sound (soldiers_corpse_snd , 1000, 1000, 1, 0, 2)    --num_replics_snd

end
----------------------------------------------------------------------------------------------------------------------
function action_corpse:execute ()
    action_base.execute (self)

    if self.corpse == nil then
       self.object:motivation_action_manager ():evaluator (property_corpse).corpse_present = false
       return
    end

    if distance_between (self.object, self.corpse) > 1 and self.stage ~= 1 then
       self.stage = 0
       return
    end

    local pos_our = self.object:position ()
    local pos_corpse = self.corpse:position ()
    self.dir = vector ():set (pos_corpse.x - pos_our.x, 0, pos_corpse.z - pos_our.z)
    self.dir:normalize ()
    self.object:set_sight (look.direction, self.dir, 0)

    self.object:set_movement_type         (move.stand)

    if self.stage == 0 then
       if self.soldier_corpse == true then
          self.object:add_animation ("vishka_1", true)
       else
          self.object:add_animation ("vishka_1", true)
       end
       self.stage = 1
       --self:set_animation ()
       return
    end

    if self.stage == 1 and self.object:animation_count () == 0 then
       self.object:set_sound_mask (2147483647)
       self.object:set_sound_mask (0)
       self.object:play_sound (soldiers_corpse_snd , 1, 0, 1, 0, 0)    --num_replics_snd
       self.object:motivation_action_manager ():evaluator (property_corpse).corpse_present = false
       self.dir.x = -self.dir.x
       self.dir.z = -self.dir.z
       self.object:set_sight (look.direction, self.dir, 0)
       return
    end
end
----------------------------------------------------------------------------------------------------------------------
function action_corpse:finalize ()
    self.object:clear_animations ()
    action_base.finalize (self)
    local act = self.object:motivation_action_manager ():action (xr_actions_id.sidor_act_commander)
    if act == nil or table.getn (act.members) == 0 then
       return
    end

    for a = 1, table.getn (act.members), 1 do
        act.members[a].object:motivation_action_manager ():evaluator (property_corpse_s).corpse_present = false
    end
end
----------------------------------------------------------------------------------------------------------------------
function action_corpse:set_animation ()

    self.current_animation = self.current_animation + 1
    if self.current_animation > table.getn (animations) then
       self.current_animation = 1
    end

    self.object:add_animation (animations[self.current_animation].anim, animations[self.current_animation].flag)
end







----------------------------------------------------------------------------------------------------------------------
-- Action corpse soldier
----------------------------------------------------------------------------------------------------------------------
class "action_corpse_s" (action_base)
----------------------------------------------------------------------------------------------------------------------
function action_corpse_s:__init (name) super (nil, name)
    self.corpse_vertex_id = -1
    self.corpse = nil
    self.stage = 0
    self.soldier_corpse = false
    self.current_animation = 1
end
----------------------------------------------------------------------------------------------------------------------
function action_corpse_s:initialize ()

    action_base.initialize (self)

    local eva = self.object:motivation_action_manager ():evaluator (property_corpse_s)
    self.corpse_vertex_id = eva.vertex_id
    self.corpse = eva.corpse

    if self.corpse == nil then
       self.object:motivation_action_manager ():evaluator (property_corpse_s).corpse_present = false
       return
    end


    self.corpse_vertex_id = this.get_random_vertex_id (self.corpse, 5)

    local id = self.corpse:clsid ()
    if id == clsid.stalker then
       self.soldier_corpse = false
    else
       self.soldier_corpse = true
    end

    local p1 = self.corpse:position ()
    local p2 = self.object:position ()
    local dir = vector ():set (p1.x - p2.x, p1.y - p2.y, p1.z - p2.z)
    dir:normalize ()

    self.object:set_node_evaluator        ()
    self.object:set_path_evaluator        ()
    self.object:set_desired_position      ()
    self.object:set_desired_direction     (dir)
    self.object:set_item                  (object.idle, self.object:best_weapon ())
    self.object:set_detail_path_type      (move.line)
    self.object:set_body_state            (move.standing)
    self.object:set_movement_type         (move.walk)
    self.object:set_path_type             (game_object.level_path)
    self.object:set_dest_level_vertex_id  (self.corpse_vertex_id)
    self.object:set_mental_state          (anim.free)
    self.object:set_sight                 (look.path_dir, nil, 0)
    self.stage = 0

    local __name, __command, __group, __member = str_split (self.object:name ())
    self.current_animation = __member


    self.object:set_sound_mask (-1)   --2147483647
    self.object:set_sound_mask (0)

    if self.object:motivation_action_manager ():evaluator (property_corpse_s).first_view == true then
       self.object:play_sound (soldiers_replics_snd    , 1, 0, 1, 0, 0)    --num_replics_snd
    end

end
----------------------------------------------------------------------------------------------------------------------
function action_corpse_s:execute ()
    action_base.execute (self)

    if self.corpse == nil then
       self.object:motivation_action_manager ():evaluator (property_corpse_s).corpse_present = false
       return
    end

    if distance_between (self.object, self.corpse) > 3 then
       return
    end

    self.object:set_movement_type         (move.stand)

    if self.stage == 0 then
       self:set_animation ()
       self.stage = 1
       return
    end

    if self.stage == 1 and self.object:animation_count () == 0 then
       self.object:set_sound_mask (-1)
       self.object:set_sound_mask (0)
       self.object:play_sound (soldiers_corpse_snd , 1000, 1000, 1, 0, 1)    --num_replics_snd
       self.object:motivation_action_manager ():evaluator (property_corpse_s).corpse_present = false
       return
    end
end
----------------------------------------------------------------------------------------------------------------------
function action_corpse_s:finalize ()
    self.object:clear_animations ()
    action_base.finalize (self)
end
----------------------------------------------------------------------------------------------------------------------
function action_corpse_s:set_animation ()

    self.current_animation = self.current_animation + 1
    if self.current_animation > table.getn (animations) then
       self.current_animation = 1
    end

    self.object:add_animation (animations[self.current_animation].anim, animations[self.current_animation].flag)

end



----------------------------------------------------------------------------------------------------------------------
-- Action sound
----------------------------------------------------------------------------------------------------------------------
class "action_snd" (action_base)
------------------------------------------------------
function action_snd:__init (name) super (nil, name)
    self.check_vertex_id = -1
    self.time = 0
    self.current_animation = 1
    self.sound_position = vector ():set (0, 0, 0)
    self.sound_vertex_id = -1
    self.stage = 0
    self.sound_dir = vector ():set (0, 0, 0)
    self.leader_index = 0
end
------------------------------------------------------
function action_snd:initialize ()

    action_base.initialize (self)
    self.object:clear_animations ()

    self.object:set_node_evaluator        ()
    self.object:set_path_evaluator        ()
    self.object:set_desired_position      ()
    self.object:set_desired_direction     ()
    self.object:set_item                  (object.idle, self.object:best_weapon ())
    self.object:set_detail_path_type      (move.line)
    self.object:set_movement_type         (move.stand)
    self.object:set_body_state            (move.standing)
    self.object:set_mental_state          (anim.danger)
    self.time = device ():time_global ()


    local __name, __command, __group, __member = str_split (self.object:name ())
    self.current_animation = __member

    self.leader_index = this.FindLeader (__command, __group)
    if self.leader_index ~= 0 then
       if Patrols[self.leader_index].npc:id () == self.object:id () then
          self.leader_index = 0
       end
    end

    local eva = self.object:motivation_action_manager ():evaluator (property_snd)
    if eva == nil or eva.sound_source == nil then return end

    self.sound_vertex_id, self.sound_position = this.get_random_vertex_id (eva.sound_source, 0.0)
    local our_pos = self.object:position ()
    self.sound_dir = vector ():set (self.sound_position.x - our_pos.x, 0.0,  self.sound_position.z - our_pos.z)

    self.object:set_sight (look.fire_point, self.sound_position, 0)

    if self.leader_index == 0 then
       self.object:set_sound_mask (-1)
       self.object:set_sound_mask (0)
       self.object:play_sound (soldiers_hear_snd, 1, 0, 1, 0, math.random (0, num_hear_phrases - 1))
    end

    self.stage = 0

end
------------------------------------------------------
function action_snd:execute ()
    action_base.execute (self)

    local eva = self.object:motivation_action_manager ():evaluator (property_snd)
    if eva ~= nil and eva.sound_source ~= nil then
       if eva.sound_source:alive () == false then
          eva.heared = false
          eva.old_snd_src = nil
          eva.sound_source = nil
          return
       end
    end

    if self.stage == 0 then
       local angle = this.get_angle (self.object:direction (), self.sound_dir)
       if angle < 0.8 then return end
       self.object:set_sight (look.direction, self.object:direction (), 0)
       if eva.snd_type == sound_mutant or eva.snd_type == sound_unknown then
          self.stage = 1
          self:set_animation ()
          return
       elseif eva.snd_type == sound_human then
          if self.sound_vertex_id == -1 then
             --printf ("PATROL : INVALID VERTEX ID")
             self.stage = 1
          else
             self.stage = 3
          end
          --self:set_animation ()
          return
       end
    end

    if self.stage == 1 then
       if self.object:animation_count () == 0 then
          if self.leader_index == 0 then
             self.object:set_sound_mask (2147483647)
             self.object:set_sound_mask (0)
             self.object:play_sound (soldiers_idle2_snd, 1, 0, 1, 0, math.random (0, num_phrases_idle2 - 1))
          end
          local eva = self.object:motivation_action_manager ():evaluator (property_snd)
          eva.heared = false
          eva.old_snd_src = eva.sound_source
       end
       return
    end

    if self.stage == 2 then
       if self.sound_position:distance_to (self.object:position ()) < 2 then
          self.stage = 1
          self.object:set_movement_type (move.stand)
       end
       return
    end

    if self.stage == 3 then
       --if self.object:animation_count () == 0 then
          self.object:set_item                  (object.activate, self.object:best_weapon ())
          self.object:set_detail_path_type      (move.line)
          self.object:set_body_state            (move.standing)
          self.object:set_movement_type         (move.walk)
          self.object:set_path_type             (game_object.level_path)
          self.object:set_dest_level_vertex_id  (self.sound_vertex_id)
          self.object:set_mental_state          (anim.danger)
          self.object:set_sight                 (look.path_dir, nil, 0)
          self.stage = 2
       --end
    end

end
------------------------------------------------------
function action_snd:finalize ()
    action_base.finalize (self)
    self.object:clear_animations ()
end
------------------------------------------------------
function action_snd:set_animation ()

    self.current_animation = self.current_animation + 1
    if self.current_animation > table.getn (anim_pris) then
       self.current_animation = 1
    end

    self.object:add_animation (anim_pris[self.current_animation].anim, anim_pris[self.current_animation].flag)

end
----------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------
-- Action path
----------------------------------------------------------------------------------------------------------------------
-- Ёкшен дл€ перемещени€ по патрульному пути
----------------------------------------------------------------------------------------------------------------------
class "action_path" (action_base)

function action_path:__init (path, group, command, name) super (nil, name)
    self.path = path
    self.group = group
    self.command = command
    self.state = leader_move
    self.first_call = true
    self.members = {}
    self.move_direction = true
    self.c_waypoint = 0
    self.n_waypoint = 1
    self.waypoints = patrol (self.path):count () - 1
    self.target_point = vector ():set (0, 0, 0)
    self.c_time = 0
    self.need_rotate = false
    self.talk_time = 0
    self.current_talk = 0
    self.start_talk = 0
    self.command_sended = false
end
----------------------------------------------------------------------------------------------------------------------
function action_path:initialize ()

    action_base.initialize (self)
    self.object:set_node_evaluator        ()
    self.object:set_path_evaluator        ()
    self.object:set_desired_position      ()
    self.object:set_desired_direction     ()

    --self.object:play_sound                (2, 60000, 10000)
    self.object:set_item                  (object.idle, self.object:best_weapon ())
    self.object:set_detail_path_type      (move.line)
    self.object:set_body_state            (move.standing)
    self.object:set_sight                 (look.path_dir, nil, 0)


    self.object:set_callback (self, "move_callback", game_object.movement)

    local __name, __command, __group, __member = str_split (self.object:name ())
    self.current_animation = __member
    self:check_path ()
    self:move_to_collect ()
    self.need_rotate = false
    self.talk_time = math.random (20000, 40000)
    self.start_talk = device ():time_global ()
    self.current_talk = 0
    self.current_phrase = 0
    self.command_sended = false
end
----------------------------------------------------------------------------------------------------------------------
function action_path:move_to_collect ()
    local way           = patrol (self.path)
    local position      = self.object:position ()
    local i_nearest     = way:get_nearest        (position)
    local waypoint      = way:point              (i_nearest)
    local dir           = vector ():set (waypoint.x - position.x, 0, waypoint.z - position.z)
    dir:normalize ()
    self.c_waypoint     = i_nearest
    self.object:set_path_type               (game_object.level_path)
    self.object:set_dest_level_vertex_id    (way:level_vertex_id (i_nearest))
    self.object:set_desired_position        (way:point (i_nearest))
    self.object:set_desired_direction       ()  --dir
    self.object:set_body_state(move.standing) -- added by Zmey: crash bug fix: always set body standing to standing when setting mental state to anim.free
    self.object:set_mental_state            (anim.free)
    self.object:set_movement_type           (move.walk)
--    self.object:set_sight                   (look.fire_point, vector ():set (waypoint.x, waypoint.y + 1.5, waypoint.z), 0)
    self.object:set_sight                   (look.path_dir, nil, 0)
    self.target_point = waypoint
    self.state = leader_collect
end
----------------------------------------------------------------------------------------------------------------------
function action_path:send_command (command, target)
    local size = table.getn (self.members)
    if size == 0 then return end
    for a = 1, size, 1 do
        if self.members[a].object:alive () == true then
           self.members[a].action:send_command (command, target)
        end
    end
end
----------------------------------------------------------------------------------------------------------------------
function action_path:check_path ()

    if self.move_direction == true then
       if self.c_waypoint == self.waypoints then
          self.move_direction = false
          --self.c_waypoint = count
          self.n_waypoint = self.c_waypoint - 1
       else
          self.n_waypoint = self.c_waypoint + 1
       end
    else
       if self.c_waypoint == 0 then
          self.n_waypoint = 1
          self.move_direction = true
       else
          self.n_waypoint = self.c_waypoint - 1
       end
    end

end
----------------------------------------------------------------------------------------------------------------------
function action_path:set_alarm ()
    self.n_waypoint = self.c_waypoint - 1
    self.move_direction = false
    self:check_path ()
    self.object:clear_animations ()
    self.object:set_path_type  (game_object.level_path)
    self.object:set_path_type  (game_object.patrol_path)
    self.object:set_patrol_path (self.path, patrol.custom, patrol.continue, true)
    self.object:set_desired_direction ()
    self.object:set_desired_position ()
    self.object:set_previous_point (self.c_waypoint)
    self.object:set_start_point (self.n_waypoint)
    self.object:set_body_state(move.standing) -- added by Zmey: crash bug fix: always set body standing to standing when setting mental state to anim.free
    self.object:set_mental_state (anim.danger)
    self.state = leader_alarm
    self.object:set_movement_type (move.run)
    self.object:set_sight (look.path_dir, nil, 0)
    self:send_command (leader_alarm)
end
----------------------------------------------------------------------------------------------------------------------
function action_path:talking ()
    local size = table.getn (self.members)
    if size < 1 then return end

    self.current_talk = self.current_talk + 1
    if self.current_talk > size then
       self.current_talk = 0
    end

    if self.current_talk ~= 0 then
       if self.members[self.current_talk].object:alive () == false then
          return
       end
    end

    if self.current_talk == 0 then
       self.object:play_sound (soldiers_idle_snd, 1, 0, 1, 0, self.current_phrase)
    else
       self.members[self.current_talk].action:talk (self.current_phrase)
    end
    self.current_phrase = self.current_phrase + 1
    if self.current_phrase >= num_phrases then self.current_phrase = 0 end
    self.talk_time = math.random (20000, 40000)
    self.start_talk = device ():time_global ()

end
----------------------------------------------------------------------------------------------------------------------
function action_path:execute ()

    action_base.execute (self)

    if self.talk_time == 0 then
       self:talking ()
    else
       if device ():time_global () - self.start_talk > self.talk_time then
          self.talk_time = 0
       end
    end


    self.object:set_item (object.idle, self.object:best_weapon ())

    if self.state == leader_collect then
       self:check_collect ()
    elseif self.state == leader_check then
       self:checkpoint ()
    elseif self.state == leader_move then
       self:set_move ()
    elseif self.state == leader_rotate then
       self:rotate ()
    elseif self.state == leader_alarm then
       self:move_to_base ()
    end


end
----------------------------------------------------------------------------------------------------------------------
function action_path:check_members_alive ()
    local size = table.getn (self.members)
    if size == 0 then
       return false
    end

    for a = 1, size, 1 do
        if self.members[a].object:alive () == true then
           return true
        end
    end
    return false
end
----------------------------------------------------------------------------------------------------------------------
function action_path:checkpoint ()

    self.object:set_movement_type (move.stand)
    if self:check_members_alive () == false then
       if self.object:animation_count () == 0 then
          self.object:clear_animations ()
          self.c_time = device ():time_global ()
          self.state = leader_rotate
       end
    else
       if self.object:animation_count () == 0 then
          for a = 1, table.getn (self.members), 1 do
              local state = self.members[a].action:get_state ()
              if state == soldier_collect then
                 self:set_animation ()
                 return
              end
              if state ~= soldier_ready then
                 self:set_animation ()
                 return
              end
          end
          self.object:clear_animations ()
          self:set_move ()

          local way = patrol (self.path)
          if way:flag (self.c_waypoint, 0) == true then
             self.object:play_sound (commander_snd, 1, 0, 1, 0, 2)
          elseif way:flag (self.c_waypoint, 2) == true then
             self.object:play_sound (commander_snd, 1, 0, 1, 0, 1)
          end
       end
    end
    --printf ("Set checkpoint")

end
----------------------------------------------------------------------------------------------------------------------
function action_path:move_to_base ()

    local way = patrol (self.path)
    if way:point (0):distance_to (self.object:position ()) < 2.0 then
       self:move_to_collect ()
    end
end
----------------------------------------------------------------------------------------------------------------------
function action_path:rotate ()

    if self.need_rotate == true then
       --printf ("This is test")
       local pos = patrol (self.path):point (self.n_waypoint)
       pos.y = pos.y + 1.5
       self.object:set_sight (look.fire_point, pos, 0)
       if device ():time_global () - self.c_time > 1000 then
          self.state = leader_move
          self:set_move ()
          self.need_rotate = false
       end
    else
       self.state = leader_move
       self:set_move ()
    end


end
----------------------------------------------------------------------------------------------------------------------
function action_path:check_collect ()
    if self.target_point:distance_to (self.object:position ()) > 0.5 then
       --if self.command_sended == false then
          self:send_command (leader_collect, self.target_point)
--          self.command_sended = true
  --     end
       return
    end
    self.object:set_movement_type (move.stand)
    self:check_path ()
    self.command_sended = false
    self.state = leader_check
    local pt1 = patrol (self.path):point (self.n_waypoint)
    local pt2 = self.object:position ()
    local dir = vector ():set (pt1.x - pt2.x, pt1.y - pt2.y, pt1.z - pt2.z)
    dir:normalize ()
    self.object:set_sight (look.direction, dir, 0)
    self:set_animation ()
    self:send_command (leader_collect, self.target_point)
end
----------------------------------------------------------------------------------------------------------------------
function action_path:set_move ()
    self.object:set_path_type  (game_object.patrol_path)
    self.object:set_patrol_path (self.path, patrol.custom, patrol.continue, true)
    self.object:set_desired_direction ()
    self.object:set_desired_position ()
    self.object:set_previous_point (self.c_waypoint)
    self.object:set_start_point (self.n_waypoint)
    self.object:set_body_state(move.standing) -- added by Zmey: crash bug fix: always set body standing to standing when setting mental state to anim.free
    self.object:set_mental_state (anim.free)
    self.state = leader_move
    self.object:set_movement_type (move.walk)
    self.object:set_sight (look.danger, nil, 0)
    --printf ("[%d]Current waypoint %d, next waypoint %d", device ():time_global (), self.c_waypoint, self.n_waypoint)
    if self.move_direction == true then
       self:send_command (leader_move_fwd, nil)
    else
       self:send_command (leader_move_bwd, nil)
    end
    self:send_command (leader_move, nil)
end
----------------------------------------------------------------------------------------------------------------------
function action_path:finalize ()
    action_base.finalize (self)
    self.object:clear_animations ()
    self.object:clear_callback (game_object.movement)
end
----------------------------------------------------------------------------------------------------------------------
function action_path:set_animation ()

    self.current_animation = self.current_animation + 1
    if self.current_animation > table.getn (animations) then
       self.current_animation = 1
    end

    self.object:add_animation (animations[self.current_animation].anim, animations[self.current_animation].flag)

end
----------------------------------------------------------------------------------------------------------------------
function action_path:move_callback (obj, action_type, index)

    if index == -1 then return end
    local ptr = patrol (self.object:patrol ())
    self.c_waypoint = index

    if self.state == leader_alarm then
       return
    end

    if ptr:flag (index, 0) then
       self.need_rotate = true
       self.move_direction = true
    end

    if ptr:flag (index, 2) then
       self.move_direction = false
       self.need_rotate = true
    end

    self:check_path ()

    if self:check_members_alive () == true then
       for a = 1, table.getn (self.members), 1 do
           if self.members[a].object:alive () == true and distance_between (self.object, self.members[a].object) > 16 then
              self.state = leader_check
              self:set_animation ()
              self:checkpoint ()
              self:send_command (leader_collect, self.object:position ())
              self.object:play_sound (commander_snd, 1, 0, 1, 0, 0)
              return
           end
       end
    end


    if ptr:flag (index, 1) == true or ptr:flag (index, 0) == true or ptr:flag (index, 2) == true then
       self.state = leader_check
       self:set_animation ()
       self:checkpoint ()
       self:send_command (leader_check, nil)
    end
end


----------------------------------------------------------------------------------------------------------------------
-- Patrol binder
----------------------------------------------------------------------------------------------------------------------
class "patrol_binder" (object_binder)
----------------------------------------------------------------------------------------------------------------------
function patrol_binder:__init (obj) super(obj)
    local name, group, command, member = str_split (obj:name ())
    self.group = group
    self.command = command
    self.npc = obj
    self.action = nil
end
----------------------------------------------------------------------------------------------------------------------
function patrol_binder:reinit ()
    object_binder.reinit (self)
end
----------------------------------------------------------------------------------------------------------------------
function patrol_binder:reload (section)
    object_binder.reload  (self, section)
    local manager  = self.object:motivation_action_manager ()

    manager:add_evaluator (property_pathend_comm, this.evaluator_const (false))
    manager:add_evaluator (property_snd, this.evaluator_snd ())
    manager:add_evaluator (property_corpse, this.evaluator_corpse ())

    self.action = this.action_path   (this.GetPatrolPath (self.npc:name ()), self.group, self.command, "action_path")
    self.action:add_precondition     (world_property (stalker_ids.property_alive, true))
    self.action:add_precondition     (world_property (stalker_ids.property_enemy, false))
    self.action:add_precondition     (world_property (property_corpse, false))
    self.action:add_precondition     (world_property (property_snd, false))
    self.action:add_effect           (world_property (property_pathend_comm, true))
    manager:add_action               (xr_actions_id.sidor_act_commander, self.action)

    local act = this.action_snd ("action_snd")
    act:add_precondition     (world_property (stalker_ids.property_alive, true))
    act:add_precondition     (world_property (stalker_ids.property_enemy, false))
    act:add_precondition     (world_property (property_snd, true))
    act:add_effect           (world_property (property_snd, false))
    manager:add_action       (action_check_snd, act)

    act = this.action_corpse ("action_corpse")
    act:add_precondition     (world_property (stalker_ids.property_alive, true))
    act:add_precondition     (world_property (stalker_ids.property_enemy, false))
    act:add_precondition     (world_property (property_corpse, true))
    act:add_effect           (world_property (property_corpse, false))
    manager:add_action       (action_check_corpse, act)

    act = manager:action (stalker_ids.action_free_no_alife)
    act:add_precondition (world_property (property_pathend_comm,  true))
    act = manager:action (stalker_ids.action_gather_items)
    act:add_precondition (world_property (property_pathend_comm,  true))

end
----------------------------------------------------------------------------------------------------------------------
function patrol_binder:net_spawn  (server_object)
  if (object_binder.net_spawn(self,server_object) == false) then
     return false
  end
  return true
end
----------------------------------------------------------------------------------------------------------------------
function patrol_binder:net_destroy  ()
  object_binder.net_destroy  (self)
end
----------------------------------------------------------------------------------------------------------------------









----------------------------------------------------------------------------------------------------------------------
-- Soldier binder
----------------------------------------------------------------------------------------------------------------------
class "soldier_binder" (object_binder)
----------------------------------------------------------------------------------------------------------------------
function soldier_binder:__init (obj) super(obj)
    local name, group, command, member = str_split (obj:name ())
    self.group = group
    self.command = command
    self.npc = obj
    self.action = nil
    self.leader_index = 0
end
----------------------------------------------------------------------------------------------------------------------
function soldier_binder:reinit ()
    object_binder.reinit (self)
end
----------------------------------------------------------------------------------------------------------------------
function soldier_binder:reload (section)
    object_binder.reload  (self, section)
    local manager  = self.object:motivation_action_manager ()

    manager:add_evaluator (property_pathend_sold, this.evaluator_const (false))
    manager:add_evaluator (property_snd, this.evaluator_snd ())
    manager:add_evaluator (property_corpse_s, this.evaluator_corpse_s ())

    self.action = this.action_soldier(this.GetPatrolPath (self.npc:name ()), "action_soldier")
    self.action.leader_index = self.leader_index
    self.action:add_precondition     (world_property (stalker_ids.property_alive, true))
    self.action:add_precondition     (world_property (stalker_ids.property_enemy, false))
    self.action:add_precondition     (world_property (property_snd, false))
    self.action:add_precondition     (world_property (property_corpse_s, false))
    self.action:add_effect           (world_property (property_pathend_sold, true))
    manager:add_action               (xr_actions_id.sidor_act_soldier, self.action)

    local act = this.action_snd ("action_snd")
    act:add_precondition     (world_property (stalker_ids.property_alive, true))
    act:add_precondition     (world_property (stalker_ids.property_enemy, false))
    act:add_precondition     (world_property (property_snd, true))
    act:add_effect           (world_property (property_snd, false))
    manager:add_action       (action_check_snd, act)

    act = this.action_corpse_s ("action_corpse_s")
    act:add_precondition     (world_property (stalker_ids.property_alive, true))
    act:add_precondition     (world_property (stalker_ids.property_enemy, false))
    act:add_precondition     (world_property (property_corpse_s, true))
    act:add_effect           (world_property (property_corpse_s, false))
    manager:add_action       (action_check_corpse, act)


    act = manager:action (stalker_ids.action_free_no_alife)
    act:add_precondition (world_property (property_pathend_sold,  true))
    act = manager:action (stalker_ids.action_gather_items)
    act:add_precondition (world_property (property_pathend_sold,  true))

end
----------------------------------------------------------------------------------------------------------------------
function soldier_binder:net_spawn  (server_object)
  if (object_binder.net_spawn(self,server_object) == false) then
     return false
  end
  return true
end
----------------------------------------------------------------------------------------------------------------------
function soldier_binder:net_destroy  ()
  object_binder.net_destroy  (self)
end
----------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------
-- Action path
----------------------------------------------------------------------------------------------------------------------
-- Ёкшен дл€ перемещени€ по патрульному пути
----------------------------------------------------------------------------------------------------------------------
class "action_soldier" (action_base)

function action_soldier:__init (path, name) super (nil, name)
    self.path = path
    self.state = soldier_check
    self.move_direction = true
    self.c_waypoint = 0
    self.n_waypoint = 1
    self.waypoints = patrol (self.path):count () - 1
    self.target_point = vector ():set (0, 0, 0)
    self.c_time = 0
    self.need_rotate = false
    self.leader_index = 0
    self.r_command = soldier_check
end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:get_state ()
    return self.state
end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:initialize ()

    action_base.initialize                (self)
    self.object:set_node_evaluator        ()
    self.object:set_path_evaluator        ()
    self.object:set_desired_position      ()
    self.object:set_desired_direction     ()

    self.object:set_item                  (object.idle, self.object:best_weapon ())
    self.object:set_detail_path_type      (move.line)
    self.object:set_body_state            (move.standing)
    self.object:set_sight                 (look.path_dir, nil, 0)

    self.object:set_callback (self, "move_callback", game_object.movement)

    local __name, __command, __group, __member = str_split (self.object:name ())
    self.current_animation = __member
    self.r_command = soldier_check
    self.need_rotate = false


    if self.leader_index ~= 0 then
       if Patrols[self.leader_index].object:alive () == false then
          self.state = soldier_alarm
          self:set_alarm ()
          --printf ("Set alarm for soldier %s", self.object:name ())
       end
    else
       --printf ("Alarm not set. Leader index is %d", self.leader_index)
    end
end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:talk (num_phrase)
    self.object:play_sound (soldiers_idle_snd, 1, 0, 1, 0, num_phrase)
end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:set_view ()
    self.object:set_movement_type (move.stand)
    self:set_animation ()
    self.state = soldier_check
end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:move_to_collect ()
    local way           = patrol (self.path)
    local position      = self.object:position ()
    local i_nearest     = way:get_nearest (self.target_point)
    local waypoint      = way:point (i_nearest)
    local dir           = vector ():set (waypoint.x - position.x, 0, waypoint.z - position.z)
    dir:normalize ()
    self.c_waypoint = i_nearest
    self.object:set_path_type               (game_object.level_path)
    self.object:set_dest_level_vertex_id    (way:level_vertex_id (i_nearest))
    self.object:set_desired_position        (way:point (i_nearest))
    self.object:set_desired_direction       ()  --dir
    self.object:set_body_state(move.standing) -- added by Zmey: crash bug fix: always set body standing to standing when setting mental state to anim.free
    self.object:set_mental_state            (anim.free)
    self.object:set_movement_type           (move.walk)
    self.object:set_sight                   (look.path_dir, vector ():set (waypoint.x, waypoint.y + 1.5, waypoint.z), 0)
    self.target_point = waypoint
    self.state = soldier_collect
    --printf ("Soldier set move to collect")
end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:check_path ()

    if self.move_direction == true then
       if self.c_waypoint == self.waypoints then
          self.move_direction = false
          --self.c_waypoint = count
          self.n_waypoint = self.c_waypoint - 1
       else
          self.n_waypoint = self.c_waypoint + 1
       end
    else
       if self.c_waypoint == 0 then
          self.n_waypoint = 1
          self.move_direction = true
       else
          self.n_waypoint = self.c_waypoint - 1
       end
    end

end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:execute ()

    action_base.execute (self)
    self.object:set_item (object.idle, self.object:best_weapon ())

    if Patrols[self.leader_index].object:alive () == false then
       self:send_command (leader_alarm, nil)
    end


    if self.state == soldier_collect then
       self:check_collect ()
    elseif self.state == soldier_check then
       self:checkpoint ()
    elseif self.state == soldier_move then
       self:set_move ()
    elseif self.state == soldier_rotate then
       self:rotate ()
    elseif self.state == soldier_check then
       self:checkpoint ()
    elseif self.state == soldier_alarm then
       self:move_to_base ()
    end


end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:move_to_base ()
    local way = patrol (self.path)
    if way:point (0):distance_to (self.object:position ()) < 3 then
       self.object:set_movement_type (move.stand)
       if self.object:animation_count () < 2 then
          --printf ("Set animation")
          self:set_animation ()
       end
    end
end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:checkpoint ()

    self.object:set_movement_type (move.stand)
    if self.object:animation_count () == 0 then
       self.object:clear_animations ()
       self.c_time = device ():time_global ()
       self.state = soldier_ready
    end
end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:rotate ()

    if self.need_rotate == true then
       local pos = patrol (self.path):point (self.n_waypoint)
       pos.y = pos.y + 1.5
       self.object:set_sight (look.fire_point, pos, 0)
       if device ():time_global () - self.c_time > 1000 then
          self.state = leader_move
          self:set_move ()
          self.need_rotate = false
       end
    else
       self.state = soldier_move
       self:set_move ()
    end

end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:check_collect ()
    if self.target_point:distance_to (self.object:position ()) > 1.0 then
       return
    end
    self.object:set_movement_type (move.stand)
    self.object:set_body_state(move.standing) -- added by Zmey: crash bug fix: always set body standing to standing when setting mental state to anim.free
    self.object:set_mental_state (anim.free)
    self:check_path ()
    local pt1 = patrol (self.path):point (self.n_waypoint)
    local pt2 = self.object:position ()
    local dir = vector ():set (pt1.x - pt2.x, pt1.y - pt2.y, pt1.z - pt2.z)
    dir:normalize ()
    self.object:set_sight (look.direction, dir, 0)
    if self.object:animation_count () < 1 then
       self:set_animation ()
    end
    self.state = soldier_check
end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:set_move ()
    self.object:set_path_type  (game_object.patrol_path)
    self.object:set_patrol_path (self.path, patrol.custom, patrol.continue, true)
    self.object:set_desired_direction ()
    self.object:set_desired_position ()
    self.object:set_previous_point (self.c_waypoint)
    self.object:set_start_point (self.n_waypoint)
    self.object:set_body_state(move.standing) -- added by Zmey: crash bug fix: always set body standing to standing when setting mental state to anim.free
    self.object:set_mental_state (anim.free)
    self.state = soldier_move
    self.object:set_movement_type (move.walk)
    self.object:set_sight (look.danger, nil, 0)
    --printf ("[%d]Current waypoint %d, next waypoint %d", device ():time_global (), self.c_waypoint, self.n_waypoint)
end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:finalize ()
  self.object:clear_callback (game_object.movement)
  self.object:clear_animations ()
  action_base.finalize (self)
end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:send_command (command, target)
--    printf ("Soldier %s received command %d", self.object:name (), command)
    if command == leader_collect then
       --printf ("Receive command LEADER_COLLECT")
       self.r_command = soldier_check
       self.target_point = target
       self:move_to_collect ()
    elseif command == leader_move then
       --printf ("Receive command LEADER_MOVE")
       self.r_command = soldier_move
       self:set_move ()
    elseif command == leader_check then
       --printf ("Receive command LEADER_CHECK")
       self.state = soldier_check
       self.r_command = soldier_check
       self:set_animation ()
    elseif command == leader_wait then
       --printf ("Receive command LEADER_WAIT")
       self.r_command = soldier_collect
    elseif command == leader_alarm then
       if self.state ~= soldier_alarm then
          --printf ("Receive command LEADER_ALARM")
          self.state = soldier_alarm
          self:set_alarm ()
       end
    elseif command == leader_move_fwd then
       --printf ("Receive command LEADER_MOVE_FORWARD")
       self.move_direction = true
       self:check_path ()
    elseif command == leader_move_bwd then
       --printf ("Receive command LEADER_MOVE_BACKWARD")
       self.move_direction = false
       self:check_path ()
    end
end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:set_alarm ()
    self.n_waypoint = self.c_waypoint - 1
    self.move_direction = false
    self:check_path ()
    self.object:clear_animations ()
    self.object:set_path_type  (game_object.level_path)
    self.object:set_path_type  (game_object.patrol_path)
    self.object:set_patrol_path (self.path, patrol.custom, patrol.continue, true)
    self.object:set_desired_direction ()
    self.object:set_desired_position ()
    self.object:set_previous_point (self.c_waypoint)
    self.object:set_start_point (self.n_waypoint)
    self.object:set_body_state(move.standing) -- added by Zmey: crash bug fix: always set body standing to standing when setting mental state to anim.free
    self.object:set_mental_state (anim.danger)
    self.object:set_movement_type (move.run)
    self.object:set_sight (look.path_dir, nil, 0)

    --printf ("Set alarm for soldier %s. Current waypoint %d, next waypoint %d", self.object:name (), self.c_waypoint, self.n_waypoint)

end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:get_state ()
    return self.state
end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:set_animation ()

    --self.object:clear_animations ()

    self.current_animation = self.current_animation + 1
    if self.current_animation > table.getn (animations) then
       self.current_animation = 1
    end

    self.object:add_animation (animations[self.current_animation].anim, animations[self.current_animation].flag)

end
----------------------------------------------------------------------------------------------------------------------
function action_soldier:move_callback (obj, action_type, index)

    if index == -1 then return end
    local ptr = patrol (self.object:patrol ())
    self.c_waypoint = index

    if self.state == soldier_alarm then
       return
    end

    if ptr:flag (index, 0) then
       self.need_rotate = true
       self.move_direction = true
    end

    if ptr:flag (index, 2) then
       self.move_direction = false
       self.need_rotate = true
    end

    self:check_path ()

end

----------------------------------------------------------------------------------------------------------------------
function FindLeader (_command, _squad)
    local size = table.getn (Patrols)
    if size == 0 then return 0 end

    local name, command, squad, member
    for a = 1, size, 1 do
        name, command, squad, member = str_split (Patrols[a].npc:name ())
        if _command == command and _squad == squad then
           return a
         end
    end

    return 0
end
----------------------------------------------------------------------------------------------------------------------
function AddToPatrol (obj, command, squad, member)

    local index = this.FindLeader (command, squad)
    if index == 0 then
       index = index + 1
       Patrols[index] = this.patrol_binder (obj)
       obj:bind_object  (Patrols[index])
    else
       local size = table.getn (Patrols[index].action.members)
       size = size + 1
       Patrols[index].action.members[size] = this.soldier_binder (obj)
       Patrols[index].action.members[size].leader_index = index
       obj:bind_object (Patrols[index].action.members[size])
    end

    obj:add_sound ("Scripts\\Patrol\\Commander1_", 20, snd_type.talk, 2, 1, commander_snd)
    obj:add_sound ("Scripts\\Patrol\\soldier_idle_", 20, snd_type.talk, 2, 1, soldiers_idle_snd)
    obj:add_sound ("script_replics\\soldier_1\\idle\\soldier_idle_", 20, snd_type.talk, 2, 1, soldiers_idle2_snd)
    obj:add_sound ("script_replics\\soldier_1\\replics\\soldier_replic_", 20, snd_type.talk, 2, 1, soldiers_replics_snd)
    obj:add_sound ("script_replics\\soldier_1\\hear_something\\soldier_hear_", 20, snd_type.talk, 2, 1, soldiers_hear_snd)
    obj:add_sound ("script_replics\\bandit_1\\replics\\bandit_replic_", 20, snd_type.talk, 2, 1, soldiers_corpse_snd)
end
----------------------------------------------------------------------------------------------------------------------
function setalarm (command, squad)
    local index = this.FindLeader (command, squad)
    if index == 0 then
       --printf ("Set alarm failed for command %s, squad %d", command, squad)
       return
    end

    Patrols[index].action:set_alarm ()
    --printf ("Set alarm for command %s, squad %d", command, squad)
end