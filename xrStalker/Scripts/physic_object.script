function init(obj)
	local ini  = obj:spawn_ini()
	
	if(ini == nil) then return end
	
	if(ini:section_exist("door")) then
		obj:bind_object(door_binder(obj))
	end
	if(ini:section_exist("animation")) then
		obj:bind_object(handing_lamp_binder(obj))
	end
end

class "door_binder" (object_binder)
function door_binder:__init(obj) super(obj)
	self.need_initialize	= true
	self.joint				= nil
	self.low_limits			= 0
	self.hi_limits			= 0
	self.angel				= 0
end

//function door_binder:reload(section)
//	object_binder.reload(self, section)
//end

function door_binder:initialize()
	object_binder.reinit(self)

	local ini	= self.object:spawn_ini()
	self.joint	= self.object:get_physics_shell():get_joint_by_bone_name("door")
	
	self.low_limits, self.hi_limits	= self.joint:get_limits(self.low_limits, self.hi_limits, 0)
    
    self.object:set_nonscript_usable(false)
    self.object:set_use_callback(self, "door_callback")
    self.object:set_tip_text("press E to open the door")

	local variable = false

	if(ini:line_exist("door", "opened")) then
		//'Есть данные о том, закрыта или открыта дверь
		variable = ini:r_bool("door", "opened")

		if(variable) then
			self:open_door()
		else
			self:close_door()
		end
	end

	if(ini:line_exist("door", "text")) then
		//'Надпись, которая высвечивается, когда подходишь к двери
		variable = ini:r_string("door", "text")
		self.object:set_tip_text(variable)
	end
	
	self.need_initialize	= false
end

function door_binder:update(delta)
	object_binder.update(self, delta)
	if(self.need_initialize) then
		self:initialize()
	end
end

function door_binder:close_door()
	self.joint:set_max_force_and_velocity(200, 1, 0)
end

function door_binder:open_door()
	self.joint:set_max_force_and_velocity(200, -1, 1)
end

function door_binder:door_callback(door, actor)
	self.angel  = self.joint:get_axis_angle(90)

	self.low_limits, self.hi_limits	= self.joint:get_limits(self.low_limits, self.hi_limits, 0)

	if(self.angel - self.low_limits > self.hi_limits - self.angel) then
		self.joint:set_max_force_and_velocity(300, -2, 1)
	else
        self.joint:set_max_force_and_velocity(300, 2, 1)
	end
end

class "handing_lamp_binder" (object_binder)
function handing_lamp_binder:__init(obj) super(obj)
	printf("Binding lamp")
	self.type		= "low"
	self.time		= 0
	self.rnd		= 0
	self.dir_x_axis = -1
	self.dir_y_axis = -1
	self.joint	= nil
end

function handing_lamp_binder:reload(section)
	object_binder.reload(self, section)
	
	//'Читаем данные из кастом даты. Если неправильные данные, то ставим type = "low"
	local ini	= self.object:spawn_ini()
	if(ini:line_exist("animation", "type")) then
		self.type = ini:r_string("animation", "type")
		printf("read animation type: %s", self.type)
	end
	
	if(self.type ~= "low" and self.type ~="midle" and self.type ~= "hight") then
		printf("WRONG TUNING HANDING LAMP")
		self.type	= "low"
	end
	
	self.time	= device():time_global()
	self.dir_x_axis = 1
	self.dir_z_axis	= 1
	self.joint		= nil
end

function handing_lamp_binder:update(delta)
	object_binder.update(self, delta)

	if(self.joint == nil) then
		self.joint	= self.object:get_physics_shell():get_joint_by_bone_name("provod")
	end	
	
	if(device():time_global() > self.time) then
		printf("force")
		self.joint:set_max_force_and_velocity(2 + math.random(), 0.2 * self.dir_x_axis, 0)
		self.joint:set_max_force_and_velocity(2 + math.random(), 0.25 * self.dir_z_axis, 2)
		self.dir_x_axis	= self.dir_x_axis * (-1)
		self.dir_z_axis = self.dir_z_axis * (-1)
		self.time		= device():time_global() + math.random(500, 500)
	end				
end
