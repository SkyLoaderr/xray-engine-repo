
--[[
ОПИСАНИЕ ФУНКЦИЙ

-- Крешнуть игру (после вывода сообщения об ошибке в лог)
function abort(fmt, ...)

-- Выводит отладочное сообщение в лог, если скрипт активен (активный скрипт выбирается с помощью
-- переменной debug_info.trace_script). 
function trace(script_name, fmt, ...)

-- Переводит переменную любого типа (включая nil) в строку. Используется для отладочного вывода информации.
function to_str(what)

-- Создает и возвращает копию вектора
function vector_copy_by_val(vec)

-- Настройка параметров игровых объектов:
function conf_get_bool(char_ini, section, field, override, object, mandatory)
function conf_get_string(char_ini, section, field, override, object, mandatory)
function conf_get_number(char_ini, section, field, override, object, mandatory)

-- Проверяет, находится ли stalker рядом с точкой path_point пути patrol_path
function stalker_at_waypoint(stalker, patrol_path, path_point)

-- Послать stalker в заданную точку patrol_path(path_point)
function stalker_go_to_waypoint(stalker, patrol_path, path_point)

--]]

----------------------------------------------------------------------------------------------------

-- Крешнуть игру (после вывода сообщения об ошибке в лог)
function abort(fmt, ...)
	local reason = string.format(fmt, unpack(arg))
	printf("ERROR: %s", reason)
	patrol(".." .. reason .. "..")
end

-- Выводит отладочное сообщение в лог, если скрипт активен (активный скрипт выбирается с помощью
-- переменной debug_info.trace_script). 
function trace(script_name, fmt, ...)
	if debug_info.trace_script == script_name then
		log(string.format("[TRACE] " .. script_name .. ".script: " .. fmt, unpack(arg)))
	end
end

-- Переводит переменную любого типа (включая nil) в строку. Используется для отладочного вывода информации.
function to_str(what)
	if what == nil then
		return "<nil>"
	else
		return tostring(what)
	end
end

-- Создает и возвращает копию вектора
function vector_copy_by_val(vec)
--[[
	local newvec = vector()
	newvec.x = vec.x
	newvec.y = vec.y
	newvec.z = vec.z
	return newvec
--]]
	return vector():set(vec)
end

-- Настройка параметра типа bool у игрового объекта.
-- 
-- char_ini - указатель на customdata (обычно object:spawn_ini())
-- section - имя секции в customdata
-- field - имя поля в customdata
-- override - nil, если переменную нужно прочесть из customdata,
--            иначе - значение, которое взять вместо того, которое в customdata
-- object - игровой объект, от которого будет взято имя для сообщения об ошибке
-- mandatory - поле обязательно должно быть задано
--
-- Возвращает true или false
function conf_get_bool(char_ini, section, field, override, object, mandatory)
	if override ~= nil then
		return override ~= false
	end
	if char_ini:section_exist(section) and char_ini:line_exist(section, field) then
		local ret = char_ini:r_bool(section, field)
		return ret
	end
	if not mandatory then
		return false
	end
	local err = "object name '" .. object:name() .. "': attempt to read a non-existant boolean field '" ..
		field .. "' in section '" .. section .. "'";
	utils.abort("%s", err)
end

function conf_get_string(char_ini, section, field, override, object, mandatory)
	if override ~= nil then
		return override
	end
	if char_ini:section_exist(section) and char_ini:line_exist(section, field) then
		return char_ini:r_string(section, field)
	end
	if not mandatory then
		return nil
	end
	local err = "object name '" .. object:name() .. "': attempt to read a non-existant boolean field '" ..
		field .. "' in section '" .. section .. "'";
	utils.abort("%s", err)
end

function conf_get_number(char_ini, section, field, override, object, mandatory)
	if override ~= nil then
		return override
	end
	if char_ini:section_exist(section) and char_ini:line_exist(section, field) then
		return char_ini:r_s32(section, field)
	end
	if not mandatory then
		return nil
	end
	local err = "object name '" .. object:name() .. "': attempt to read a non-existant numeric field '" ..
		field .. "' in section '" .. section .. "'";
	utils.abort("%s", err)
end

-- Проверяет, находится ли stalker рядом с точкой path_point пути patrol_path
function stalker_at_waypoint(stalker, patrol_path, path_point)
	return stalker:level_vertex_id() == patrol_path:level_vertex_id(path_point)
--[[
	local stalker_pos = stalker:position()
	local distance = stalker_pos:distance_to(patrol_path:point(path_point))
	if distance <= 0.5 then
		return true
	end
	return false
--]]
end

-- Послать stalker в заданную точку patrol_path(path_point)
function stalker_go_to_waypoint(stalker, patrol_path, path_point)
	if stalker:animation_count() > 0 then
		stalker:clear_animations()
	end
	if stalker:level_vertex_id() == patrol_path:level_vertex_id(path_point) then
		return
	end
	stalker:set_dest_level_vertex_id(patrol_path:level_vertex_id(path_point))
	stalker:set_movement_type(move.run)
	stalker:set_body_state(move.standing)
	stalker:set_sight(look.path_dir, nil, 0)
	stalker:set_path_type(game_object.level_path)
	stalker:set_mental_state(anim.danger)
	stalker:set_detail_path_type(move.line)
end

function stalker_stop(stalker)
	stalker:set_movement_type(move.stand)
end

function stalker_look_at_waypoint(stalker, patrol_path, path_point)
	local look_pt = this.vector_copy_by_val(patrol_path:point(path_point)):sub(stalker:position())
	stalker:set_sight(look.direction, look_pt, 0)
end

function stalker_look_at_stalker(stalker, whom)
	--local pos = whom:position()
	--pos.y = pos.y + 0.8
	--stalker:set_sight(look.fire_point, whom, 0)

	local look_pt = this.vector_copy_by_val(whom:position()):sub(stalker:position())
	stalker:set_sight(look.direction, look_pt, 0)
end

local function door_default_callback(door, actor)
	local ph_shell = door:get_physics_shell()
	local joint = ph_shell:get_joint_by_bone_name("door")

	local low_limit = 0
	local hi_limit = 0
	low_limit, hi_limit = joint:get_limits(low_limit, hi_limit, 0)

	local angle = joint:get_axis_angle(0)
	if angle-low_limit > hi_limit - angle 
	then
		joint:set_max_force_and_velocity(100, -1.5, 0)
	else
		joint:set_max_force_and_velocity(100, 1.5, 0)
	end
end

function door_init(door)
	door:set_use_callback(door_default_callback)
end

-- Дверь door импульсом захлопнется и залочится, при юзе будет вызываться callback_fn
function door_close_then_lock(door, callback_fn)
	local ph_shell = door:get_physics_shell()
	local joint = ph_shell:get_joint_by_bone_name("door")
	local low_limit = 0
	local hi_limit = 0
	low_limit, hi_limit = joint:get_limits(low_limit, hi_limit, 0)
	local angle = joint:get_axis_angle(0)
	if angle-low_limit > hi_limit - angle 
	then
		joint:set_max_force_and_velocity(1000000, 0, 0)
	else
		joint:set_max_force_and_velocity(1000000, 0, 0)
	end
end
	
--unlock_then_open(door) -- дверь разлочится и импульсом откроется
--locked(door) -- true, если дверь закрыта и залочена

--При попытке поюзать незапертую дверь она просто силой открывается до максимально допустимого состояния.

function init_path(pathname)
	local path_info = {}
	local ptr = patrol(self.path_active)
	local num_points = ptr:count()

	local flag_id = 0
	for pt = 0, num_points - 1 do
		for flg = 0, 31 do
			if ptr:flag(pt, flg) then
				flag_id = flag_id + 2 ^ flg
			end
		end
		path_info[pt] = {}
		path_info[pt].flag_id = flag_id
	end
end
