local sounds = {}

---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
--  онстанта
class "evaluator_need_sleeper" (property_evaluator)
function evaluator_need_sleeper:__init(storage) super ()
  self.a = storage
end
function evaluator_need_sleeper:evaluate ()
  local tt

  tt = self.a.enabled == true

      return tt
end

----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
-- ќбычное поведение
class "action_sleeper_activity" (action_base)
function action_sleeper_activity:__init (npc_name,action_name,storage) super (nil, action_name)
    self.a = storage
	self.timer = {begin = nil,
			idle = nil,
			maxidle = 10,
			sumidle = 20,
			random = 50 }
end
function action_sleeper_activity:initialize()
    action_base.initialize(self)
    self.object:set_node_evaluator()
    self.object:set_path_evaluator()
    self.object:set_desired_position()
    self.object:set_desired_direction()

	local pp = patrol(self.a.path_main):level_vertex_id(0)
	xr_position.setPosition(self.object, pp)

	-- нужно его повернуть в одну из указанных позиций
	self.ptr = patrol (self.a.path_main)
	-- определ€ем список вершин, которые имеют такие же установленные флаги (текущую игнорируем)
	self.points = {}
	for i=0, self.ptr:count()-1, 1 do
		for j=5, 31, 1 do
			if self.ptr:flag(0, j) == true and
			   self.ptr:flag(0, j) == self.ptr:flag(i, j) and
			   i ~= 0
			then				
				table.insert(self.points, i)
			end
		end
	end
end
function action_sleeper_activity:execute()
	if xr_position.onPosition(self.object) == true and xr_state.finish_state(self.object) == true then
        	if table.getn(self.points) > 0 then
			local point = self.ptr:level_vertex_id(self.points[math.random(table.getn(self.points))])
			local pt = level.vertex_position(point)
			self.object:set_sight(look.point, pt, 0)
		end
 		self.object:set_item(object.deactivate, self.object:best_weapon())
		xr_state.change_state(self.object, 4)

		if self.timer.begin == nil then
			--начальна€ инициализаци€
			self.timer.begin = device():time_global()/1000
			self.timer.idle = math.random(self.timer.maxidle) + self.timer.sumidle
		end

		if device():time_global()/1000 - self.timer.begin > self.timer.idle then
			self.timer.begin = device():time_global()/1000
			self.timer.idle = math.random(self.timer.maxidle) + self.timer.sumidle

			if math.random(100) < self.timer.random then
				-- добавление рандомных анимаций
				self.object:clear_animations()
        			self.object:add_animation("spit_1",true)	
				a = xr_state.getIdle(4)
				if a ~= nil then
					self.object:add_animation(a, true)
				end
			end
		end		
	end
end
function action_sleeper_activity:finalize()
	xr_state.change_state(self.object, 0)
    	action_base.finalize(self)
end

----------------------------------------------------------------------------------------------------------------------
--Guard binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc)
  local operators    = {}
  local properties  = {}

  local manager = npc:motivation_action_manager()

  properties["need_sleeper"]   = xr_evaluators_id.zmey_sleeper_base + 1
  properties["state_end"]      = xr_evaluators_id.state_change
  properties["position"]	= xr_evaluators_id.position

  operators["action_sleeper"]   = xr_actions_id.zmey_sleeper_base + 1

  -- // evaluators
  manager:add_evaluator (properties["need_sleeper"],   this.evaluator_need_sleeper  (xr_motivator.storage[npc:id()].sleeper))

  local new_action = this.action_sleeper_activity(npc, "action_sleeper_activity", xr_motivator.storage[npc:id()].sleeper)
  new_action:add_precondition    (world_property(stalker_ids.property_alive,   	true))
  new_action:add_precondition    (world_property(stalker_ids.property_enemy,   	false))
  new_action:add_precondition    (world_property(properties["need_sleeper"],   	true))
  new_action:add_precondition    (world_property(properties["state_end"], 	true))
  new_action:add_precondition	 (world_property(properties["position"], 	true))
  new_action:add_effect(world_property(properties["need_sleeper"], false))
  manager:add_action(operators["action_sleeper"], new_action)

  new_action = manager:action(stalker_ids.action_puzzle_solver)
  new_action:add_precondition(world_property(properties["need_sleeper"], false))
end
function set_sleeper(object, enable, point)
	-- enable - будет ли работать схема в принципе
	-- point - точка где спать

	local char_ini = object:spawn_ini()
	local st = xr_motivator.storage[object:id()].sleeper

	if enable == nil then
	    	if char_ini:section_exist ("sleeper") == true then
        		if char_ini:line_exist("sleeper", "enabled") == true then
                		st.enabled = char_ini:r_bool("sleeper", "enabled")
			else
				st.enabled = false
		        end
		else
			st.enabled = false
		end
	else
		st.enabled = enable		
	end	
	if st.enabled == true then
		if point == nil then
		    	if char_ini:section_exist ("sleeper") == true then
	        		if char_ini:line_exist("sleeper", "path_main") == true then
		        	        st.path_main = char_ini:r_string("sleeper", "path_main")
	        		else
		        	    	st.enabled = false
			        end
			else
				st.enabled = false
			end
		else
			st.path_main = point
		end
	end
	xr_motivator.checkStorage(object)
end