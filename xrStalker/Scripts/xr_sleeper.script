local sounds = {}

--[[-- Условие завершения скрипта
class "evaluator_kamp_end" (property_evaluator)
function evaluator_kamp_end:__init(storage) super()
	self.a = storage
end
function evaluator_kamp_end:evaluate()
	local tt
	if self.a.enabled == false then
		tt = true
	else
		tt = false
	end
--	if tt == true then
--		printf("[EVA] Kamp: Can go? true")
--	else
--		printf("[EVA] Kamp: Can go? false")
--	end               
	return tt
end

-- Находимся ли мы на заданной позиции
class "evaluator_on_position" (property_evaluator)
function evaluator_on_position:__init(storage) super()
	self.a = storage

	-- таблица векторов, содержащих направления на точки рассадки
	self.vectors = {{1, 	0,	0},
			{1,	0, 	1},
			{0, 	0,	1},
			{-1, 	0,	1},
			{-1, 	0, 	0},
			{-1, 	0,	-1},
			{0, 	0,	-1},
			{1, 	0,	-1} }
end
function evaluator_on_position:evaluate()
	local tt
        -- если позиция еще не выбрана
	if self.a.pos_id == -1 then
		tt = false
	else
		if self.a.action == 1 then 
			tt = true
		else
	   		local pos = self.vectors[self.a.pos_id]
   			local dir = vector():set(pos[1], pos[2], pos[3])
   			local pp = level.vertex_in_direction(patrol(self.a.center_point):level_vertex_id(0), dir, self.a.max_rad)

	   		if pp == self.object:level_vertex_id() then
	   			tt = true
   			else
				tt = false
	   		end
		end
	end
--	if tt == true then
--		printf("[EVA] Kamp: On position? true")
--	else
--		printf("[EVA] Kamp: On position? false")
--	end               
	return tt
end

-- Необходимо ли нам идти вокруг лагеря
class "evaluator_need_patrol" (property_evaluator)
function evaluator_need_patrol:__init(storage) super()
	self.a = storage
end
function evaluator_need_patrol:evaluate()
	local tt
	tt = self.a.action == 1
--	if tt == true then
--		printf("[EVA] Kamp: Need patrol? true")
--	else
--		printf("[EVA] Kamp: Need patrol? false")
--	end              
	return tt
end

----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
-- Идет в заданную область
class "action_go_position" (action_base)
function action_go_position:__init (npc_name,action_name,storage) super (nil,action_name)
	self.a = storage
	
	-- таблица векторов, содержащих направления на точки рассадки
	self.vectors = {{1, 	0,	0},
			{1,	0, 	1},
			{0, 	0,	1},
			{-1, 	0,	1},
			{-1, 	0, 	0},
			{-1, 	0,	-1},
			{0, 	0,	-1},
			{1, 	0,	-1} }
end
function action_go_position:initialize()
--	printf("[ACT] Start: Go position")
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()    

	self.object:set_body_state(move.standing)
	self.object:set_mental_state(anim.free)
	xr_state.change_state(self.object, 0)
	
	self.started = false
end
function action_go_position:execute ()

	if self.started == false then
		self.started = true
	 
		-- для начала надо составить список занятых позиций
		self.object:set_item(object.idle, self.object:best_weapon())
		local used = {}
		local i = 1
		for key,value in xr_motivator.storage do 
			if value.kamp.center_point == self.a.center_point and
			    value.kamp.enabled == true then
				used[i] = value.kamp.pos_id
				i = i + 1
			end
		end

		-- затем исключить их из списка доступных позиций
		local free = {}
		local i = 1
		for key,value in self.vectors do 
			local exist = false
			for k,v in used do
				if key == v then
					exist = true
				end
			end
			if exist == false then
				local pos = value
				local dir = vector():set(pos[1], pos[2], pos[3])
				local pp = level.vertex_in_direction(patrol(self.a.center_point):level_vertex_id(0), dir, self.a.max_rad)

				if pp ~= patrol(self.a.center_point):level_vertex_id(0) then
					free[i] = key
					i = i + 1
				end
			end
		end

		-- затем из доступных позиций выбрать рандомно одну.
		if table.getn(free) > 0 then
			local rr = math.random(table.getn(free))

			self.a.pos_id = free[rr]

			local pos = self.vectors[self.a.pos_id]
			local dir = vector():set(pos[1], pos[2], pos[3])
			local pp = level.vertex_in_direction(patrol(self.a.center_point):level_vertex_id(0), dir, self.a.max_rad)
	        	self.object:set_dest_level_vertex_id(pp)

			self.object:set_path_type(game_object.level_path)
			self.object:set_sight(look.path_dir, nil, 0)
			self.object:set_body_state(move.standing)
			self.object:set_movement_type(move.walk)
		end
		-- если доступных не осталось - никуда его не отправлять
	end
	action_base.execute (self)
end
function action_go_position:finalize ()
--	printf("[ACT] Finish: Go position")                                                  
	self.object:set_movement_type(move.stand)
	action_base.finalize (self)
end

-- Обходит лагерь по одному из патрульных путей
class "action_go_patrol" (action_base)
function action_go_patrol:__init (npc_name,action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_go_patrol:initialize()
--	printf("[ACT] Start: Go patrol")
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()    

	xr_state.change_state(self.object, 0)

	self.begin = false

	self.final_point = {}
	self.relax_point = {}
	self.relax_time = {idle = nil,
			begin = nil,
			max_idle = 5,
			sum_idle = 5 }
	self.relax_idle = {time = 5000,
			begin = nil }

	-- Описание предназначения флагов:
	-- 0 - начало пути
	-- 1 - конец пути
	-- 2 - точка для останова и потягиваний
	-- 5+ - если он находится в этой точке, то он разворачивается и смотрит в одну из точек с установленным аналогичным флагом
end
function action_go_patrol:execute()
	action_base.execute (self)

	-- не двигаться с места пока не закончим вставание
	if self.begin == false and xr_state.finish_state(self.object) then
		-- Установка на патрульный путь
		self.begin = true
		local rr = math.random(table.getn(self.a.patrol_path))
		self.object:set_sight(look.path_dir, nil, 0)
		self.object:set_body_state(move.standing)
		self.object:set_mental_state(anim.free)
--		self.object:set_mental_state(anim.danger)
		self.object:set_path_type  (game_object.patrol_path)
	    	self.object:set_patrol_path (self.a.patrol_path[rr], patrol.start, patrol.continue, true)
		self.object:set_movement_type(move.walk)

		self.object:set_item(object.idle, self.object:best_weapon())	                                                            

		local rr = math.random(3) 
		if rr == 1 then
			self.object:play_sound (sounds["replics"], 1, 0, 1, 0, 3)
		elseif rr == 2 then
			self.object:play_sound (sounds["replics"], 1, 0, 1, 0, 4)
		else
			self.object:play_sound (sounds["replics"], 1, 0, 1, 0, 5)
		end

		-- Определение индексов финальных точек
		self.ptr = patrol (self.object:patrol ())
		local ii = 1
		for i=0, self.ptr:count()-1, 1 do
			if self.ptr:flag(i, 1) == true then
				self.final_point[ii] = i
				ii = ii + 1
			end
		end
		-- Определение индексов точек релаксирования
		local ii = 1
		for i=0, self.ptr:count()-1, 1 do
			if self.ptr:flag(i, 2) == true then
				self.relax_point[ii] = i
				ii = ii + 1
			end
		end
	end

	-- тут нужно сделать проверку на отыгрывание разных релаксных анимаций
	for key,value in self.relax_point do
		if self.object:level_vertex_id() == self.ptr:level_vertex_id(value) then
			-- стоим и смотрим, отыгрывая разные анимации
			if self.relax_time.begin == nil	then
				if self.relax_idle.begin == nil or (device():time_global() - self.relax_idle.begin) >= self.relax_idle.time then
					-- инициализируем остановку
					self.relax_time.begin = device():time_global()
					self.relax_time.idle = math.random(self.relax_time.max_idle) + self.relax_time.sum_idle
					self.object:set_movement_type(move.stand)
					-- нужно его повернуть в одну из указанных позиций
					self.ptr = patrol (self.object:patrol ())
					-- определяем список вершин, которые имеют такие же установленные флаги (текущую игнорируем)
					local points = {}
                        		for i=0, self.ptr:count()-1, 1 do
						for j=5, 31, 1 do
							if self.ptr:flag(value, j) == true and
							   self.ptr:flag(value, j) == self.ptr:flag(i, j) and
							   i ~= value 
							then				
								table.insert(points, i)
							end
						end
					end

					if table.getn(points) > 0 then
						local point = self.ptr:level_vertex_id(points[math.random(table.getn(points))])
						local pt = level.vertex_position(point)
						self.object:set_sight(look.point, pt, 0)
					end
				end
			else
				-- Выход из остановки
				if device():time_global() - self.relax_time.begin >= self.relax_time.idle*1000 then
					self.object:set_sight(look.path_dir, nil, 0)
					self.object:set_movement_type(move.walk)				
					self.relax_time.begin = nil
					self.relax_idle.begin = device():time_global()
				end
			end		
		end
	end
	
	-- Тут нужно будет сделать проверку что мы закончили патрулирование
	for key,value in self.final_point do
		if self.object:level_vertex_id() == self.ptr:level_vertex_id(value) then
			-- устанавливаем что мы дошли до конца патрульного пути
			-- также устанавливаем время окончания 
			self.a.timer.act1.begin = device():time_global()/1000
			self.a.action = 0

			local rr = math.random(3) 
			if rr == 1 then
				self.object:play_sound (sounds["replics"], 1, 0, 1, 0, 6)
			elseif rr == 2 then
				self.object:play_sound (sounds["replics"], 1, 0, 1, 0, 7)
			else
				self.object:play_sound (sounds["replics"], 1, 0, 1, 0, 8)
			end
		end
	end
end
function action_go_patrol:finalize()
--	printf("[ACT] Finish: Go patrol")
	action_base.finalize (self)
end

-- Просто сидит и втыкает
class "action_wait" (action_base)
function action_wait:__init (npc_name,action_name,storage) super (nil,action_name)
	self.a = storage

	self.timer = { begin = nil,
		       idle = nil,
		       maxidle = 20,
		       sumidle = 10 }

end
function action_wait:initialize()
--	printf("[ACT] Start: Wait")
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()    

	self.object:set_item(object.deactivate, self.object:best_weapon())

	self.sound = {idle = 0,
		     begin = nil,
		     maxidle = 10, 
		     sumidle = 10,
   		     rnd = 100,
		     lastsound = nil,
		 	sounds = {      {pack = sounds["idle"], id = 0},
					{pack = sounds["idle"], id = 1}, 
					{pack = sounds["idle"], id = 3}, 
					{pack = sounds["idle"], id = 4}, 
					{pack = sounds["idle"], id = 7}, 
 					{pack = sounds["idle"], id = 9}, 
					{pack = sounds["idle"], id = 11}, 
					{pack = sounds["idle"], id = 12}, 
					{pack = sounds["idle"], id = 14} 	}}
	self.sound_r = {idle = 0,
		     begin = nil,
		     maxidle = 10, 
		     sumidle = 10,
   		     rnd = 100,
		     lastsound = nil,
		 	sounds = {      {pack = sounds["idle"], id = 2},
					{pack = sounds["idle"], id = 3}, 
					{pack = sounds["idle"], id = 5}, 
					{pack = sounds["idle"], id = 6}, 
					{pack = sounds["idle"], id = 10}, 
 					{pack = sounds["idle"], id = 11}, 
					{pack = sounds["idle"], id = 12}, 
					{pack = sounds["idle"], id = 14} 	}}

	self.anim = {	idle = 0,
			begin = nil,
			maxidle = 5,
			sumidle = 5,
			rnd = 40,
			anim_active = { {name = "item_0_idle_1", hand = true},
					{name = "item_0_idle_2", hand = true},
					{name = "item_0_idle_3", hand = true}} }
end
function action_wait:execute()
	action_base.execute (self)
	if self.a.action == 0 or self.a.action == nil then
		--!!! ОПРЕДЕЛЕНИЕ ДАЛЬНЕЙШЕГО ДЕЙСТВИЯ
		local actions = {}
		local i = 1
	
		-- Тут выбор действий
		if table.getn(self.a.patrol_path) > 0 and self.a.last_action ~= 1 then
			-- проверка, что на патрульных путях никого нетути
			local free = true
			for key,value in xr_motivator.storage do 
				if value.kamp.center_point == self.a.center_point and
				   value.kamp.action == 1 and
				   key ~= self.object:id() and
				   value.kamp.enabled == true then
					free = false
				end
				-- Проверка, что последнее время никто не ходил в обход 
				if value.kamp.center_point == self.a.center_point and
				   value.kamp.timer.act1.begin ~= nil and
				   (device():time_global()/1000 - value.kamp.timer.act1.begin) < self.a.timer.act1.time and
				   value.kamp.enabled == true then
					free = false
				end

			end
		
		        if free then
				actions[i] = 1
				i = i + 1
			end             	
		end

		actions[i] = 5
   
		local rr = math.random(table.getn(actions))
		self.a.action = actions[rr]
		self.a.last_action = self.a.action
		self.timer.begin = device():time_global()/1000
		self.timer.idle = math.random(self.timer.maxidle) + self.timer.sumidle
	end

	if self.a.action == 5 then
		--!!! ПРОСТО СИДИМ И ВТЫКАЕМ
		xr_state.change_state(self.object, 3)
		-- повернуть его лицом к центру
		local pp = patrol(self.a.center_point):point(0)
		pp.y = pp.y + 0.7
		self.object:set_sight(look.point, pp, 0)

		if (device():time_global()/1000 - self.timer.begin) < self.timer.idle then
		        -- Анимации
			if self.object:animation_count() == 1 then
				xr_kamp.set_anim(self.object, self.anim, self.a)
			end

			-- Саунды
			if self.object:active_sound_count() == 0 then
				if level.rain_factor() < 0.0006 then
					globals.set_sound(self.object, self.sound, false)
				else
					globals.set_sound(self.object, self.sound_r, false)
				end
			end
		else
			self.a.action = 0
		end
	end
end
function action_wait:finalize()
--	printf("[ACT] Finish: Wait")
	action_base.finalize (self)
end

----------------------------------------------------------------------------------------------------------------------
-- Functions
----------------------------------------------------------------------------------------------------------------------
-- Проигрыш анимашек
function set_anim(npc, anim, st)
	if anim.begin == nil or
	   (device():time_global()/1000 - anim.begin) > anim.idle 
	then
		anim.begin = device():time_global()/1000
		anim.idle = math.random(anim.maxidle) + anim.sumidle

		if math.random(100) < anim.rnd then
			local r = math.random(table.getn(anim.anim_active))
			npc:clear_animations()
			npc:add_animation(anim.anim_active[r].name,anim.anim_active[r].hand)
			npc:add_animation("stalker_3_2", true)
		end
	end		
end

----------------------------------------------------------------------------------------------------------------------
--Kamp binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(object)

	local operators		= {}
	local properties	= {}

	sounds["replics"] 	= xr_sounds_id.stohe_kamp_base + 1
	sounds["idle"] 		= xr_sounds_id.stohe_kamp_base + 2

	object:add_sound("script_replics\\bandit_1\\replics\\bandit_replic_", 20, snd_type.talk, 2, 1, sounds["replics"])
	object:add_sound("script_replics\\bandit_1\\idle\\bandit_idle_", 20, snd_type.talk, 2, 1, sounds["idle"])

	local manager = object:motivation_action_manager()

	properties["state_end"]		= xr_evaluators_id.state_change
	properties["event"] 		= xr_evaluators_id.stohe_reactions_base + 0
	properties["kamp_end"]		= xr_evaluators_id.stohe_kamp_base + 1
	properties["on_position"]	= xr_evaluators_id.stohe_kamp_base + 2
	properties["need_patrol"]	= xr_evaluators_id.stohe_kamp_base + 4

	operators["go_position"]	= xr_actions_id.stohe_kamp_base + 2
	operators["go_patrol"]		= xr_actions_id.stohe_kamp_base + 3
	operators["wait"]		= xr_actions_id.stohe_kamp_base + 4

	-- Evaluators                                                                            
	manager:add_evaluator (properties["kamp_end"], 		this.evaluator_kamp_end		(xr_motivator.storage[object:id()].kamp))
	manager:add_evaluator (properties["on_position"],	this.evaluator_on_position	(xr_motivator.storage[object:id()].kamp))
	manager:add_evaluator (properties["need_patrol"],	this.evaluator_need_patrol	(xr_motivator.storage[object:id()].kamp))

	-- Actions
	action = this.action_go_patrol (object:name(),"action_go_patrol", xr_motivator.storage[object:id()].kamp)
	action:add_precondition		(world_property(stalker_ids.property_alive, 	true))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
	action:add_precondition		(world_property(properties["event"], 		false))
	action:add_precondition		(world_property(properties["state_end"], 	true))
	action:add_precondition		(world_property(properties["need_patrol"],	true))
	action:add_effect 		(world_property(properties["kamp_end"], 	true))
	manager:add_action (operators["go_patrol"], action)

	action = this.action_wait (object:name(),"action_kamp_wait", xr_motivator.storage[object:id()].kamp)
	action:add_precondition		(world_property(stalker_ids.property_alive, 	true))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
	action:add_precondition		(world_property(properties["on_position"], 	true))
	action:add_precondition		(world_property(properties["state_end"], 	true))
	action:add_precondition		(world_property(properties["event"], 		false))
	action:add_precondition		(world_property(properties["need_patrol"],	false))
	action:add_effect 		(world_property(properties["kamp_end"], 	true))
	manager:add_action (operators["wait"], action)

	action = this.action_go_position (object:name(),"action_go_kamp", xr_motivator.storage[object:id()].kamp)
	action:add_precondition		(world_property(stalker_ids.property_alive, 	true))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
	action:add_precondition		(world_property(properties["state_end"], 	true))
	action:add_precondition		(world_property(properties["event"], 		false))
	action:add_precondition 	(world_property(properties["on_position"], 	false))
	action:add_effect 		(world_property(properties["on_position"], 	true))
	manager:add_action (operators["go_position"], action)

	action = manager:action (stalker_ids.action_puzzle_solver)	
	action:add_precondition		(world_property(properties["kamp_end"],		true))
end
-- включение лагеря
function set_kamp(object, enable, center_point, patrol_path)
	-- enable - будет ли работать схема в принципе
	-- center_point - центр лагеря
	-- patrol_path - патрульные пути для обхода
	local char_ini = object:spawn_ini()
	local st = xr_motivator.storage[object:id()].kamp

	if enable == nil then
	    	if char_ini:section_exist ("kamp") == true then
        		if char_ini:line_exist("kamp", "enabled") == true then
                		st.enabled = char_ini:r_bool("kamp", "enabled")
			else
				st.enabled = false
		        end
		else
			st.enabled = false
		end
	else
		st.enabled = enable		
	end	

	if st.enabled == true then
		if center_point == nil then
		    	if char_ini:section_exist ("kamp") == true then
	        		if char_ini:line_exist("kamp", "center_point") == true then
		        	        st.center_point = char_ini:r_string("kamp", "center_point")
	        		else
		        	    	st.enabled = false
			        end
			else
				st.enabled = false
			end
		else
			st.center_point = center_point
		end
	end
	if st.enabled == true then
		if patrol_path == nil then
		    	if char_ini:section_exist ("kamp") == true then
	        		local i = 1
			        while char_ini:line_exist("kamp", "patrol_path_"..i) == true do
        				st.patrol_path[i] = char_ini:r_string("kamp", "patrol_path_"..i)
					i = i + 1
		    		end
			end
		else
			st.patrol_path = patrol_path
		end
	end
	xr_motivator.checkStorage(object)
end]]

function action2(obj,...)
    local act = entity_action()
    local i = 1
    while true do
        if (arg[i] ~= nil) then
            act:set_action(arg[i])
        else
            break
        end
        i = i + 1
    end
    if (obj ~= nil) then
        obj:command(act,false)
    end
    return  entity_action(act)
end

---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
-- Константа
class "evaluator_need_sleeper" (property_evaluator)
function evaluator_need_sleeper:__init(storage) super ()
  self.a = storage
end
function evaluator_need_sleeper:evaluate ()
  local tt

  tt = self.a.enabled == true

      return tt
end

----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
-- Обычное поведение
class "action_sleeper_activity" (action_base)
function action_sleeper_activity:__init (npc_name,action_name,storage) super (nil, action_name)
    self.a = storage

    self.state_none = 0
    self.state_standing_before_anim = 1
    self.state_anim_playing = 2
    self.state_moving = 3

    self.state = self.state_none

    self.path_main = self.a.path_main

  -- TODO: выбирать активный путь в зависимости от погоды (сделать выбор функцией)
    self.path_active = self.path_main

    -- Точка, в которую смотрели в прошлый раз. Ее запоминаем для того, чтобы не делать паузу между анимациями,
    -- если собираемся смотреть в ту же самую точку, не поворачиваясь никуда...
    self.last_look_index = nil
end
function action_sleeper_activity:initialize()
    action_base.initialize(self)
    self.object:set_node_evaluator()
    self.object:set_path_evaluator()
    self.object:set_desired_position()
    self.object:set_desired_direction()

    --self.object:set_item(object.deactivate, self.object:best_weapon())
    self.object:set_detail_path_type(move.line)
    self.object:set_body_state(move.standing)
    self.object:set_movement_type(move.walk)
    self.object:set_path_type(game_object.patrol_path)
    self.object:set_patrol_path(self.path_active, patrol.start, patrol.continue, true)
    self.object:set_mental_state(anim.free)
    self.object:set_sight(look.search, nil, 0)

    self.state = self.state_moving

    self.object:set_callback(self, "waypoint_callback", game_object.movement)
end
function action_sleeper_activity:waypoint_callback(obj, action_type, index)
    -- Будет использоваться позже для вызова этой функции с целью иммитации коллбека (для путей, состоящих из одной точки):
    self.last_action_type = action_type
    self.last_index = index

    if index == -1 then
        return
    end

    local ptr = patrol(self.path_active)
    self.object:set_movement_type(move.stand)

    -- Выбрать случайно одну из точек, чтобы посмотреть в нее:
    local pt_chosen = nil
    local pt_found = 0

    local num_points = ptr:count()
    for i = 0, num_points - 1 do
        if i ~= index then
            pt_found = pt_found + 1
            local r = math.random(1, pt_found)
            if r == 1 then
                pt_chosen = i
            end
        end
    end

    if pt_chosen then
        if pt_chosen ~= self.last_look_index then
            self.object:clear_animations () -- не играть анимацию во время поворота!
            self.expiration_time = device():time_global() + 1500; -- дать 100 мс на поворот
            self:look_at_waypoint(pt_chosen) -- поворачиваемся
        else
            self.expiration_time = 0 -- сразу же стартовать анимацию, уже смотрим в нужную сторону
        end
        self.state = self.state_standing_before_anim
        self.object:set_movement_type(move.stand)
    end
end

-- Посмотреть в направлении указанной точки текущего маршрута
function action_sleeper_activity:look_at_waypoint(pt)
    local way = patrol (self.object:patrol ())
    local look_pt = this.vector_copy_by_val(way:point(pt)):sub (self.object:position ())
    self.object:set_sight(look.direction, look_pt, 0)
    self.last_look_index = pt

    self.object:set_item(object.deactivate, self.object:best_weapon())
end

function action_sleeper_activity:execute()
	printf("sleeper[%d]: self.state = %d", device():time_global(), self.state)
	if self.state == self.state_standing_before_anim and self.expiration_time and
	   device():time_global() >= self.expiration_time then
		xr_state.change_state(self.object, 4)
		self.state = self.state_anim_playing
	end
end

function action_sleeper_activity:finalize()
  self.last_look_index = nil -- воможно уходим с точки, последнее неправление взгляда уже не актуально

    self.object:clear_callback(game_object.movement)
    action_base.finalize(self)
end

----------------------------------------------------------------------------------------------------------------------
--Guard binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc)
  local operators    = {}
  local properties  = {}

  sounds["commander_snd"]     = xr_sounds_id.zmey_sleeper_base + 1
  sounds["soldiers_idle_snd"]     = xr_sounds_id.zmey_sleeper_base + 2
  sounds["soldiers_idle2_snd"]     = xr_sounds_id.zmey_sleeper_base + 3
  sounds["soldiers_replics_snd"]     = xr_sounds_id.zmey_sleeper_base + 4
  sounds["soldiers_hear_snd"]     = xr_sounds_id.zmey_sleeper_base + 5
  sounds["soldier_alarm"]     = xr_sounds_id.zmey_sleeper_base + 6

  npc:add_sound ("Scripts\\Patrol\\Commander1_",           20, snd_type.talk, 2, 1, sounds["commander_snd"])
  npc:add_sound ("Scripts\\Patrol\\soldier_idle_",         20, snd_type.talk, 2, 1, sounds["soldiers_idle_snd"])
  npc:add_sound ("script_replics\\soldier_1\\idle\\soldier_idle_",     20, snd_type.talk, 2, 1, sounds["soldiers_idle2_snd"])
  npc:add_sound ("script_replics\\soldier_1\\replics\\soldier_replic_",     20, snd_type.talk, 2, 1, sounds["soldiers_replics_snd"])
  npc:add_sound ("script_replics\\soldier_1\\hear_something\\soldier_hear_",   20, snd_type.talk, 2, 1, sounds["soldiers_hear_snd"])
  npc:add_sound ("script_replics\\soldier_1\\alarm\\soldier_alarm_",     20, snd_type.talk, 2, 2, sounds["soldier_alarm"])

  local manager = npc:motivation_action_manager()

  properties["need_sleeper"]   = xr_evaluators_id.zmey_sleeper_base + 1
  properties["state_end"]      = xr_evaluators_id.state_change

  operators["action_sleeper"]   = xr_actions_id.zmey_sleeper_base + 1

  -- // evaluators
  manager:add_evaluator (properties["need_sleeper"],   this.evaluator_need_sleeper  (xr_motivator.storage[npc:id()].sleeper))

  local new_action = this.action_sleeper_activity(npc, "action_sleeper_activity", xr_motivator.storage[npc:id()].sleeper)
  new_action:add_precondition    (world_property(stalker_ids.property_alive,   	true))
  new_action:add_precondition    (world_property(stalker_ids.property_enemy,   	false))
  new_action:add_precondition    (world_property(properties["need_sleeper"],   	true))
  new_action:add_precondition    (world_property(properties["state_end"], 	true))
  new_action:add_effect(world_property(properties["need_sleeper"], false))
  manager:add_action(operators["action_sleeper"], new_action)

  new_action = manager:action(stalker_ids.action_puzzle_solver)
  new_action:add_precondition(world_property(properties["need_sleeper"], false))
end

-- функции
function vector_copy_by_val(vec)
  local newvec = vector()
  newvec.x = vec.x
  newvec.y = vec.y
  newvec.z = vec.z
  return newvec
end
