local sounds = {}

---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
--  онстанта
class "evaluator_need_sleeper" (property_evaluator)
function evaluator_need_sleeper:__init(storage) super ()
  self.a = storage
end
function evaluator_need_sleeper:evaluate ()
  local tt

  tt = self.a.enabled == true

      return tt
end

----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
-- ќбычное поведение
class "action_sleeper_activity" (action_base)
function action_sleeper_activity:__init (npc_name,action_name,storage) super (nil, action_name)
    self.a = storage
	self.timer = {begin = nil,
			idle = nil,
			maxidle = 10,
			sumidle = 20,
			random = 50 }
end
function action_sleeper_activity:initialize()
    action_base.initialize(self)
    self.object:set_node_evaluator()
    self.object:set_path_evaluator()
    self.object:set_desired_position()
    self.object:set_desired_direction()

	local pp = patrol(self.a.path_main):level_vertex_id(0)
	xr_position.setPosition(self.object, pp)

	-- нужно его повернуть в одну из указанных позиций
	self.ptr = patrol (self.a.path_main)
	-- определ€ем список вершин, которые имеют такие же установленные флаги (текущую игнорируем)
	self.points = {}
	for i=0, self.ptr:count()-1, 1 do
		for j=5, 31, 1 do
			if self.ptr:flag(0, j) == true and
			   self.ptr:flag(0, j) == self.ptr:flag(i, j) and
			   i ~= 0
			then				
				table.insert(self.points, i)
			end
		end
	end
end
function action_sleeper_activity:execute()
	if xr_position.onPosition(self.object) == true and xr_state.finish_state(self.object) == true then
        	if table.getn(self.points) > 0 then
			local point = self.ptr:level_vertex_id(self.points[math.random(table.getn(self.points))])
			local pt = level.vertex_position(point)
			self.object:set_sight(look.point, pt, 0)
		end
 		self.object:set_item(object.deactivate, self.object:best_weapon())
		xr_state.change_state(self.object, xr_state.sleep)

		if self.timer.begin == nil then
			--начальна€ инициализаци€
			self.timer.begin = device():time_global()/1000
			self.timer.idle = math.random(self.timer.maxidle) + self.timer.sumidle
		end

		if device():time_global()/1000 - self.timer.begin > self.timer.idle then
			self.timer.begin = device():time_global()/1000
			self.timer.idle = math.random(self.timer.maxidle) + self.timer.sumidle

			if math.random(100) < self.timer.random then
				-- добавление рандомных анимаций
				self.object:clear_animations()
        			self.object:add_animation("spit_1",true)	
				a = xr_state.getIdle(4)
				if a ~= nil then
					self.object:add_animation(a, true)
				end
			end
		end
		if self.object:active_sound_count() == 0 then
			self.object:play_sound (sounds["sleep"] , 1, 0, 1, 0, 0)
		end
	end
end
function action_sleeper_activity:finalize()
	xr_state.change_state(self.object, xr_state.stand)
	self.object:set_sound_mask (-1)
    	self.object:set_sound_mask (0)
    	action_base.finalize(self)
end

----------------------------------------------------------------------------------------------------------------------
--Guard binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, char_ini)
    if char_ini == nil or char_ini:section_exist ("sleeper") == true then
  	local operators    = {}
  	local properties  = {}

	sounds["sleep"] 	= xr_sounds_id.stohe_kamp_base + 1

	npc:add_sound("script_replics\\soldier_1\\idle\\soldier_sleep_", 20, snd_type.talk, 2, 1, sounds["sleep"])

  	local manager = npc:motivation_action_manager()

  	properties["need_sleeper"]   	= xr_evaluators_id.zmey_sleeper_base + 1
  	properties["state_end"]      	= xr_evaluators_id.state_change
  	properties["position"]		= xr_evaluators_id.position

  	operators["action_sleeper"]   	= xr_actions_id.zmey_sleeper_base + 1

  	-- // evaluators
  	manager:add_evaluator (properties["need_sleeper"],   this.evaluator_need_sleeper  (xr_motivator.storage[npc:id()].sleeper))

  	local action = this.action_sleeper_activity(npc, "action_sleeper_activity", xr_motivator.storage[npc:id()].sleeper)
  	action:add_precondition		(world_property(stalker_ids.property_alive,   	true))
  	action:add_precondition    	(world_property(stalker_ids.property_enemy,   	false))
  	action:add_precondition    	(world_property(properties["need_sleeper"],   	true))
  	action:add_precondition    	(world_property(properties["state_end"], 	true))
  	action:add_precondition    	(world_property(properties["position"], 	true))
  	action:add_effect(world_property(properties["need_sleeper"], false))
  	manager:add_action(operators["action_sleeper"], action)

  	action = manager:action(stalker_ids.action_puzzle_solver)
  	action:add_precondition(world_property(properties["need_sleeper"], false))

	if char_ini ~= nil then xr_sleeper.set_sleeper(npc) end
    end
end
function set_sleeper(object, enable, point)
	-- enable - будет ли работать схема в принципе
	-- point - точка где спать

	local char_ini = object:spawn_ini()
	local st = xr_motivator.storage[object:id()].sleeper

	if enable == nil then
       		if char_ini:section_exist ("sleeper") == true and char_ini:line_exist("sleeper", "enabled") == true then
               		st.enabled = char_ini:r_bool("sleeper", "enabled")
		else
			st.enabled = false
	        end
	else
		st.enabled = enable		
	end	
	if st.enabled == true then
		if point == nil then
        		if char_ini:section_exist ("sleeper") == true and char_ini:line_exist("sleeper", "path_main") == true then
	        	        st.path_main = char_ini:r_string("sleeper", "path_main")
        		else
	        	    	st.enabled = false
		        end
		else
			st.path_main = point
		end
	end
	xr_motivator.checkStorage(object)
end