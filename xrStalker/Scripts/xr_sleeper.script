local sounds = {}

---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
--  онстанта
class "evaluator_need_sleeper" (property_evaluator)
function evaluator_need_sleeper:__init(storage) super ()
  self.a = storage
end
function evaluator_need_sleeper:evaluate ()
      return xr_logic.is_active(self.object, self.a)
end

----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
-- ќбычное поведение
class "action_sleeper_activity" (action_base)
function action_sleeper_activity:__init (npc_name,action_name,storage) super (nil, action_name)
    self.a = storage
	self.timer = {begin = nil,
			idle = nil,
			maxidle = 10,
			sumidle = 20,
			random = 50 }
	self.ptr = nil
	self.ptrname = nil
	self.points = {}	
	self.state = 0 --' счетчик FSM

	self.sound_w = { rnd = 60,
				   maxidle = 10, 
				   sumidle = 10,
				   themes = { "weather", "state" } }	
	self.sound_s = { rnd = 100,
				   maxidle = 1, 
				   sumidle = 0,
				   themes = { "sleep" } }
end
function action_sleeper_activity:initialize()
    action_base.initialize(self)
    self.object:set_node_evaluator()
    self.object:set_path_evaluator()
    self.object:set_desired_position()
    self.object:set_desired_direction()        
end
function action_sleeper_activity:execute()
	action_base.execute(self)
	
	self.object:set_item(object.deactivate, self.object:best_weapon())	
	if xr_state.finish_state(self.object) ~= true then	
		return
	end
	
	if self.ptrname ~= self.a.path_main then
		self.state = 0
	end
	
	if self.state == 0 then	--' инициализаци€
		self.ptr = patrol (self.a.path_main)
		self.ptrname = self.a.path_main
		for i=0, self.ptr:count()-1, 1 do
			for j=5, 31, 1 do
				if self.ptr:flag(0, j) == true and
				   self.ptr:flag(0, j) == self.ptr:flag(i, j) and
				   i ~= 0
				then				
					table.insert(self.points, i)
				end
			end
		end
		xr_state.change_state(self.object, xr_state.stand)
		self.state = 1			
	end

	if self.object:position():distance_to_sqr(level.vertex_position(self.ptr:level_vertex_id(0))) < 1 then
		self.state = 3
	end
	
	if self.state == 1 then	--' приход на точку
		self.object:set_mental_state(anim.free)
		self.object:set_sight(look.path_dir, nil, 0)
		self.object:set_movement_type(move.walk)
		self.object:set_path_type(game_object.level_path)
		self.object:set_dest_level_vertex_id(self.ptr:level_vertex_id(0))
		self.object:set_desired_direction()
		self.state = 2		
	end

	if self.state == 3 then	--' спим	
        if table.getn(self.points) > 0 then
			local point = self.ptr:level_vertex_id(self.points[math.random(table.getn(self.points))])
			local pt = level.vertex_position(point)
			self.object:set_sight(look.point, pt, 0)
		end 

		if self.a.wakeable ~= nil and self.a.wakeable == true then
			xr_state.change_state(self.object, xr_state.sit)
			xr_sound.sound_update(self.object, self.sound_w)
		else		
			xr_state.change_state(self.object, xr_state.sleep)
			if self.timer.begin == nil then
				self.timer.begin = device():time_global()/1000
				self.timer.idle = math.random(self.timer.maxidle) + self.timer.sumidle
			end		
			if device():time_global()/1000 - self.timer.begin > self.timer.idle then
				self.timer.begin = device():time_global()/1000
				self.timer.idle = math.random(self.timer.maxidle) + self.timer.sumidle
				if math.random(100) < self.timer.random then
					-- добавление рандомных анимаций
					self.object:clear_animations()
        			self.object:add_animation("spit_1",true)	
					self.object:add_animation("spit_2",true)
				end
			end
			xr_sound.sound_update(self.object, self.sound_s)
		end
		
		xr_logic.try_switch_to_another_section(self.object, self.a)		
	end
end
function action_sleeper_activity:finalize()
	xr_state.change_state(self.object, xr_state.stand)
   	action_base.finalize(self)
end

----------------------------------------------------------------------------------------------------------------------
--Sleeper binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
  	local operators    = {}
  	local properties  = {}

	sounds["sleep"] 	= xr_sounds_id.stohe_kamp_base + 1

	npc:add_sound("script_replics\\soldier_1\\idle\\soldier_sleep_", 20, snd_type.talk, 2, 1, sounds["sleep"])

  	local manager = npc:motivation_action_manager()

  	properties["need_sleeper"]   	= xr_evaluators_id.zmey_sleeper_base + 1

  	operators["action_sleeper"]   	= xr_actions_id.zmey_sleeper_base + 1

  	-- // evaluators
  	manager:add_evaluator (properties["need_sleeper"],   this.evaluator_need_sleeper  (xr_motivator.storage[npc:id()].sleeper))

  	local action = this.action_sleeper_activity(npc, "action_sleeper_activity", xr_motivator.storage[npc:id()].sleeper)
  	action:add_precondition		(world_property(stalker_ids.property_alive,   	true))
  	action:add_precondition    	(world_property(stalker_ids.property_enemy,   	false))
  	action:add_precondition    	(world_property(properties["need_sleeper"],   	true))
  	xr_motivator.addCommonPrecondition(action)
 	action:add_effect(world_property(properties["need_sleeper"], false))
  	manager:add_action(operators["action_sleeper"], action)

  	action = manager:action(xr_actions_id.alife)
  	action:add_precondition(world_property(properties["need_sleeper"], false))
end
function set_scheme(npc, ini, scheme, section, gulag_name)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
	st.logic     = xr_logic.cfg_get_switch_conditions(ini, section, npc)		
	st.path_main = utils.cfg_get_string(ini, section, "path_main", npc, true,  gulag_name)
	st.wakeable	 = utils.cfg_get_bool(ini, section, "wakeable", npc, false)
end