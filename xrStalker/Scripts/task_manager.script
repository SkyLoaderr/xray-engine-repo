function action_task_reward(npc, actor)
	local parent = get_parent(npc)
		
	for k,v in pairs(active_task) do	
		if v.completed == true and v.parent == parent then
			if v.type == "artefact" then
				dialogs.relocate_item_section(npc, v.target, "out")
			elseif v.type == "monster_part" then
				dialogs.relocate_item_section(npc, v.target, "out")
			elseif v.type == "find_item" then
				dialogs.relocate_item_section(npc, v.target, "out")
			end

			active_task[v.type].full_completed = true

			if v.reward_money ~= nil then
				dialogs.relocate_money(npc, v.reward_money, "in")
			end
			
			if v.reward_item ~= nil then
				for kk,vv in pairs(v.reward_item) do
					if npc:object(vv) ~= nil then
						dialogs.relocate_item_section(npc, vv, "in")
					else
						break
					end
				end
			end

			if v.reward_reputation ~= nil then
				db.actor:change_character_reputation(db.actor:character_reputation() + v.reward_reputation)
			end

			if v.reward_relation ~= nil then
				for kk,vv in pairs(v.reward_relation) do
					relation_registry.change_community_goodwill (kk, db.actor:id(), tonumber(vv))
				end
			end

			if v.reward_rank ~= nil then
				actor_stats.add_points("quests", v.name, 1, v.reward_rank)
				db.actor:set_character_rank(db.actor:character_rank() + v.reward_rank)
			end
				
			-- устанавливаем время последнего обновления задания
			for kk,vv in pairs(task_info[parent]) do
				if vv.name == v.name then
					vv.last_time = game.get_game_time()
					return
				end
			end			
		end	
	end
end
function calculate_predicate(npc, tbl)
	local parent = get_parent(npc)
	local aa = alife()

	if tbl.parent ~= nil then
		if tbl.parent ~= parent then return false end
	end
	if tbl.community ~= nil then
		if tbl.community ~= db.actor:character_community() then return false end
	end
	if tbl.condlist ~= nil then
		if xr_logic.pick_section_from_condlist(db.actor, db.actor, tbl.condlist) ~= "true" then return false end
	end


	-- Проверка что квест еще не выдан
	if active_task[tbl.type] ~= nil then
		return false
	end
	
	-- Проверка по времени последнего выполнения/проваливания
	if tbl.last_time ~= nil and game.get_game_time():diffSec(tbl.last_time) < 172800 then
		return false
	end

	-- проверка по таргету
	if tbl.type == "eliminate_lager" then
		if tbl.target_objects == nil then
			return false
		end
		for k,v in pairs(tbl.target_objects) do
			local gulag = aa:object(v).gulag
			if gulag:get_population() > 0 then
				tbl.selected_target = v
				return true
			else
				return false
			end
		end
		return false
	elseif tbl.type == "kill_stalker" then
		if tbl.target_objects == nil then
			return false
		end
		local avail_obj = {}
		for k,v in pairs(tbl.target_objects) do
			local obj = aa:object(v)
			-- создаем список кто может быть выбран
			if obj ~= nil and
			   obj:alive() == true 
			then
				table.insert(avail_obj, v)
			else
				tbl.target_objects[k] = nil
			end
		end
		local nn = table.getn(avail_obj)
		if nn > 0 then
			tbl.selected_target = avail_obj[math.random(nn)]
			return true
		else
			return false
		end
	elseif tbl.type == "find_item" then
		if tbl.target_objects == nil then
			return false
		end
		local obj = aa:object(tbl.target_objects)
		if obj ~= nil then
			tbl.selected_target = tbl.target_objects
			return true
		else
			return false
		end	
	end
	

	return true
end



function reward_by_task(task, done)
--[[
	fill_phrase_table()

	--' Если done = true, то это выполненное задание, иначе проваленное.
	local descr = reward_by_task_id[task:get_id()]
	if descr == nil then
		return
	end

	if done == true then
		if descr.reward_reputation ~= nil then
			db.actor:change_character_reputation(db.actor:character_reputation() + descr.reward_reputation)
		end

		if descr.reward_relation ~= nil then
			for k,v in pairs(descr.reward_relation) do
				relation_registry.change_community_goodwill(k, db.actor:id(), tonumber(v))
			end
		end

		if descr.reward_rank ~= nil then
			actor_stats.add_points("quests", task:get_id(), 1, descr.reward_rank)
			db.actor:set_character_rank(db.actor:character_rank() + descr.reward_rank)
		end
	end
]]
end


--'------------------------------------------------------------------------------
--' NEW RANDOM TASK
--'------------------------------------------------------------------------------
local random_task = nil

local parent_by_story = {
	[003] = "trader",
	[500] = "barman",
	[902] = "ecolog",
	[507] = "dolg",
	[707] = "freedom"}

local story_by_parent = {
	trader = 003,
	barman = 500,
	ecolog = 902,
	dolg = 507,
	freedom = 707}

local return_task_by_type = {
	eliminate_lager = "return_for_reward",
	kill_stalker = "return_for_reward",
	artefact = "return_for_reward_bring",
	monster_part = "return_for_reward_bring",
	find_item = "return_for_reward_bring"}

class "CRandomTask"
function CRandomTask:__init()
	--' На конструкторе вычитываем LTX и создаем заготовки квестов.
	self.task_ini = ini_file("misc\\task_manager.ltx")
	self.task_phrase_id = 100

	--' Итерируемся по всем настройкам фраз
	if not self.task_ini:section_exist("list") then
		abort("There is no section [list] in task_manager.ltx")
	end
	local n = self.task_ini:line_count("list")
	local id, value = "",""
	local category = ""

	--' начальная установка
	self.task_info = {}
	
	for i=0,n-1 do
		result, id, value	= self.task_ini:r_line("list",i,"","")
		
		if not self.task_ini:section_exist(id) then
			abort("There is no section [%s] in task_manager.ltx", id)
		end		

		self.task_info[id] = {}
		if not self.task_ini:line_exist(id, "type") then
			abort("Task manager error: no type in section [%s]", id)
		end

		self.task_info[id].type			= self.task_ini:r_string(id, "type")			
		self.task_info[id].name			= id
		if self.task_ini:line_exist(id, "parent") then
			self.task_info[id].parent		= self.task_ini:r_string(id, "parent")
		else
			self.task_info[id].parent		= "nil"
		end
		if self.task_ini:line_exist(id, "target") then
			self.task_info[id].target		= self.task_ini:r_string(id, "target")
		end
		if self.task_ini:line_exist(id, "text") then
			self.task_info[id].text			= self.task_ini:r_string(id, "text")
		end
		if self.task_ini:line_exist(id, "description") then
			self.task_info[id].description	= self.task_ini:r_string(id, "description")				
		end


		local sss = utils.cfg_get_string(self.task_ini, id, "reward_item", nil, false, "")
		if sss ~= nil then
			self.task_info[id].reward_item = parse_names(sss) 
		else
			self.task_info[id].reward_item = sss
		end
		self.task_info[id].reward_money = utils.cfg_get_number(self.task_ini, id, "reward_money", nil, false)		
	
		if self.task_ini:line_exist(id, "community") then
			self.task_info[id].community = self.task_ini:r_string(id, "community")
		end		

		self.task_info[id].reward_rank = utils.cfg_get_number(self.task_ini, id, "reward_rank", nil, false, 0)
		self.task_info[id].reward_reputation = utils.cfg_get_number(self.task_ini, id, "reward_reputation", nil, false)
		self.task_info[id].reward_relation = parse_key_value(utils.cfg_get_string(self.task_ini, id, "reward_relation", nil, false, ""))
	
		if self.task_ini:line_exist(id, "condlist") then
			self.task_info[id].condlist = xr_logic.parse_condlist(db.actor, "task_manager", "condlist", self.task_ini:r_string(id, "condlist"))
		end		

		self.task_info[id].init_phrase_id = self:get_id()
		self.task_info[id].desc_phrase_id = self:get_id()
		self.task_info[id].yes_phrase_id = self:get_id()
		self.task_info[id].no_phrase_id = self:get_id()

		--' По умолчанию квест доступен для выдачи
		self.task_info[id].enabled = true
	end

	--' Создание дополнительных ассоциативных таблиц для облегчения поиска
	self.task_id_by_type = {}
	self.task_id_by_parent = {}
	self.task_id_by_yes_phrase_id = {}
	self.active_task_by_type = {}
	for k,v in pairs(self.task_info) do
		--' По типу квеста
		if self.task_id_by_type[v.type] == nil then
			self.task_id_by_type[v.type] = {}
		end
		table.insert(self.task_id_by_type[v.type], k)

		--' По типу вендора
		if self.task_id_by_parent[v.parent] == nil then
			self.task_id_by_parent[v.parent] = {}
		end
		table.insert(self.task_id_by_parent[v.parent], k)

		--' По id фразы согласия на квест
		self.task_id_by_yes_phrase_id[v.yes_phrase_id] = k
	end
end
--' Генератор уникальных ID для фраз
function CRandomTask:get_id()
	self.task_phrase_id = self.task_phrase_id + 1
	return self.task_phrase_id
end
--' Возвращает идентификатор вендора, с которым мы говорим
function CRandomTask:get_parent(npc)
	local story_id = npc:story_id()
	if parent_by_story[story_id] == nil then
		abort("Task manager error: wrong parent story_id[%s]", story_id)
	end
	return parent_by_story[story_id]
end
--' Выводит список доступных квестов
function CRandomTask:action_task_show(npc, actor)
	local parent = self:get_parent(npc)	
	for k,v in pairs(self.task_id_by_parent[parent]) do
		if self.task_info[v].enabled == true then
			local task_texture, task_rect = get_texture_info("ui_icons_task_"..self.task_info[v].type, "ui_iconsTotal_locations")
			db.actor:give_talk_message(game.translate_string(self.task_info[v].name), task_texture, task_rect,"iconed_trade_info")
		end
	end
end
--' Может ли вендор выдать квест
function CRandomTask:parent_can_task(actor, npc, p1, p2, p3)
	local parent = self:get_parent(npc)
	for k,v in pairs(self.task_id_by_parent[parent]) do
		if self.task_info[v].enabled == true then
			return true
		end
	end
	return false
end
--' Есть ли у игрока хоть одно задание от данного вендора
function CRandomTask:active_parent_task(actor, npc)
	local parent = self:get_parent(npc)
	for k,v in pairs(self.active_task_by_type) do
		if self.task_info[v].parent == parent then
			return true
		end				
	end
	return false
end
--' Есть ли игрока завершенные задания (которые осталось только сдать)
function CRandomTask:have_completed_job(actor, npc, p1, p2, p3)
	return false
end
--' Выдача квеста игроку
function CRandomTask:action_give_task(actor, npc, p1, p2)
	local task = CGameTask()
	
	printf("p1 = %s p2 = %s", tostring(p1), tostring(p2))

	local task_desc = self.task_info[self.task_id_by_yes_phrase_id[p2]]
	
	task:load(task_desc.type)
	task:set_title(task_desc.type)
	
	local objective = SGameTaskObjective(task,1)
	objective:set_description(task_desc.name)
	objective:set_article_id(task_desc.description)

	--' Выбираем текущую цель квеста
	self.task_info[self.task_id_by_yes_phrase_id[p2]].selected_target = task_desc.target_objects[math.random(table.getn(task_desc.target_objects))]

	if task_desc.type == "eliminate_lager" then
		objective:set_map_hint(task_desc.text)
		objective:set_map_location("green_location")
		objective:set_object_id(task_desc.selected_target)
		alife():object(task_desc.selected_target):lock_population(true)
	elseif task_desc.type == "kill_stalker" then
		objective:set_map_hint(task_desc.text)
		objective:set_map_location("green_location")
		objective:set_object_id(task_desc.selected_target)
	elseif task_desc.type == "find_item" then
		objective:set_map_hint(task_desc.text)
		objective:set_map_location("green_location")
		objective:set_object_id(task_desc.selected_target)
	end
	objective:add_complete_func("task_manager.task_complete")
	task:add_objective(objective)

	objective = SGameTaskObjective(task,2)
	objective:set_description(return_task_by_type[task_desc.type])

	objective:set_map_hint(return_task_by_type[task_desc.type])
	objective:set_map_location("blue_location")
	objective:set_object_id(alife():story_object(tonumber(story_by_parent[task_desc.parent])).id)
	
	task:add_objective(objective)
	
	db.actor:give_task(task,false)

	--' дизаблим все остальные задания данного типа, так как игрок не может одновременно обладать двумя заданиями одного типа.
	self.active_task_by_type[task_desc.type] = self.task_id_by_yes_phrase_id[p2]
	for k,v in pairs(self.task_info) do
		if v.type == task_desc.type then
			v.enabled = false
		end
	end
end
--' Отказ игроком от квеста
function CRandomTask:action_refuse_task(actor, npc, p1, p2)
	local task_desc = self.task_info[self.task_id_by_yes_phrase_id[p2]]

	--' Делаем доступными все задания данного типа
	self.task_info[self.active_task_by_type[task_desc.type]].selected_target = nil
	self.active_task_by_type[task_desc.type] = nil	
	for k,v in pairs(self.task_info) do
		if v.type == task_desc.type then
			v.enabled = true
		end
	end
end
--' Проверяем, не выполнен ли таск
function CRandomTask:task_complete(p1, p2)
	return false
end
--' Проверяем, не профейлен ли таск
function CRandomTask:task_fail(p1, p2)
	return false
end
--' Создается диалог актера, в котором будут выдаваться задания.
function CRandomTask:init_task_dialog(dlg, parent)
	local phr = dlg:AddPhrase("tm_seek_new_job",0,-1,-10000)
	local phrase_script = phr:GetPhraseScript()

	phr = dlg:AddPhrase("tm_"..parent.."_list_job",1,0,-10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddAction("task_manager.action_task_show")
	phrase_script:AddPrecondition("task_manager.precondition_vendor_can_task")
		
	phr = dlg:AddPhrase("tm_"..parent.."_has_no_job",2,0,-10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddPrecondition("task_manager.precondition_vendor_cannot_task")
	
	for k,v in pairs(self.task_id_by_parent[parent]) do
		phr = dlg:AddPhrase(self.task_info[v].name, self.task_info[v].init_phrase_id, 1, -10000)		
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddPrecondition("task_manager.precondition_task_avail")

		phr = dlg:AddPhrase(self.task_info[v].text, self.task_info[v].desc_phrase_id, self.task_info[v].init_phrase_id, -10000)
		
		phr = dlg:AddPhrase("tm_seek_job_yes", self.task_info[v].yes_phrase_id, self.task_info[v].desc_phrase_id, -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.action_give_task")

		phr = dlg:AddPhrase("tm_seek_job_no", self.task_info[v].no_phrase_id, self.task_info[v].desc_phrase_id, -10000)
	end

	dlg:AddPhrase("tm_seek_job_abandon",3,1,-10000)
end
--' Создается диалог актера, в котором будут приниматься задания
function CRandomTask:init_reward_dialog(dlg, parent)
	local phr = dlg:AddPhrase("tm_reward_job",0,-1,-10000)
	local phrase_script = phr:GetPhraseScript()

	phr = dlg:AddPhrase("tm_"..parent.."_job_complete", 1, 0, -10000)
	phrase_script = phr:GetPhraseScript()
--'	phrase_script:AddAction("task_manager.action_task_reward")
	phrase_script:AddPrecondition("task_manager.precondition_have_completed_job")
			
	phr = dlg:AddPhrase("tm_"..parent.."_job_ask", 2, 0, -10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddPrecondition("task_manager.precondition_dont_have_completed_job")

	
	-- Список возможных квестов трейдера.
	for k,v in pairs(self.task_id_by_parent[parent]) do
		phr = dlg:AddPhrase(self.task_info[v].name, self.task_info[v].init_phrase_id, 2, -10000)
		phrase_script = phr:GetPhraseScript()		
--'		phrase_script:AddPrecondition("task_manager.precondition_active_task")
		
		phr = dlg:AddPhrase("tm_"..parent.."_job_what", self.task_info[v].desc_phrase_id, self.task_info[v].init_phrase_id, -10000)
		
		phr = dlg:AddPhrase("tm_job_refuse", self.task_info[v].yes_phrase_id, self.task_info[v].desc_phrase_id, -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.action_refuse_task")
			
		phr = dlg:AddPhrase("tm_job_nothing", self.task_info[v].no_phrase_id, self.task_info[v].desc_phrase_id,-10000)
	end

end
--' Регистрация целей для квестов.
function CRandomTask:register_target(obj)
	if IsStalker(obj) then
		--' Возможно регистрируется цель для квеста "убить сталкера"
		for k,v in pairs(self.task_id_by_type["kill_stalker"]) do	
			if obj.alive ~= nil and obj:alive() == true and
				obj:profile_name() == self.task_info[v].target 
			then
				if self.task_info[v].target_objects == nil then
					self.task_info[v].target_objects = {}
				end
				table.insert(self.task_info[v].target_objects, obj.id)
			end
		end

	elseif obj:clsid() == clsid.smart_terrain then
		--' Возможно регистрируется цель для квеста "вынести лагерь" или "защитить лагерь"
		for k,v in pairs(self.task_id_by_type["eliminate_lager"]) do
			if obj:name() == self.task_info[v].target then
				if self.task_info[v].target_objects == nil then
					self.task_info[v].target_objects = {}
				end
				table.insert(self.task_info[v].target_objects, obj.id)
			end
		end

	else
		--' Возможно регистрируется цель для квеста "найти предмет"
		for k,v in pairs(self.task_id_by_type["find_item"]) do
			if obj:section_name() == self.task_info[v].target then
				if self.task_info[v].target_objects == nil then
					self.task_info[v].target_objects = {}
				end
				table.insert(self.task_info[v].target_objects, obj.id)
			end				
		end
	end
end


function get_random_task()
	if random_task == nil then
		random_task = CRandomTask()
	end
	return random_task
end


function init_trader_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "trader")
end
function init_barman_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "barman")
end
function init_ecolog_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "ecolog")
end
function init_dolg_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "dolg")
end
function init_freedom_task_dialog(dlg)
	get_random_task():init_task_dialog(dlg, "freedom")
end

function init_trader_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "trader")
end
function init_barman_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "barman")
end
function init_ecolog_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "ecolog")
end
function init_dolg_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "dolg")
end
function init_freedom_reward_dialog(dlg)
	get_random_task():init_reward_dialog(dlg, "freedom")
end

function has_active_vendor_task(actor, npc)
	return get_random_task():active_parent_task(actor, npc)
end
function precondition_task_avail(actor, npc, p1, p2, p3)
	printf("*** %s %s %s %s %s", actor:name(), npc:name(), tostring(p1), tostring(p2), tostring(p3))
	return true
end

function precondition_vendor_can_task(npc, actor, p1, p2, p3)
	return get_random_task():parent_can_task(actor, npc, p1, p2, p3)
end
function precondition_vendor_cannot_task(npc, actor, p1, p2, p3)
	return not get_random_task():parent_can_task(actor, npc, p1, p2, p3)
end
function precondition_have_completed_job(npc, actor, p1, p2, p3)
	return get_random_task():have_completed_job(actor, npc, p1, p2, p3)
end
function precondition_dont_have_completed_job(npc, actor, p1, p2, p3)
	return not get_random_task():have_completed_job(actor, npc, p1, p2, p3)
end

function action_task_show(npc, actor)
	get_random_task():action_task_show(npc, actor)
end
function action_give_task(actor, npc, p1, p2)
	get_random_task():action_give_task(actor, npc, p1, p2)
end
function action_refuse_task(actor, npc, p1, p2)
	get_random_task():action_refuse_task(actor, npc, p1, p2)
end

function task_complete(p1, p2)
	return get_random_task():task_complete(p1, p2)
end
function task_fail(p1, p2)
	return get_random_task():task_fail(p1, p2)
end