function printf(fmt,...)
	log(string.format(fmt,unpack(arg)))
end

function wait_game(time_to_wait)
	if (time_to_wait == nil) then
		coroutine.yield()
	else
		local time_to_stop = game.time() + time_to_wait
		while game.time() <= time_to_stop do
			coroutine.yield()
		end
	end
end

function wait(time_to_wait)
	if (time_to_wait == nil) then
		coroutine.yield()
	else
		local time_to_stop = device().time_global + time_to_wait
		while device().time_global <= time_to_stop do
			coroutine.yield()
		end
	end
end

function action(obj,...)
	local act = entity_action()
	local i = 1
	while true do
		if (arg[i] ~= nil) then
			act:set_action(arg[i])
		else
			break
		end
		i = i + 1
	end
	obj:command(act)
end

class "pp_effector" (effector)

function pp_effector:__init(effector_type,start_time,dest_power,life_time) super(effector_type,start_time)
	self.start_time = start_time
	self.stop_time	= start_time + life_time
	self.max_power	= dest_power
end

function pp_effector:process(pp)
	effector.process(self,pp)

	local curr_time	= device().time_global
	local d			= 0.0

	if curr_time < self.start_time then
		d			= 0.0
	else
	    if curr_time < self.stop_time then
	    	d 			= (curr_time - self.start_time) / (self.stop_time - self.start_time)
	    else
	    	self.info	= self.max_power
	    	return      true
		end
	end
	
	local dual		= duality()
	local noise		= noise()
	local color		= color()

	dual.h			= self.max_power.dual.h 			* d
	dual.v			= self.max_power.dual.v 			* d
	noise.grain		= self.max_power.noise.grain 		* d
	noise.intensity = self.max_power.noise.intensity 	* d
	color.r			= self.max_power.noise.color.r 		* d
	color.g			= self.max_power.noise.color.g 		* d
	color.b			= self.max_power.noise.color.b 		* d 
	color.a			= self.max_power.noise.color.a 		* d 
	pp.gray			= self.max_power.gray 				* d
	pp.blur			= self.max_power.blur 				* d

	noise.color		= color
	pp.dual			= dual
	pp.noise		= noise
	
	self.info		= pp
	
	return          true
end

function pp_effector:finished()
	return			self.stop_time < device().time_global
end

function get_level_object(obj_name)
	res				= level.object(obj_name)
	while res == nil do
		res			= level.object(obj_name)
		wait		()
	end
	return			res
end

function get_actor()
	res				= level.actor()
	while res == nil do
		res			= level.actor()
		wait		()
	end
	return			res
end



--------------------------------------------------
-- Класс LUA реализующий Finite State Machine
-- для управления персонажами
--------------------------------------------------
class 'FSM'

-- 	инициализация путем задания объекта Non-Player Character
function FSM:__init(script_name, npc_obj)
	-- указатель на подконтрольный NPC
	self.npc = npc_obj
	-- строка - имя скрипта, который запускает игру
	self.script_name = script_name
	-- матрица, задающая граф переходов состояний
	-- реализуется как двумерная таблица
	self.transition_matrix = {[0] = {}}
	-- номер текущего состояния
	self.current_state = 0

	-- флаг того, что машина включена
	self.machine_running = true

	printf("inialization FSM for NPC %s", self.npc:name())
end

function FSM:is_running()
	return self.machine_running
end

function FSM:start()
	printf("starting FSM for %s", self.npc:name())
	self.machine_running = true
end

function FSM:stop()
	printf("stoping FSM for %s", self.npc:name())
	self.machine_running = false
	self:reset_script_control()
end


-- 	добавление указателя на булеву
-- 	функцию условия перехода
function FSM:set_transition(from_state_num, to_state_num, cond_func)
	printf("in setting transition %d, %d ", from_state_num, to_state_num)

	if self.transition_matrix[from_state_num] == nil then
	   self.transition_matrix[from_state_num] = {[to_state_num] = cond_func}
	else
	   self.transition_matrix[from_state_num][to_state_num] = cond_func
	end
end

-- единичная проверка FSM
function FSM:run()
	local transition_vector = self.transition_matrix[self.current_state]
	table.foreach(transition_vector, 
				  function(to_state_num, cond_func) 
						if cond_func(self.npc, self) == true then
							printf("transition from %d to %d", self.current_state, to_state_num)

							if to_state_num == 0 then 
								self:reset_script_control()
							end

							if  self.current_state == 0 then 
								self:set_script_control()
							end
				
							self.current_state = to_state_num
							return true
						end
						return nil
				  end)
end


-- запуск бесконечного цикла FSM
function FSM:run_loop()
	printf("running FSM loop for NPC %s", self.npc:name())

	while self:is_running() do
		local transition_vector = self.transition_matrix[self.current_state]
		table.foreach(transition_vector, 
					  function(to_state_num, cond_func) 
							if cond_func(self.npc, self) == true then
								printf("transition from %d to %d", self.current_state, to_state_num)

								if to_state_num == 0 then 
									self:reset_script_control()
								end

								--if  self.current_state == 0 then 
								--	self:set_script_control()
								--end
				
								self.current_state = to_state_num
								return true
							end
							return nil
					  end)
		wait()
	end
end

-- взятие под контроль скрипта NPC (переход из нулевого состояния)
function FSM:set_script_control()
	self.npc:script(true, self.script_name)
end

-- отпускание из под контроля скрипта NPC (переход в нулевое состояние)
function FSM:reset_script_control()
	self.npc:script(false, self.script_name)
end

--------------------------------------------------
-- end of  class 'FSM'
--------------------------------------------------







