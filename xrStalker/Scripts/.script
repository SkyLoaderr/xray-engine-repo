function printf(fmt,...)
	log(string.format(fmt,unpack(arg)))
end

function wait_game(time_to_wait)
	if (time_to_wait == nil) then
		coroutine.yield()
	else
		local time_to_stop = game.time() + time_to_wait
		while game.time() <= time_to_stop do
			coroutine.yield()
		end
	end
end
 
function wait(time_to_wait)
	if (time_to_wait == nil) then
		coroutine.yield()
	else
		local time_to_stop = device():time_global() + time_to_wait
		while device():time_global() <= time_to_stop do
			coroutine.yield()
		end
	end
end

function action(obj,...)
	local act = entity_action()
	local i = 1
	while true do
		if (arg[i] ~= nil) then
			act:set_action(arg[i])
		else
			break
		end
		i = i + 1
	end
	if (obj ~= nil) then
		obj:command(act,false)
	end
	return	entity_action(act)
end

function action_first(obj,...)
	local act = entity_action()
	local i = 1
	while true do
		if (arg[i] ~= nil) then
			act:set_action(arg[i])
		else
			break
		end
		i = i + 1
	end
	if (obj ~= nil) then
		obj:command(act,true)
	end
	return	entity_action(act)
end

class "pp_effector" (effector)

function pp_effector:__init(effector_type,start_time,dest_power,life_time) super(effector_type,start_time)
	self.start_time = start_time
	self.stop_time	= start_time + life_time
	self.max_power	= dest_power
end

function pp_effector:process(pp)
	effector.process(self,pp)

	local curr_time	= device():time_global()
	local d			= 0.0

	if curr_time < self.start_time then
		d			= 0.0
	else
	    if curr_time < self.stop_time then
	    	d 			= (curr_time - self.start_time) / (self.stop_time - self.start_time)
	    else
	    	self.info	= self.max_power
	    	return      true
		end
	end
	
	local dual		= duality()
	local noise		= noise()
	local color		= color()

	dual.h			= self.max_power.dual.h 			* d
	dual.v			= self.max_power.dual.v 			* d
	noise.grain		= self.max_power.noise.grain 		* d
	noise.intensity = self.max_power.noise.intensity 	* d
	color.r			= self.max_power.noise.color.r 		* d
	color.g			= self.max_power.noise.color.g 		* d
	color.b			= self.max_power.noise.color.b 		* d 
	color.a			= self.max_power.noise.color.a 		* d 
	pp.gray			= self.max_power.gray 				* d
	pp.blur			= self.max_power.blur 				* d

	noise.color		= color
	pp.dual			= dual
	pp.noise		= noise
	
	self.info		= pp
	
	return          true
end

function pp_effector:finished()
	return			self.stop_time < device():time_global()
end

function get_level_object(obj_name)
	local res		= level.object(obj_name)
	while res == nil do
		res			= level.object(obj_name)
		wait		()
	end
	return			res
end

function get_actor()
	local res		= level.actor()
	while res == nil do
		res			= level.actor()
		wait		()
	end
	return			res
end

function distance_between(obj1, obj2)
	return obj1:position():distance_to(obj2:position())
end


--------------------------------------------------
-- Класс LUA реализующий Finite State Machine
-- для управления персонажами
--------------------------------------------------
class 'FSM'

-- 	инициализация путем задания объекта Non-Player Character
function FSM:__init(script_name, npc_obj)
	-- указатель на подконтрольный NPC
	self.npc = npc_obj
	-- строка - имя скрипта, который запускает игру
	self.script_name = script_name
	-- матрица, задающая граф переходов состояний
	-- реализуется как двумерная таблица
	self.transition_matrix = {[0] = {}}
	-- номер текущего состояния
	self.current_state = 0

	-- флаг того, что машина включена
	self.machine_running = true

	printf("inialization FSM for NPC %s", self.npc:name())
end

function FSM:is_running()
	return self.machine_running
end

function FSM:start()
	printf("starting FSM for %s", self.npc:name())
	self.machine_running = true
end

function FSM:stop()
	printf("stoping FSM for %s", self.npc:name())
	self.machine_running = false
	self:reset_script_control()
end


-- 	добавление указателя на булеву
-- 	функцию условия перехода
function FSM:set_transition(from_state_num, to_state_num, cond_func)
	printf("in setting transition %d, %d ", from_state_num, to_state_num)

	if self.transition_matrix[from_state_num] == nil then
	   self.transition_matrix[from_state_num] = {[to_state_num] = cond_func}
	else
	   self.transition_matrix[from_state_num][to_state_num] = cond_func
	end
end

-- единичная проверка FSM
function FSM:run()
	local transition_vector = self.transition_matrix[self.current_state]
	table.foreach(transition_vector, 
				  function(to_state_num, cond_func) 
						if cond_func(self.npc, self) == true then
							printf("transition from %d to %d", self.current_state, to_state_num)

							if to_state_num == 0 then 
								self:reset_script_control()
							end

							--if  self.current_state == 0 then 
							--	self:set_script_control()
							--end
				
							self.current_state = to_state_num
							return true
						end
						return nil
				  end)
end


-- запуск бесконечного цикла FSM
function FSM:run_loop()
	printf("running FSM loop for NPC %s", self.npc:name())

	while self:is_running() do
		local transition_vector = self.transition_matrix[self.current_state]
		table.foreach(transition_vector, 
					  function(to_state_num, cond_func) 
							if cond_func(self.npc, self) == true then
								printf("transition from %d to %d", self.current_state, to_state_num)

								if to_state_num == 0 then 
									self:reset_script_control()
								end

								--if  self.current_state == 0 then 
								--	self:set_script_control()
								--end
				
								self.current_state = to_state_num
								return true
							end
							return nil
					  end)
		if self.npc:alive () == false then
		   self.npc:script (false, self.script_name)
		   return
		   end		
		wait()
	end
end

-- взятие под контроль скрипта NPC (переход из нулевого состояния)
function FSM:set_script_control()
	printf("set script control for FSM of NPC %s", self.npc:name())
	self.npc:script(true, self.script_name)
end

-- отпускание из под контроля скрипта NPC (переход в нулевое состояние)
function FSM:reset_script_control()
	printf("reset script control for FSM of NPC %s", self.npc:name())
	self.npc:script(false, self.script_name)
end

--------------------------------------------------
-- end of  class 'FSM'
--------------------------------------------------

function reset_action (npc, script_name)
	npc:script (false, script_name)
	npc:script (true, script_name)
end

class "script_object"

function script_object:__init(name,script,...)
	self.action			= action(nil,unpack(arg))
	self.object_name	= name
	self.script_name	= script
	self.object			= nil
end

function script_object:update()
	local					obj = self.object
	self.object				= level.object(self.object_name)
	if ((obj == nil) and (self.object ~= nil)) then
		self.object:script	(true,self.script_name)
		self.object:command	(self.action,false)
	end
end

--
-- Передача персонажу информации
--
function GiveInfo(obj, info_number)

	local result = obj:give_info_portion(info_number)
	while not result do
		wait()
		result = obj:give_info_portion(info_number)
	end
end 

function GiveInfoViaPda(obj_receiver, obj_sender, info_number)
	obj_receiver:give_info_portion_via_pda(info_number, obj_sender)
end 


--------------------------------------------------
-- Functions and variables added by Zmey
--------------------------------------------------

-- Константа, которую использовать в местах, где нужно задать неограниченное время действия
time_infinite = 100000000

-- Название скрипта, который в данный момент находится в отладке
-- (в этом скрипте будут срабатывать вызовы функции debug_log)
debug_script_name = ""

-- Выводит в лог строчку, если script_name == debug_script_name
-- Используется для отрадки сценариев
function debug_log(script_name, fmt, ...)
  if debug_script_name == script_name then
    log(string.format(fmt, unpack(arg)))
    flush()
  end
end

-- Если в данный момент выполняется какое-то действие, прерывает его и отключает скриптовый режим
function interrupt_action(who, script_name)
  if who:get_script() then
    who:script(false, script_name)
  end
end

function random_choice(...)
  local r = math.random(1, arg.n)
  return arg[r]
end

function new_action(...)
  local act = entity_action()
  for i = 1, arg.n do
    act:set_action(arg[i])
  end
  return act;
end

obj_last_actions = {};

function perform_action(obj, action_name, action)
  if (obj ~= nil) then
    obj_last_actions[obj] = action_name
    obj:command(act, false)
  end
end

function last_action(obj)
  return obj_last_actions[obj]
end


