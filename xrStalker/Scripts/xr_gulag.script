fraction = {}

class "fract"
function fract:__init(name)
	self.name = name

	self.state = 0 		-- состояние схемы. 0 - дефолтовое. 1 и дальше - различные особые состояния, например тревога для блокпоста
	self.stateBegin = nil

	self.checkTime = 60000 	-- время между проверками постов
	self.checkBegin = nil

	self.Object = {}        -- список ресурсов
	self.Job = {}           -- список заданий
	self.States = {}	-- список состояний

	self:loadJob(name)
	self:loadStates(name)
end
function fract:addObject(npc)
	if self.Object[npc:id()] == nil then
		table.insert(self.Object, npc:id(), npc)
	end
end
function fract:calculate() -- просчет лагеря
	-- проверка не закончилось ли время особого состояния
	if self.stateBegin ~= nil and self.state ~= 0 then
		local timeout = 0
		for k,v in self.States do
			if v.id == self.state then	
				timeout = v.timeout
				break
			end
		end
		
		if device():time_global() - self.stateBegin > timeout then
			self.state = 0
		end
	end

	-- убирание мертвых сталкеров	
	local tt = {}
	for k,v in self.Object do
		if v:alive() ~= true then
			self.Object[k] = nil
		end
	end

	-- обнуление несуществующих акторов у заданий
	for k,v in self.Job do
		if v.object ~= nil then
			-- проверить что этот актор есть в обжектах
			if is_object_online(v.object) then
				if self.Object[v.object] == nil then
					v.object = nil				
				end
			end			
		end	
	end

	-- проверка незанятых точек, переведение сталкеров на более приоритетные задания
	-- такую проверку нужно делать раз в какое то время
	local order = false
	if self.checkBegin == nil or
	   device():time_global() - self.checkBegin > self.checkTime then
		order = true
	end

	-- и затем итерировать на этой таблице при выдаче работы
	if order then
		self.checkBegin = device():time_global()
		for k,v in self.Object do
			self:setJob(v)
		end
		self:print()
	end
end
function fract:print()
	printf("---------------------- %s ----------------------", self.name)
	printf("Resources:")
	for k,v in self.Object do
		printf("id: %d name: %s", k, v:name())
	end
	printf("Jobs:")
	for k,v in self.Job do
		printf("name: %s, prior %d", v.name, v.prior)
		if v.object ~= nil then
			printf("    ObjID: %d", v.object)
			printf("    Actor: %s", self.Object[v.object]:name())
		end
	end
end
function fract:loadJob(name) -- загружает список заданий
	if name == "blockpost" then
		local t = { name = "guard",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 6,
			state = { 0, 1 }, -- в каких состояниях это задание существует
			search_light = nil,
			path_main = "blockpost_guard_left",
			path_hideout = "blockpost_guard_left" }
		table.insert(self.Job, t)			
		t = { name = "guard",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 9,
			state = { 0, 1 }, -- в каких состояниях это задание существует
			search_light = nil,
			path_main = "blockpost_guard_right",
			path_hideout = "blockpost_guard_right" }
		table.insert(self.Job, t)			
		t = { name = "guard",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 9,
			state = { 0, 1 }, -- в каких состояниях это задание существует
			search_light = "blockpost_search_light",
			path_main = "blockpost_guard_light",
			path_hideout = "blockpost_guard_light" }
		table.insert(self.Job, t)			
		t = { name = "guard",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 10,
			state = { 0, 1 }, -- в каких состояниях это задание существует
			search_light = nil,
			path_main = "blockpost_guard_center",
			path_hideout = "blockpost_guard_center" }
		table.insert(self.Job, t)
		t = { name = "patrol",
			object = nil,
			begin = nil, 
			idle = 600000,	-- раз в какое время запускается работа
			prior = 8,
			state = { 0, 1 }, -- в каких состояниях это задание существует
			patrol_path = "blockpost_patrol_0",
			escape_path = "blockpost_escape_0" }
		table.insert(self.Job, t)			
		t = { name = "follower",
			object = nil,
			begin = nil, 
			idle = 600000,	-- раз в какое время запускается работа
			prior = 7,
			state = { 0, 1 }, -- в каких состояниях это задание существует
			leader_name = nil,
			escape_path = "blockpost_escape_0" }
		table.insert(self.Job, t)			
		table.insert(self.Job, t)			
		t = { name = "sleeper",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 1,
			state = { 0, 1 }, -- в каких состояниях это задание существует
			path_main = "blockpost_sleep_1"}
		table.insert(self.Job, t)			
		t = { name = "sleeper",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 1,
			state = { 0, 1 }, -- в каких состояниях это задание существует
			path_main = "blockpost_sleep_2"}
		table.insert(self.Job, t)			
		t = { name = "sleeper",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 1,
			state = { 0, 1 }, -- в каких состояниях это задание существует
			path_main = "blockpost_sleep_3"}
		table.insert(self.Job, t)			
		t = { name = "sleeper",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 1,
			state = { 0, 1 }, -- в каких состояниях это задание существует
			path_main = "blockpost_sleep_4"}
		table.insert(self.Job, t)			
		t = { name = "sleeper",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 1,
			state = { 0, 1 }, -- в каких состояниях это задание существует
			path_main = "blockpost_sleep_5"}
		table.insert(self.Job, t)			
		t = { name = "sleeper",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 1,
			state = { 0, 1 }, -- в каких состояниях это задание существует
			path_main = "blockpost_sleep_6"}
		table.insert(self.Job, t)			
	end
end
function fract:setJob(npc) -- выбирает для данного npc наиболее приоритетное задание
	-- оно должно иметь приоритет выше, чем текущее
	local t

	for k,v in self.Job do
		local ena = false
		-- проверка что это задание доступно при данном состоянии
		for kk,vv in v.state do
			if vv == self.state then
				ena = true
				break
			end
		end
		-- проверка что данное задание не занято
		if v.object ~= nil then ena = false end
		-- проверка что пришло время.
		if v.begin ~= nil then
			printf("Time checking %s %s, %d %d %d", npc:name(), v.name, device():time_global(), v.begin, device():time_global()-v.begin)
		end

		if v.begin ~= nil and device():time_global() - v.begin < v.idle then
			ena = false
		end
		
		if ena == true then
			if t == nil then
				t = v
			else
				-- проверка по приоритету
				if v.prior > t.prior then
					t = v
				end
			end
		end

	end
	-- если приоритет выше, чем приоритет текущего задания - тогда пропускаем.
	if t ~= nil then
		for k,v in self.Job do
			if v.object == npc:id() then
				if v.prior >= t.prior then
					t = nil
					break
				end
			end
		end
	end

	if t ~= nil then
		-- удаляем у этого npc все работы (в сторадже)
		self:clearAllJob(npc)

		--устанавливаем данные для текущей работы	
		if t.name == "guard" then
			t.object = npc:id()
			t.begin = device():time_global()
		        xr_guard.set_guard(npc, true, t.path_main, t.path_hideout, t.search_light)
		end
		if t.name == "sleeper" then
			t.object = npc:id()
			t.begin = device():time_global()
		        xr_sleeper.set_sleeper(npc, true, t.path_main)			
		end
		if t.name == "patrol" then
			t.object = npc:id()
			t.begin = device():time_global()
		        xr_patrol.set_patrol(npc, true, t.patrol_path, t.escape_path)			
		end
		if t.name == "follower" then
			local nn = self:nameStalkerOnJob("patrol")
			if nn ~= nil then
				t.object = npc:id()
				t.begin = device():time_global()
			        xr_follower.set_follower(npc, true, nn, t.escape_path)			
			end
		end
	end
end
function fract:clearAllJob(npc)
	-- изменения в списке заданий
	for k,v in self.Job do
		if v.object == npc:id() then	
			v.object = nil
		end
	end

	-- изменения в сторадже
	for k,v in xr_motivator.storage[npc:id()] do
		if k == "sleeper" or
		   k == "camper" or
		   k == "scout" or
		   k == "follower" or
		   k == "patrol" or
		   k == "guard"
		then
			v.enabled = false
		end
	end
end
function fract:nameStalkerOnJob(job_name)
	for k,v in self.Job do
		if v.name == job_name then
			if v.object ~= nil then
				return self.Object[v.object]:name()
			end
		end
	end
	return nil
end
function fract:loadStates(name) -- загружает список заданий
	if name == "blockpost" then
		local t = { id = 1,  -- состояние тревоги
			    timeout = 300000 }
		table.insert(self.States, t)			
	end
end
function fract:setState(id)
	-- проверка что это состояние возможно
	for k,v in self.States do
		if v.id == id then	
			self.stateBegin = device():time_global()	
			self.state = id
			return
		end
	end
end
function fract:stalkerExsist(npc)
	-- существует ли сталкер
	if self.Object[npc:id()] ~= nil then	
		return true
	end
	return false
end


function addMember(name, npc)
	if xr_gulag.fraction[name] == nil then
		xr_gulag.fraction[name] = xr_gulag.fract(name)
	end
	xr_gulag.fraction[name]:addObject(npc)
	xr_gulag.fraction[name]:print()
	xr_gulag.fraction[name]:setJob(npc)
end
function setFractionState(name, id)
	xr_gulag.fraction[name]:setState(id)
end
function isUnderFraction(npc)
	for k,v in xr_gulag.fraction do
		if v:stalkerExsist(npc) == true then
			return k
		end
	end
	return nil
end             
function resetJob(fraction, npc)
	printf("CALLED resetJob: %s, %s", fraction, npc:name())
	xr_gulag.fraction[fraction]:clearAllJob(npc)
	xr_gulag.fraction[fraction]:setJob(npc)
end         