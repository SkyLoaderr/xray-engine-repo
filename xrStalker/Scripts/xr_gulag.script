-- Диденко Руслан (Stohe), Чугай Александр (Chugai)

--function printf()
--end

-- в работах поле object хранит id объекта

-- TODO никаких работ типа nil+out_restrictor
-- TODO если функция вызывается не из гулага, то проверять online/offline alive/dead чуваков
-- TODO серверный объект хранить в self.Object
-- TODO distance_to перевести на distance_to_sqr
-- TODO fill_idle
-- TODO у патруля перевыбор работы не будет в офлайне. надо чтоб был

level_gulags = {gulag_general, gulag_escape, gulag_garbage, gulag_agroprom, gulag_dark_valley, gulag_labx18, gulag_bar,
                gulag_military, gulag_radar, gulag_radar_u, gulag_yantar, gulag_pripyat, gulag_kishka, gulag_sarcofag,
                gulag_deadcity}

local gulag_tasks_file_name  = "misc\\gulag_tasks.ltx"
local gulag_tasks_ltx        = ini_file( gulag_tasks_file_name )

local job_position_threshold = 50 -- расстояние до места работы при котором персонаж в онлайне считается достигшим места работы

idle_nil  = nil
idle_once = -1
idle_none = -2

local path_fields = { "path_walk", "path_main", "path_home", "center_point" }

-----------------------------------------------------------------------
class "gulag"

-- конструктор
function gulag:__init(smrttrn, type, squad, groups, npc_info, capacity)
	self.smrttrn  = smrttrn
	self.name     = smrttrn:name()
	self.type     = type
	self.squad    = squad
	self.groups   = groups or {}
	self.npc_info = npc_info
	self.capacity = capacity

	self.Object            = {} -- объекты по id. Значения: nil-нету такого, true-есть в офлайне, game_object-есть в онлайн
	self.Object_begin_job  = {} -- по id. true/nil достиг ли объект места своей работы
	self.ObjectJob         = {} -- по id. номер работы для каждого персонажа
	self.JobBeginTime      = {} -- для каждой работы время начала

	self.state      = 0
	self.stateBegin = nil

	self.casualities = 0
end

-- подготовка к работе
function gulag:initialize()
	self.Job               = {} -- работы
	self.ObjectJobPathName = {} -- по id. имя патрульного пути места работы персонажа
	self.restrictors       = {} -- по id. назначенные гулагом рестрикторы для каждого персонажа

	gulag_tasks.loadJob( self.Job, self.name, self.type, self.squad, self.groups, self )
	self:init_ltx( self.name, self.type )
	self:prepare_jobs()
	self:prepare_jobs_for_new_state()

	self.calculateStates = gulag_tasks.loadStates( self.name, self.type )

	local ini = self.smrttrn:spawn_ini()
	local sect = "smart_terrain"
	if not ini:section_exist( sect ) then
		sect = "gulag1"
	end

	self.state_switch_0 = xr_logic.parse_condlist( self.smrttrn, "gulag1", "switch_0", utils.cfg_get_string(ini, sect, "switch_0", self.smrttrn, false, "", "") )
	self.state_switch_1 = xr_logic.parse_condlist( self.smrttrn, "gulag1", "switch_1", utils.cfg_get_string(ini, sect, "switch_1", self.smrttrn, false, "", "") )

	self.JobBeginTime = nil
end

-- подготовить работы.
-- подготовить данные о местоположении каждой работы; о объекте, который на ней занят.
-- подсчитать ёмкость = min(кол-во работ в 0 состоянии, поле capacity в custom data)
function gulag:prepare_jobs()
	table.sort( self.Job, function(a,b) return a.prior > b.prior end )

	local ptrl, path_name
	local capacity = 0

	for i, job in ipairs( self.Job ) do
		job.num            = i

		path_name          = self:get_job_path_name( job )
		ptrl               = patrol( path_name )

		job.path_name      = path_name
--		printf( "[smart_terrain %s] gulag.prepare_jobs: job=%s path_name=%s", self.name, job.section, path_name )
		job.game_vertex_id = ptrl:game_vertex_id( 0 )
		job.position       = ptrl:point( 0 )

		job.begin          = self.JobBeginTime[i]

		for i, v in ipairs( job.state ) do
			if v == 0 then
				capacity = capacity + 1
				break
			end
		end
	end

	self.capacity = math.min( capacity, self.capacity )

	local job

	for obj_id, jobN in pairs( self.ObjectJob ) do
		job        = self.Job[jobN]
		job.object = obj_id
		self.ObjectJobPathName[obj_id] = job.path_name
	end
end

-- подгрузка ltx с секциями логики для работ.
-- может подгрузить либо динамический ltx, либо статический (gulag_tasks.ltx)
function gulag:init_ltx(name, type)
	local ltx, ltx_name = gulag_tasks.loadLtx(name, type)

	if ltx then
		self.ltx      = ltx
		self.ltx_name = ltx_name
	else
		self.ltx      = gulag_tasks_ltx
		self.ltx_name = gulag_tasks_file_name
	end
end

-- получить имя пути места работы
function gulag:get_job_path_name( job )
	local section = job.section

	if not self.ltx:line_exist( section, "active" ) then
		abort( "gulag: ltx=%s  no 'active' in section %s", self.ltx_name, section )
	end

	local active_section = self.ltx:r_string( section, "active" )
	local path_field

	for i, v in ipairs( path_fields ) do
		if self.ltx:line_exist( active_section, v ) then
			path_field = v
			break
		end
	end

	if not path_field then
		abort( "gulag: ltx=%s, there is no path in section %s", self.ltx_name, active_section )
	end

	if path_field == "center_point" then -- TODO убрать затык
		local path_name = self.name .. "_" .. self.ltx:r_string( active_section, path_field )

		if level.patrol_path_exists( path_name .. "_task" ) then
			return path_name .. "_task"
		else
			return path_name
		end
	else
		return self.name .. "_" .. self.ltx:r_string( active_section, path_field )
	end
end

-- сохранения общего состояния гулага
function gulag:save_common( packet )
	packet:w_u8( self.casualities )
	packet:w_u8( self.state )
	utils.w_CTime( packet, self.stateBegin or smart_terrain.CTime_0 )

--	print_table( self.Job )

	packet:w_u8( table.getn( self.Job ) )

	for i, job in ipairs( self.Job ) do
		packet:w_u32( job.begin or 0 )
--		printf( "job i=%d", i )
	end
end

-- восстановление общего состояния гулага
function gulag:load_common( packet )
	self.casualities = packet:r_u8()
	self.state       = packet:r_u8()
	self.stateBegin  = utils.r_CTime( packet )

	local n = packet:r_u8()

	for i = 1, n do
		table.insert( self.JobBeginTime, packet:r_u32() )
--		printf( "job i=%d", i )
	end
end

-- сохранение информации об объекте
function gulag:save_obj( packet, obj_id )
	packet:w_bool ( self.Object_begin_job[obj_id] )
	packet:w_u8   ( self.ObjectJob[obj_id] or 0 )
end

-- восстановление информации об объекте
function gulag:load_obj( packet, obj_id )
	self.Object[obj_id]           = true
	self.Object_begin_job[obj_id] = packet:r_bool()

	local jobN = packet:r_u8()
	if jobN ~= 0 then
		self.ObjectJob[obj_id] = jobN
	end
end

-- добавить объект под гулаг.
-- при добавления объекта он помечается как офлайновый
function gulag:addObject( obj_id )
	self.Object_begin_job[obj_id] = false

	self:object_setup_offline( obj_id )
end

-- настроить персонажа на работу в офлайне.
-- если он в это время в онлайне, то вызвать object_setup_online
function gulag:object_setup_offline( obj_id )
	printf( "[smart_terrain %s] gulag: object_setup_offline: obj=%s", self.name, self.npc_info[obj_id].name )

	self.Object[obj_id] = true

	if self.npc_info[obj_id].se_obj.online then
		self:object_setup_online( obj_id, level.object_by_id( obj_id ), true )
	end
end

-- настроить персонажа на работу в онлайне.
-- вызывается у персонажей из net_spawn().
-- если он уже пришёл на работу, настроить ему логику и рестрикторы.
-- obj=game_object
function gulag:object_setup_online( obj_id, obj, need_setup_logic )
	printf( "[smart_terrain %s] gulag: object_setup_online: obj=%s need_setup_logic=%s", self.name, obj:name(), tostring( need_setup_logic) )

	--db.storage[obj_id].gulag = self

	self.Object[obj_id] = obj

	if need_setup_logic and self.ObjectJob[obj_id] then
		local job = self.Job[self.ObjectJob[obj_id]]

		self:set_restrictions( obj, job.out_rest, job.in_rest )
		self:setup_logic( obj, job.section )
	end
end

-- удалить объект из гулага.
-- вызывается только из se_smart_terrain:unregister_npc() !
-- если объект жив и он в онлайне, то переинициализировать логику.
function gulag:removeObject( obj_id )
	local obj = self.Object[obj_id]

	if obj ~= true and obj:alive() then
		self:free_obj_and_reinit( obj_id )

--		db.storage[obj_id].gulag = nil
	else
		self:free_obj( obj_id )
	end

	self.Object[obj_id]      = nil
	self.restrictors[obj_id] = nil
end

--[[ Обновление гулага
убирает мёртвых.
следит, кто прыгнул в офлайн и не сообщил об этом (случается при переходе с уровня на уровень
когда биндер смарттеррейна убивается до персонажа).
следит, дошёл ли персонаж до места работы.
измененяет потери в лагере.
вызывает функцию состояния, если есть актёр.
]]
function gulag:update()
	if not self.stateBegin then
		self.stateBegin = game.get_game_time()
	end

	local online

	for obj_id, obj in pairs( self.Object ) do
		online = self.npc_info[obj_id].se_obj.online

		if obj ~= true and not online then
			self:object_setup_offline( obj_id )
			obj = true
		end

		if self:can_obj_begin_job( obj_id, obj ) then
			self:beginJob( obj_id )
		end

		-- TODO. remove while iterating :\
		-- TODO проверка смерти в офлайн
		if obj ~= true and not obj:alive() then
			self:changeCasualities(1)
			self.smrttrn:unregister_npc( self.npc_info[obj_id].se_obj )
		end
	end

	if self.calculateStates ~= nil and db.actor then
		self:changeState(self.calculateStates(self))
	end

	self:updateJob()
	self:print()
end

-- можно ли объекту начать работать?
-- для этого проверить, не на работе ли уже.
-- если нет, то проверить, достиг ли объект места работы.
-- условия достижения персонажем места работы:
-- а) в офлайне: персонаж пришёл на нужную точку графа
-- б) в онлайне: персонаж продошёл на расстояние job_position_threshold
-- TODO делать эту проверку после updateJob
function gulag:can_obj_begin_job( obj_id, obj )
	local jobN = self.ObjectJob[obj_id]

	if jobN and not self.Object_begin_job[obj_id] then
		local job = self.Job[jobN]

		if obj == true then
			return self.npc_info[obj_id].se_obj.m_game_vertex_id == job.game_vertex_id
		else
			return obj:position():distance_to( job.position ) < ( job.position_threshold or job_position_threshold )
--			return obj:game_vertex_id() == self.Job[jobN].game_vertex_id and
--			       obj:position():distance_to( self.Job[jobN].position ) < job_position_threshold
		end
	else
		return false
	end
end

-- сменить состояние гулага.
-- TODO посчитать доступные работы на смене состояния.
-- Возобновляем все работы, доступные для наполнения только один раз.
function gulag:changeState(state)
	if self.state ~= state then
		self.state      = state
		self.stateBegin = game.get_game_time()

		self:prepare_jobs_for_new_state()
	end
end

-- существует ли указанное состояние в табличке?
function gulag:availState(st, state)
	for k,v in ipairs( st ) do
		if v == state then
			return true
		end
	end

	return false
end

-- доступна ли работа?
-- работа доступна, когда время idle истекло (или не задано)
-- и занята работа, от которой зависит данная работа.
function gulag:availJob(job)
	if job.begin == nil or game.time() - job.begin > job.idle then
		if job.fill_idle ~= nil then
			if job.fill_idle == idle_none then
				return false
			elseif job.fill_idle ~= idle_once and job.fill_idle < game.time() - job.begin then
				return false
			end
		end

		local jd = job.dependent

		if jd then
			for i, v in ipairs( self.Job ) do
				if v.section == jd then
					return v.object ~= nil
				end
			end
		end

		return true
	else
		return false
	end
end

-- Текущая работа доступна, если не истекло ее время и занята работа, от которой она зависит
function gulag:availCurrent(job)
	if job.timeout == nil or
	   job.begin == nil or game.time() - job.begin < job.timeout
	then
		local jd = job.dependent

		if jd then
	   		for i, v in ipairs( self.Job ) do
	   			if v.section == jd then
	   				return v.object ~= nil
	   			end
	   		end
		end

		return true
	else
		return false
	end
end

-- составить список работ существующих в данном состоянии гулага.
-- освобождение npc с работ, не существующих в данном состоянии.
-- обнулить fill_idle для всех работ.
-- TODO сохранение fill_idle
function gulag:prepare_jobs_for_new_state()
	local Job_avail = {}

	for i, job in ipairs( self.Job ) do
		if self:availState(job.state, self.state) then
			table.insert( Job_avail, job )
		else
			self:free_obj_and_reinit( job.object )
		end

		if job.fill_idle == idle_none then
			job.fill_idle = idle_once
		end
	end

	self.Job_avail = Job_avail
end

-- есть ли в текущем состоянии для объекта хоть одна подходящая работа?
function gulag:is_there_any_free_suitable_job( npc_info )
	printf( "is_there_any_suitable_job" )

	for i, job in ipairs( self.Job_avail ) do
		if not job.object and ( not job.predicate or job.predicate( npc_info ) ) then
			return true
		end
	end

	return false
end

-- освобождение npc с работ, ставших недоступными (например, вышел timeout).
-- также освобождение недошедших до своих работ.
function gulag:prepare_available_jobs()
	for i, job in ipairs( self.Job_avail ) do
		if not self:availCurrent(job) or not self.Object_begin_job[job.object] then
			self:free_obj_and_reinit( job.object )
		end
	end
end

-- составить список персонажей, доступных для распределения по свободным работам
function gulag:get_available_objs()
	local obj_avail = {}

	for obj_id, obj in pairs( self.Object ) do
		if self:getJob( obj_id ) == nil then
			obj_avail[obj_id] = true
		end
	end

	return obj_avail
end

-- посчитать условное расстояние от персонажа до места указанной работы.
-- если на одном уровне, то считать по локальным позициям, иначе по глобальным позициям вершин гейм-графа.
-- используется для определения ближайшего к месту работы персонажа.
function gulag:distance_to_job_location( obj_id, job )
	local obj_gv, obj_pos = self:get_obj_game_vertex_and_position( obj_id )
	local job_gv          = game_graph():vertex( job.game_vertex_id )

	if obj_gv:level_id() == job_gv:level_id() then
		return obj_pos:distance_to( job.position )
	else
		return obj_gv:game_point():distance_to( job_gv:game_point() )
	end
end

-- получить точку графа, на которой находится персонаж и его локальные координаты на уровне
-- в зависимости от того, в офлайне или в онлайне персонаж, берётся по разному
function gulag:get_obj_game_vertex_and_position( obj_id )
	local obj = self.Object[obj_id]

	if obj == true then
		obj = self.npc_info[obj_id].se_obj

		return game_graph():vertex( obj.m_game_vertex_id ), obj.position
	else
		return game_graph():vertex( obj:game_vertex_id() ), obj:position()
	end
end

-- найти ближайшего подходящего персонажа из списка
function gulag:find_nearest_suitable_obj( objs, job )
	local predicate = job.predicate
	local min_dist  = 1000000
	local dist
	local obj_nearest

	for obj_id, v in pairs( objs ) do
		if not predicate or predicate( self.npc_info[obj_id] ) then
			dist = self:distance_to_job_location( obj_id, job )
--			printf( "[smart_terrain %s] dist object=%s to job=%s is %f", self.name, self.npc_info[obj_id].name, job.section, dist )

			if dist < min_dist then
				min_dist    = dist
				obj_nearest = obj_id
			end
		end
	end

	return obj_nearest
end

-- найти занятых персонажей, которые могут занять заданную работу.
-- поиск ведётся начиная с самых низкоприоритетных работ
function gulag:find_obj_on_jobLow_for_jobHigh( job_high )
	local n = table.getn( self.Job_avail )
	local i = n

	local job_low
	local job_high_num = job_high.num
	local predicate    = job_high.predicate
	local priority     = nil
	local obj_suitable = nil

	while i > job_high_num and (not priority or priority == self.Job_avail[i].prior) do
		job_low = self.Job_avail[i]

		if job_low.object ~= nil and ( not predicate or predicate(self.npc_info[job_low.object]) ) then
			if not obj_suitable then
				priority     = job_low.prior
				obj_suitable = {}
			end

			obj_suitable[job_low.object] = true
		end

		i = i - 1
	end

	if obj_suitable then
		return self:find_nearest_suitable_obj( obj_suitable, job_high )
	else
		return nil
	end
end

-- распределение работ.
-- при распределении недошедшие персонажи приравниваются к свободным
function gulag:updateJob()
	self:prepare_available_jobs()
--	printf( "Job_avail:" )
--	print_table( self.Job_avail, "   " )

	local obj_avail = self:get_available_objs()
--	printf( "obj_avail:" )
--	print_table( obj_avail, "   " )

	local obj_id

	for i, job in ipairs( self.Job_avail ) do
		if job.object == nil then
			obj_id = self:find_nearest_suitable_obj( obj_avail, job )
			if not obj_id then
				printf( "no suitable obj for job=%d %s", i, job.section )
			end

			if not obj_id then
				obj_id = self:find_obj_on_jobLow_for_jobHigh( job )

				if obj_id then
					self:free_obj_and_reinit( obj_id )
				end
			end

			if obj_id then
				self:setJob( obj_id, job )
				obj_avail[obj_id] = nil
			end
		end
	end
end

-- вывод текущего состояния гулага (работы, объекты, состояние, население)
function gulag:print()
	local npc_info

	printf("***  %s -- State: %d -- Capacity: %d -- Population: %d", self.name, self.state, self.capacity, self:get_population())
	printf("Resources:")
	for k,v in pairs( self.Object ) do
		printf("id: %d name: %s", k, self.npc_info[k].name)
	end
	printf("Jobs:")
	for k,v in ipairs( self.Job ) do
		printf("section: %s, prior %d", v.section, v.prior)
		if v.object ~= nil then
			npc_info = self.npc_info[v.object]

			printf("    ObjID: %d", v.object)
			printf("    Actor: %s, [%s][%s][%s]", npc_info.name, npc_info.team, npc_info.squad, npc_info.group)

			if self.Object[v.object] == true then
				printf("    current section: <<<offline>>>")
			else
				printf("    current section: %s", db.storage[v.object].active_section or "<<<nil>>>")
			end
		end
	end
end

-- получить количество живых объектов под гулагом
function gulag:get_population()
	local i = 0
	local obj

	for obj_id, npc_info in pairs( self.npc_info ) do
		obj = npc_info.se_obj

		if obj.online then
			obj = level.object_by_id( obj.id )
		end

		if obj:alive() then
			i = i + 1
		end
	end

	return i
end

-- получить тип объекта (сталкер/монстр)
function gulag:get_stype( obj_id )
	if IsStalker( nil, self.npc_info[obj_id].class_id ) then
		return modules.stype_stalker
	elseif IsMonster( nil, self.npc_info[obj_id].class_id ) then
		return modules.stype_mobile
	else
		abort( "[smart_terrain %s] object %s: gulag supports stalkers and monsters only!", self.name, self.npc_info[obj_id].name )
	end
end

-- настроить логику для объекта, который в онлайне.
-- obj=game_object
function gulag:setup_logic( obj, section )
	xr_logic.configure_schemes( obj, self.ltx, self.ltx_name, self:get_stype(obj:id()), section, self.name )
	local sect = xr_logic.determine_section_to_activate( obj, self.ltx, section, db.actor )

	if utils.get_scheme_by_section( section ) == "nil" then
		abort( "[smart_terrain %s] section=%s, don't use section 'nil'!", self:name(), sect )
	end

	xr_logic.activate_by_section( obj, self.ltx, sect, false )
end

-- установить squad и group в соответствии с работой
function gulag:setup_squad_and_group( obj_id, job )
	local npc_info = self.npc_info[obj_id]

	-- онлайн?
	if self.Object[obj_id] ~= true then
		local obj = self.Object[obj_id]

		obj:change_team( npc_info.team, job.squad or npc_info.o_squad, job.group or npc_info.o_group )

		npc_info.squad = obj:squad()
		npc_info.group = obj:group()
	else
		local obj = npc_info.se_obj

		obj.squad = job.squad or npc_info.o_squad
		obj.group = job.group or npc_info.o_group

		npc_info.squad = obj.squad
		npc_info.group = obj.group
	end
end

-- установить npc работу, к ней рестрикторы, настроить логику, поменять squad, group
function gulag:setJob(obj_id, job)
	printf( "[smart_terrain %s] gulag: setJob: obj=%s job=%d %s", self.name, self.npc_info[obj_id].name, job.num, job.section )

--	self:free_obj(obj_id)

	job.object = obj_id

	self.Object_begin_job[obj_id] = false
	self.ObjectJob                  [obj_id] = job.num
	self.ObjectJobPathName          [obj_id] = job.path_name

	self:setup_squad_and_group( obj_id, job )
end

-- заступить на работу.
-- вызывается когда персонаж достиг места работы.
-- установка времени начала работы.
-- если в онлайне, то настройка логики и рестрикторов.
function gulag:beginJob( obj_id )
	local job = self.Job[self.ObjectJob[obj_id]]
	printf( "[smart_terrain %s] gulag: beginJob: obj=%s job=%d %s", self.name, self.npc_info[obj_id].name, job.num, job.section )

	self.Object_begin_job[obj_id] = true

	job.begin = game.time()

	if self.Object[obj_id] ~= true then
		local obj = self.Object[obj_id]

		self:set_restrictions( obj, job.out_rest, job.in_rest )
		self:setup_logic( obj, job.section )
	end
end

-- установить объекту рестрикторы в онлайне.
-- obj - game_object
function gulag:set_restrictions(obj, r_out, r_in)
	printf( "RESTR NPC        : %s", obj:name() )
	printf( "RESTR HAVE (IN)  : %s", obj:in_restrictions() )
	printf( "RESTR HAVE (OUT) : %s", obj:out_restrictions() )
	printf( "RESTR NEED (IN)  : %s", r_in )
	printf( "RESTR NEED (OUT) : %s", r_out )

	-- узнать, какие рестрикторы уже были назначены этим гулагом
	local restr = self.restrictors[obj:id()]

	if not restr then
		self.restrictors[obj:id()] = {}
		restr = self.restrictors[obj:id()]
	end

	local r_in_old  = restr.r_in  or ""
	local r_out_old = restr.r_out or ""

	-- удалить те, что были проставлены гулагом
	local change_r_in, change_r_out = "", ""

	if r_in_old ~= "" and r_in_old ~= r_in then
		change_r_in = r_in_old
		restr.r_in  = nil
	end

	if r_out_old ~= "" and r_out_old ~= r_out then
		change_r_out = r_out_old
		restr.r_out  = nil
	end

	if change_r_in ~= "" or change_r_out ~= "" then
		printf( "RESTR REMOVE(IN) : %s", change_r_in )
		printf( "RESTR REMOVE(OUT): %s", change_r_out )

		obj:remove_restrictions( change_r_out, change_r_in )
	end

	-- поставить новые
	change_r_in, change_r_out = "", ""

	if r_in ~= "" and r_in_old ~= r_in then
		change_r_in = r_in
		restr.r_in  = r_in
	end

	if r_out ~= "" and r_out_old ~= r_out then
		change_r_out = r_out
		restr.r_out  = r_out
	end

	if change_r_in ~= "" or change_r_out ~= "" then
		printf( "RESTR ADD(IN)    : %s", change_r_in )
		printf( "RESTR ADD(OUT)   : %s", change_r_out )

		obj:add_restrictions( change_r_out, change_r_in )
	end

	printf( "RESTR AFTER (IN) : %s", obj:in_restrictions()  )
	printf( "RESTR AFTER (OUT): %s", obj:out_restrictions() )
end

-- получить работу, которую занимает объект
function gulag:getJob(obj_id)
	local jobN = self.ObjectJob[obj_id]
	return jobN and self.Job[jobN]
end

-- возвращает имя пути места работы персонажа
function gulag:get_obj_job_path_name( obj_id )
	return self.ObjectJobPathName[obj_id]
end

-- освободить объект от работы
function gulag:free_obj(obj_id)
	local jobN = self.ObjectJob[obj_id]
	if jobN then
		self.ObjectJob[obj_id] = nil
		self.Job[jobN].object  = nil

		self.ObjectJobPathName[obj_id] = nil

		if self.Object[obj_id] ~= true and
		   self.Object_begin_job[obj_id] == true
		then
			self:set_restrictions( self.Object[obj_id], "", "" )
		end
	end
end

-- освободить объект от работы и переинициализировать логику.
-- если сталкер в онлайне и начал работу, то сбросить его схему поведения
-- как будто он только что загрузился
function gulag:free_obj_and_reinit(obj_id)
	self:free_obj(obj_id)

	local t = self.Object[obj_id]
	if t ~= nil and t ~= true and self.Object_begin_job[obj_id] then
		xr_logic.initialize_obj( t, nil, false, db.actor, self:get_stype( obj_id ) )
	end
end

-- получить id объекта, выполняющего работу
function gulag:idNPCOnJob(job_name)
	for k,v in ipairs( self.Job ) do
		if v.section == job_name then
			if v.object ~= nil then
				return v.object
			end
		end
	end
	return nil
end

-- получить потери
function gulag:getCasualities()
	return self.casualities
end

-- изменить потери
function gulag:changeCasualities(delta)
	self.casualities = self.casualities + delta
end

-- TODO, TODO, TODO
function gulag:set_relation (relation, object)
	for k,v in pairs( self.Object ) do
		v:set_relation (relation, object)
	end
end

function gulag:set_goodwill (goodwill, object)
	for k,v in pairs( self.Object ) do
		v:set_community_goodwill (goodwill, object)
	end
end

----------------------------------------------------------------------------------------------------------------------

function setup_gulag_and_logic_on_spawn( obj, st, sobject, stype, loaded )
	local sim = alife()
	if sim then
		local strn_id

		if sobject.smart_terrain_id then
			strn_id = sobject:smart_terrain_id()
		else
			strn_id = 65535
		end

--		printf( "strn_id=%s", tostring( strn_id ) )

		if strn_id ~= 65535 then
			local strn             = sim:object( strn_id )
			local need_setup_logic = strn.gulag.Object_begin_job[obj:id()] and not loaded

			strn.gulag:object_setup_online( obj:id(), obj, need_setup_logic )

			if loaded then
				--memusage.collect_info(obj, "before_logic")
				xr_logic.initialize_obj(obj, st, loaded, db.actor, stype)
				--memusage.collect_info(obj, "after_logic_before_callback")
			end
		else
			--memusage.collect_info(obj, "before_logic")
			xr_logic.initialize_obj(obj, st, loaded, db.actor, stype)
			--memusage.collect_info(obj, "after_logic_before_callback")
		end
	else
		--memusage.collect_info(obj, "before_logic")
		xr_logic.initialize_obj(obj, st, loaded, db.actor, stype)
		--memusage.collect_info(obj, "after_logic_before_callback")
	end
end

----------------------------------------------------------------------------------------------------------------------
-- Functions TODO и выше тоже
----------------------------------------------------------------------------------------------------------------------

-- получить гулаг по имени смарта
-- работает только для смартов, которые в онлайне
function get_gulag_by_name( name )
	local go_strn = db.zone_by_name[name]

	return go_strn and alife():object( go_strn:id() ).gulag
end

-- получить гулаг по story id смарта
-- работает всегда
function get_gulag_by_sid( sid )
	return alife():story_object( sid ).gulag
end

-- получить гулаг по имени или story id смарта
function get_gulag( name_or_sid )
	if type( name_or_sid ) == "number" then
		return get_gulag_by_sid( name_or_sid )
	else
		return get_gulag_by_name( name_or_sid )
	end
end

-- TODO переименовать isUnderFraction в get_npc_gulag
-- получить гулаг персонажа
-- obj=game_object
function get_npc_gulag( obj )
	local sim = alife()

	obj = sim:object( obj:id() )

	if obj:smart_terrain_id() ~= 65535 then
		return sim:object( obj:smart_terrain_id() ).gulag
	else
		return nil
	end
end

-- получить кол-во населения смарта по имени
function getGulagPopulation( name_or_sid )
	local gulag = get_gulag( name_or_sid )

	return ( gulag and gulag:get_population() ) or 0
end

-- сделать указанного персонажа врагом всех персонажей смарта, которые в онлайне
function setGulagEnemy(name_or_sid, victim)
	if not victim then
		abort("setGulagEnemy: victim == nil")
	end

	local gulag = get_gulag( name_or_sid )

	for obj_id, obj in gulag.Object do
		if obj ~= true then
			obj:set_relation( game_object.enemy, victim )
		end
	end
end

-- получить номер состояния смарта по имени
function getGulagState( name_or_sid )
	local gulag = get_gulag( name_or_sid )

	return ( gulag and gulag.state ) or 0
end

function setGulagRelation(gulag_name, relation, object)
	abort("gulag setGulagRelation: gulag_name=%s", gulag_name)

    if xr_gulag.fraction[gulag_name] == nil then return end
    xr_gulag.fraction[gulag_name]:set_relation (relation, object)
end

function setGulagGoodwill(gulag_name, goodwill, object)
	abort("gulag setGulagGoodwill: gulag_name=%s", gulag_name)

    if xr_gulag.fraction[gulag_name] == nil then return end
    xr_gulag.fraction[gulag_name]:set_goodwill (goodwill, object)
end

-- освободить персонажа от работы.
-- obj=game_object
function resetJob( obj )
	printf( "gulag resetJob: obj=%s", obj:name() )

	local gulag = get_npc_gulag( obj )
	if gulag then
		gulag:free_obj_and_reinit( obj:id() )
	end
end

function changeCasualities( name_or_sid, delta )
	local gulag = get_gulag( name_or_sid )

	if gulag then
		gulag:changeCasualities( delta )
	end
end

function getCasualities( name_or_sid )
	local gulag = get_gulag( name_or_sid )

	return ( gulag and gulag:getCasualities() ) or 0
end

-----------------------------------------------------------------------------------------------------------------

function checkStalker(npc_community, gulag_type, npc_rank, se_obj, preset_name)
    --printf ("CHECKSTALKER, COMMUNITY = %s, TYPE = %s", npc_community, gulag_type)
	if gulag_type == "test" or gulag_type == "test1" or gulag_type == "test_restr_changer" then
		return true
	end

	if gulag_type == "campers" or
	   gulag_type == "walkers" or
	   gulag_type == "rest" or
	   gulag_type == "search"
	then
		return npc_community ~= "military"
	end

	for i, v in pairs( level_gulags ) do
		if v.checkStalker(npc_community, gulag_type, npc_rank, se_obj, preset_name) then
			return true
		end
	end

	return false
end

function checkMonster(npc_community, gulag_type, npc_rank, se_obj, preset_name)
	if gulag_type == "test_mob" then
		return true
	end

    for i, v in pairs( level_gulags ) do
		if v.checkMonster(npc_community, gulag_type, npc_rank, se_obj, preset_name) then
		    return true
		end
	end

	return false
end

function checkNpc(npc_community, is_stalker, gulag_type, npc_rank, se_obj, preset_name)
--	printf("COMM %s !! %s", npc_community, gulag_type)

	if is_stalker then
		return checkStalker(npc_community, gulag_type, npc_rank, se_obj, preset_name)
	else
		return checkMonster(npc_community, gulag_type, npc_rank, se_obj, preset_name)
	end
end
