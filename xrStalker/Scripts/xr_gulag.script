fraction = {}

class "fract"
function fract:__init(name)
	self.name = name

	self.state = 0 		-- состояние схемы. 0 - дефолтовое. 1 и дальше - различные особые состояния, например тревога для блокпоста
	self.stateBegin = nil

	self.checkTime = 10000 	-- время между проверками постов
	self.checkBegin = nil

	self.Object = {}        -- список ресурсов
	self.Job = {}           -- список заданий
	self.States = {}	-- список состояний

	self:loadJob(name)
	self:loadStates(name)

	self.music = gramofon.m_gramofon("blockpost_rupor")
end
function fract:addObject(npc)
	if self.Object[npc:id()] == nil then
		table.insert(self.Object, npc:id(), npc)
	end
end
function fract:calculate() -- просчет лагеря
	-- проверка не закончилось ли время особого состояния
	if self.stateBegin ~= nil and self.state ~= 0 then
		local timeout = 0
		for k,v in self.States do
			if v.id == self.state then	
				timeout = v.timeout
				break
			end
		end
		
		if device():time_global() - self.stateBegin > timeout then
			self.state = 0
		        self.music:event(0)
		end
	end
	
	-- матюгальник
	self.music:update()

	-- убирание мертвых сталкеров	
	local tt = {}
	for k,v in self.Object do
		if v:alive() ~= true then
			self.Object[k] = nil
		end
	end

	-- обнуление несуществующих акторов у заданий
	for k,v in self.Job do
		if v.object ~= nil then
			-- проверить что этот актор есть в обжектах
			if is_object_online(v.object) then
				if self.Object[v.object] == nil then
					v.object = nil				
				end
			end			
		end	
		-- обнуление заданий, не подходящих под текущее состояние
		local avail = false
		for key,stat in v.state do
			if stat == self.state then
				avail = true
			end
		end
		if avail == false then
			v.object = nil				
		end
	end


	-- проверка незанятых точек, переведение сталкеров на более приоритетные задания
	-- такую проверку нужно делать раз в какое то время
	local order = false
	if self.checkBegin == nil or
	   device():time_global() - self.checkBegin > self.checkTime then
		order = true
	end

	-- и затем итерировать на этой таблице при выдаче работы
	if order then
		self.checkBegin = device():time_global()
		for k,v in self.Object do
			self:setJob(v)
		end
		self:print()
	end
end
function fract:print()
	printf("---------------------- %s ---------------------- State: %d", self.name, self.state)
	printf("Resources:")
	for k,v in self.Object do
		printf("id: %d name: %s", k, v:name())
	end
	printf("Jobs:")
	for k,v in self.Job do
		printf("name: %s, prior %d", v.name, v.prior)
		if v.object ~= nil then
			printf("    ObjID: %d", v.object)
			printf("    Actor: %s", self.Object[v.object]:name())
		end
	end
end
function fract:loadJob(name) -- загружает список заданий
	if name == "blockpost" then
		-- общие для всех состояний
		local t = { name = "guard",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 9,
			state = { 0, 1, 2}, -- в каких состояниях это задание существует
			running = false,
			search_light = "blockpost_search_light",
			path_main = "blockpost_guard_light",
			path_hideout = "blockpost_guard_light" }
		table.insert(self.Job, t)			
		t = { name = "guard",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 10,
			state = { 0, 1, 2}, -- в каких состояниях это задание существует
			running = false,
			search_light = nil,
			path_main = "blockpost_guard_center",
			path_hideout = "blockpost_guard_center" }
		table.insert(self.Job, t)
		t = { name = "patrol",
			object = nil,
			begin = nil, 
			idle = 600000,	-- раз в какое время запускается работа
			prior = 8,
			state = { 0, 1, 2}, -- в каких состояниях это задание существует
			patrol_path = "blockpost_patrol_0",
			escape_path = "blockpost_escape_0" }
		table.insert(self.Job, t)			
		t = { name = "follower",
			object = nil,
			begin = nil, 
			idle = 600000,	-- раз в какое время запускается работа
			prior = 7,
			state = { 0, 1, 2}, -- в каких состояниях это задание существует
			leader_name = nil,
			escape_path = "blockpost_escape_0" }
		table.insert(self.Job, t)			
		t = { name = "follower",
			object = nil,
			begin = nil, 
			idle = 600000,	-- раз в какое время запускается работа
			prior = 7,
			state = { 0, 1, 2}, -- в каких состояниях это задание существует
			leader_name = nil,
			escape_path = "blockpost_escape_0" }
		table.insert(self.Job, t)			
		t = { name = "sleeper",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 1,
			state = { 0, 1, 2}, -- в каких состояниях это задание существует
			path_main = "blockpost_sleep_1"}
		table.insert(self.Job, t)			
		t = { name = "sleeper",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 1,
			state = { 0, 1, 2}, -- в каких состояниях это задание существует
			path_main = "blockpost_sleep_2"}
		table.insert(self.Job, t)			
		t = { name = "sleeper",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 1,
			state = { 0, 1, 2}, -- в каких состояниях это задание существует
			path_main = "blockpost_sleep_3"}
		table.insert(self.Job, t)			
		t = { name = "sleeper",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 1,
			state = { 0, 1, 2}, -- в каких состояниях это задание существует
			path_main = "blockpost_sleep_4"}
		table.insert(self.Job, t)			
		t = { name = "sleeper",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 1,
			state = { 0, 1, 2}, -- в каких состояниях это задание существует
			path_main = "blockpost_sleep_5"}
		table.insert(self.Job, t)			
		t = { name = "sleeper",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 1,
			state = { 0, 1, 2}, -- в каких состояниях это задание существует
			path_main = "blockpost_sleep_6"}
		table.insert(self.Job, t)			

		-- только для спокойного состояния и для поиска вора
		t = { name = "guard",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 6,
			state = { 0, 2 }, -- в каких состояниях это задание существует
			running = false,
			search_light = nil,
			path_main = "blockpost_guard_left",
			path_hideout = "blockpost_guard_left" }
		table.insert(self.Job, t)			
		t = { name = "guard",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 6,
			state = { 0, 2 }, -- в каких состояниях это задание существует
			running = false,
			search_light = nil,
			path_main = "blockpost_guard_right",
			path_hideout = "blockpost_guard_right" }
		table.insert(self.Job, t)

		-- только для тревоги (состояние 1)
		t = { name = "guard",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 6,
			state = { 1 }, -- в каких состояниях это задание существует
			running = false,
			search_light = nil,
			path_main = "blockpost_alarm_left",
			path_hideout = "blockpost_alarm_left" }
		table.insert(self.Job, t)			
		t = { name = "guard",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 6,
			state = { 1 }, -- в каких состояниях это задание существует
			running = false,
			search_light = nil,
			path_main = "blockpost_alarm_right",
			path_hideout = "blockpost_alarm_right" }
		table.insert(self.Job, t)			
		t = { name = "guard",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 6,
			state = { 1 }, -- в каких состояниях это задание существует
			running = false,
			search_light = nil,
			path_main = "blockpost_alarm_house",
			path_hideout = "blockpost_alarm_house" }
		table.insert(self.Job, t)			
		t = { name = "guard",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 5,
			state = { 1 }, -- в каких состояниях это задание существует
			running = false,
			search_light = nil,
			path_main = "blockpost_alarm_center",
			path_hideout = "blockpost_alarm_center" }
		table.insert(self.Job, t)
		
		-- Только для поиска украденного ящика
		t = { name = "guard",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 6,
			state = { 2 }, -- в каких состояниях это задание существует
			running = true,
			search_light = nil,
			path_main = "blockpost_search1",
			path_hideout = "blockpost_search1" }
		table.insert(self.Job, t)			
		t = { name = "guard",
			object = nil,
			begin = nil, 
			idle = 0,	-- раз в какое время запускается работа
			prior = 6,
			state = { 2 }, -- в каких состояниях это задание существует
			running = true,
			search_light = nil,
			path_main = "blockpost_search2",
			path_hideout = "blockpost_search2" }
		table.insert(self.Job, t)			
	end
end
function fract:setJob(npc) -- выбирает для данного npc наиболее приоритетное задание
	-- оно должно иметь приоритет выше, чем текущее
	local t

	for k,v in self.Job do
		local ena = false
		-- проверка что это задание доступно при данном состоянии
		for kk,vv in v.state do
			if vv == self.state then
				ena = true
				break
			end
		end
		-- проверка что данное задание не занято
		if v.object ~= nil then ena = false end

		if v.begin ~= nil and device():time_global() - v.begin < v.idle then
			ena = false
		end
		
		if ena == true then
			if t == nil then
				t = v
			else
				-- проверка по приоритету
				if v.prior > t.prior then
					t = v
				end
			end
		end

	end
	-- если приоритет выше, чем приоритет текущего задания - тогда пропускаем.
	if t ~= nil then
		for k,v in self.Job do
			if v.object == npc:id() then
				if v.prior >= t.prior then
					t = nil
					break
				end
			end
		end
	end

	if t ~= nil then
		-- удаляем у этого npc все работы (в сторадже)
		self:clearAllJob(npc)

		--устанавливаем данные для текущей работы	
		if t.name == "guard" then
			t.object = npc:id()
			t.begin = device():time_global()
		        xr_guard.set_guard(npc, true, t.path_main, t.path_hideout, t.running, t.search_light)
		end
		if t.name == "sleeper" then
			t.object = npc:id()
			t.begin = device():time_global()
		        xr_sleeper.set_sleeper(npc, true, t.path_main)			
		end
		if t.name == "patrol" then
			t.object = npc:id()
			t.begin = device():time_global()
		        xr_patrol.set_patrol(npc, true, t.patrol_path, t.escape_path)			
		end
		if t.name == "follower" then
			local nn = self:nameStalkerOnJob("patrol")
			if nn ~= nil then
				t.object = npc:id()
				t.begin = device():time_global()
			        xr_follower.set_follower(npc, true, nn, t.escape_path)			
			end
		end
	end
end
function fract:clearAllJob(npc)
	-- изменения в списке заданий
	for k,v in self.Job do
		if v.object == npc:id() then	
			v.object = nil
		end
	end

	-- изменения в сторадже
	for k,v in xr_motivator.storage[npc:id()] do
		if k == "sleeper" or
		   k == "camper" or
		   k == "scout" or
		   k == "follower" or
		   k == "patrol" or
		   k == "guard"
		then
			v.enabled = false
		end
	end
end
function fract:nameStalkerOnJob(job_name)
	for k,v in self.Job do
		if v.name == job_name then
			if v.object ~= nil then
				return self.Object[v.object]:name()
			end
		end
	end
	return nil
end
function fract:loadStates(name) -- загружает список заданий
	if name == "blockpost" then
		local t = { id = 1,  -- состояние тревоги
			    timeout = 300000 }
		table.insert(self.States, t)			
		t = { id = 2,  -- состояние тревоги (стырили ящик)
			    timeout = 400000 }
		table.insert(self.States, t)			
	end
end
function fract:setState(id)
	-- проверка что это состояние возможно
	for k,v in self.States do
		if v.id == id then	
			self.stateBegin = device():time_global()	
			self.state = id
		        self.music:event(id)
			self:calculate()
			return true
		end
	end
	return false
end
function fract:getState()
	return	self.state
end
function fract:stalkerExsist(npc)
	-- существует ли сталкер
	if self.Object[npc:id()] ~= nil then	
		return true
	end
	return false
end

----------------------------------------------------------------------------------------------------------------------
-- Evaluators
----------------------------------------------------------------------------------------------------------------------
class "evaluator_alarm" (property_evaluator)
function evaluator_alarm:__init() super()
end
function evaluator_alarm:evaluate()
	local f = xr_gulag.isUnderFraction(self.object)
	if f ~= nil then
		local s = xr_gulag.getFractionState(f)
		if s == 1 then
			return true
		else 
			return false
		end
	else
		return true
	end
end
----------------------------------------------------------------------------------------------------------------------
-- Actions
----------------------------------------------------------------------------------------------------------------------
-- Инициализация торговли
class "action_alarm" (action_base)
function action_alarm:__init (npc_name,action_name) super (nil, action_name)
end
function action_alarm:initialize()
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()    

	local enemy = self.object:best_enemy()
    	if enemy and is_object_online( enemy:id() ) then
        	if enemy:clsid() == clsid.stalker or enemy:clsid() == clsid.actor then
			local f = xr_gulag.isUnderFraction(self.object)

			if f ~= nil then
				xr_gulag.setFractionState(f, 1)
			end
		end
	end
end
function action_alarm:execute ()
	action_base.execute (self)
end
function action_alarm:finalize ()
	action_base.finalize (self)
end
----------------------------------------------------------------------------------------------------------------------
-- BLOCKPOST BINDER
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(object)
	local operators		= {}
	local properties	= {}

	local manager = object:motivation_action_manager()

	properties["alarm"]		= xr_evaluators_id.stohe_gulag_base + 0
	properties["state_end"]		= xr_evaluators_id.state_change
	properties["stand"]		= xr_evaluators_id.stohe_state_base + 1

	operators["alarm"]		= xr_actions_id.stohe_gulag_base + 0

	-- Evaluators
	manager:add_evaluator (properties["alarm"], 		this.evaluator_alarm		())

	-- Actions
	local action = this.action_alarm (object:name(),"action_alarm")
	action:add_precondition		(world_property(stalker_ids.property_alive, 	true))
	action:add_precondition		(world_property(properties["alarm"], 		false))
	action:add_precondition		(world_property(properties["stand"],		true))
	action:add_precondition		(world_property(properties["state_end"],	true))
	action:add_effect 		(world_property(properties["alarm"], 		true))
	manager:add_action (operators["alarm"], action)

	action = manager:action (stalker_ids.action_combat_planner)	
	action:add_precondition		(world_property(properties["alarm"],		true))
end
----------------------------------------------------------------------------------------------------------------------
-- Function
----------------------------------------------------------------------------------------------------------------------
function addMember(name, npc)
	if xr_gulag.fraction[name] == nil then
		xr_gulag.fraction[name] = xr_gulag.fract(name)
	end
	xr_gulag.fraction[name]:addObject(npc)
	xr_gulag.fraction[name]:calculate()
end
function setFractionState(name, id)
	if xr_gulag.fraction[name] ~= nil then
		xr_gulag.fraction[name]:setState(id)
	else
		printf("ERROR MAT VASHU! netu fraction")
	end
end
function getFractionState(name)
	return xr_gulag.fraction[name]:getState()
end
function isUnderFraction(npc)
	for k,v in xr_gulag.fraction do
		if v:stalkerExsist(npc) == true then
			return k
		end
	end
	return nil
end             
function resetJob(fraction, npc)
	xr_gulag.fraction[fraction]:clearAllJob(npc)
	xr_gulag.fraction[fraction]:calculate()
end         