----------------------------------------------------------------------------------------------------------------------
--	Схема изменений положения тела
--	автор: Диденко Руслан (Stohe)
--	TODO: 
----------------------------------------------------------------------------------------------------------------------

stand = 0
sit   = 2
sit_wait = 3
sleep = 4

---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
-- Условие завершения скрипта
class "evaluator_state_end" (property_evaluator)
function evaluator_state_end:__init(storage) super()
	self.a = storage
end
function evaluator_state_end:evaluate()
	return self.a.body_state == self.a.target_state
end

-- стоим лимы
class "evaluator_standing" (property_evaluator)
function evaluator_standing:__init(storage) super()
	self.a = storage
end
function evaluator_standing:evaluate()
	return self.a.body_state == 0
end

----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
-- Изменяет положение тела
class "action_change_state" (action_base)
function action_change_state:__init (npc_name,action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_change_state:initialize()
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()  

	self.object:clear_animations()

	xr_state.transanim(self.object, self.a)

	a = xr_state.getIdle(self.a.target_state)
	if a ~= nil then
		self.object:add_animation(a, true)
	end

end
function action_change_state:execute ()
	if self.a.target_state == 0 then
		if self.object:animation_count() == 0 then
			self.a.body_state = self.a.target_state
		end
	else
		if self.object:animation_count() <= 1 then
			self.a.body_state = self.a.target_state
		end
	end

	action_base.execute (self)
end
function action_change_state:finalize ()
	action_base.finalize (self)
end

-- Вставание
class "action_stand_up" (action_base)
function action_stand_up:__init (npc_name,action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_stand_up:initialize()
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()  
	xr_state.change_state(self.object, 0, "true")
end
function action_stand_up:execute ()
	action_base.execute (self)
end
function action_stand_up:finalize ()
	action_base.finalize (self)
end

----------------------------------------------------------------------------------------------------------------------
-- Functions
----------------------------------------------------------------------------------------------------------------------
-- Проверка, изменилось ли уже положение тела или нет
function finish_state(object)
	local st = xr_motivator.storage[object:id()].state
	return st.body_state == st.target_state
end

--функция смены положения тела
function change_state(object, new, emerg)
	local st = xr_motivator.storage[object:id()].state

	if st.body_state ~= new then 
--		if emerg == "true" then
--			printf("Called emerg change state for %s: old %d, new %d", object:name(), st.body_state, new)
--		else
--			printf("Called change state for %s: old %d, new %d", object:name(), st.body_state, new)
--		end

	      	st.target_state = new
		-- add transfer animation

		if emerg == "true" then
			object:clear_animations()
			xr_state.transanim(object, st)
			st.body_state = st.target_state
		end

		return true
	else
		return false
	end
end
function getIdle(id)
	if id == 0 then
	elseif id == 1 then
		return "stalker_1_2"
	elseif id == 2 then
		return "stalker_2_1"
	elseif id == 3 then
		return "stalker_3_2"
	elseif id == 4 then
		return "spit_2"
	end
end
function transanim(object, a)
	if a.body_state == 0 then
		if a.target_state == 0 then
			--
		elseif a.target_state == 1 then
			object:add_animation("stalker_1_down", true)
		elseif a.target_state == 2 then
			object:add_animation("stalker_2_down", true)
		elseif a.target_state == 3 then
			object:add_animation("stalker_3_down", true)
		elseif a.target_state == 4 then
			object:add_animation("stalker_2_down", true)
			object:add_animation("spit_0", true)			
		end
	elseif a.body_state == 1 then
		if a.target_state == 0 then
			object:add_animation("stalker_1_up", true)
		elseif a.target_state == 1 then
			--
		elseif a.target_state == 2 then
			--!!!!
		elseif a.target_state == 3 then
			--!!!!
		elseif a.target_state == 4 then
			--!!!!
		end
	elseif a.body_state == 2 then
		if a.target_state == 0 then
			object:add_animation("stalker_2_up", true)
		elseif a.target_state == 1 then
			--!!!!
		elseif a.target_state == 2 then
			--
		elseif a.target_state == 3 then
			object:add_animation("stalker_2v3", true)
		elseif a.target_state == 4 then
			object:add_animation("spit_0", true)
		end
	elseif a.body_state == 3 then
		if a.target_state == 0 then
			object:add_animation("stalker_3_up", true)
		elseif a.target_state == 1 then
			--!!!!
		elseif a.target_state == 2 then
			object:add_animation("stalker_3v2", true)
		elseif a.target_state == 3 then
			--
		elseif a.target_state == 4 then
			--!!!!
		end
	elseif a.body_state == 4 then
		if a.target_state == 0 then
			object:add_animation("spit_3", true)
			object:add_animation("stalker_2_up", true)
		elseif a.target_state == 1 then
			--!!!!
		elseif a.target_state == 2 then
			object:add_animation("spit_3", true)
		elseif a.target_state == 3 then
			--!!!!
		elseif a.target_state == 4 then
			--
		end
	end
end
----------------------------------------------------------------------------------------------------------------------
--State binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(object)
	local operators		= {}
	local properties	= {}

	properties["state_end"]		= xr_evaluators_id.state_change
	properties["stand"]		= xr_evaluators_id.stohe_state_base + 1

	operators["state"]		= xr_actions_id.stohe_state_base + 1
	operators["stand"]		= xr_actions_id.stohe_state_base + 2

	local manager = object:motivation_action_manager()
	-- Evaluators                                                                            
	manager:add_evaluator (properties["state_end"], 		this.evaluator_state_end		(xr_motivator.storage[object:id()].state))
	manager:add_evaluator (properties["stand"], 			this.evaluator_standing			(xr_motivator.storage[object:id()].state))

	-- Actions
	local action = this.action_change_state (object:name(),"action_change_state", xr_motivator.storage[object:id()].state)
	action:add_precondition		(world_property(stalker_ids.property_alive, 	true))
  	action:add_precondition    	(world_property(stalker_ids.property_enemy,   	false))
	action:add_precondition		(world_property(properties["state_end"],	false))
	action:add_effect 		(world_property(properties["state_end"],	true))
	manager:add_action (operators["state"], action)

	action = this.action_stand_up (object:name(),"action_stand_up", xr_motivator.storage[object:id()].state)
	action:add_precondition		(world_property(stalker_ids.property_alive, 	true))
	action:add_precondition		(world_property(properties["stand"],		false))
	action:add_effect 		(world_property(properties["stand"],		true))
	manager:add_action (operators["stand"], action)

	action = manager:action (stalker_ids.action_puzzle_solver)	
	action:add_precondition		(world_property(properties["state_end"],	true))

	action = manager:action (stalker_ids.action_combat_planner)	
	action:add_precondition		(world_property(properties["stand"],		true))
end


----------------------------------------------------------------------------------------------------------------------
-- General animation scheme
----------------------------------------------------------------------------------------------------------------------
class "anims"
function anims:__init(npc)
	self.npc = npc

	self.anim = {	idle = 0,
		     	begin = nil,
		     	maxidle = 4,
		     	sumidle = 4,
   		     	rnd = 30,
			lastanim = nil,
			lastanimslot = nil, 	-- проверка изменился ли анимслот
		     	base_state = nil,  	-- базовая анимация ( nil - никаких базовых анимаций нет)
			current_state = nil	-- оверрайдинг базового состояния. Если он nil - то играем базовую
			}
	self.idle = {}
	self.idle[0] = { 	{name = "idle_0_idle_0", flag = true },
				{name = "idle_0_idle_2", flag = true },
				{name = "idle_0_idle_3", flag = true },
				{name = "idle_0_idle_4", flag = true }}
	self.idle[1] = { 	{name = "idle_1_idle_0", flag = true },
				{name = "idle_1_idle_2", flag = true },
				{name = "idle_1_idle_3", flag = true },
				{name = "idle_1_idle_4", flag = true }}
	self.idle[2] = { 	{name = "idle_2_idle_0", flag = true },
				{name = "idle_2_idle_2", flag = true },
				{name = "idle_2_idle_3", flag = true },
				{name = "idle_2_idle_4", flag = true },
				{name = "idle_2_idle_5", flag = true },
				{name = "idle_2_idle_6", flag = true },
				{name = "idle_2_idle_7", flag = true },
				{name = "idle_2_idle_8", flag = true },
				{name = "idle_2_idle_9", flag = true }}
	self.idle[3] = { 	{name = "idle_3_idle_0", flag = true },
				{name = "idle_3_idle_2", flag = true },
				{name = "idle_3_idle_3", flag = true },
				{name = "idle_3_idle_4", flag = true }}
	self.idle[4] = { 	{name = "idle_4_idle_0", flag = true },
				{name = "idle_4_idle_2", flag = true },
				{name = "idle_4_idle_3", flag = true },
				{name = "idle_4_idle_4", flag = true }}
	self.hello = {}
	self.hello[0] =  	{name = "hello_0_idle_0", flag = true }
	self.hello[1] =  	{name = "hello_1_idle_0", flag = true }
	self.hello[2] =  	{name = "hello_2_idle_0", flag = true }
	self.hello[3] =  	{name = "hello_3_idle_0", flag = true }
	self.hello[4] =  	{name = "hello_4_idle_0", flag = true }
	self.prisluh = {}
	self.prisluh[0] = { 	{name = "prisluh_0_idle_2", flag = true },
				{name = "prisluh_0_idle_3", flag = true },
				{name = "prisluh_0_idle_4", flag = true }}
	self.prisluh[1] = { 	{name = "prisluh_1_idle_2", flag = true },
				{name = "prisluh_1_idle_3", flag = true },
				{name = "prisluh_1_idle_4", flag = true }}
	self.prisluh[2] = { 	{name = "prisluh_2_idle_2", flag = true },
				{name = "prisluh_2_idle_3", flag = true },
				{name = "prisluh_2_idle_4", flag = true },
				{name = "prisluh_2_idle_5", flag = true }}
	self.prisluh[3] = { 	{name = "prisluh_3_idle_2", flag = true },
				{name = "prisluh_3_idle_3", flag = true },
				{name = "prisluh_3_idle_4", flag = true }}
	self.prisluh[4] = { 	{name = "prisluh_4_idle_2", flag = true },
				{name = "prisluh_4_idle_3", flag = true },
				{name = "prisluh_4_idle_4", flag = true }}
	self.poisk = {}
	self.poisk[0] = { 	{name = "prisluh_0_idle_0", flag = true },
				{name = "prisluh_0_idle_2", flag = true },
				{name = "prisluh_0_idle_3", flag = true },
				{name = "prisluh_0_idle_4", flag = true }}
	self.poisk[1] = { 	{name = "prisluh_1_idle_0", flag = true },
				{name = "prisluh_1_idle_2", flag = true },
				{name = "prisluh_1_idle_3", flag = true },
				{name = "prisluh_1_idle_4", flag = true }}
	self.poisk[2] = { 	{name = "prisluh_2_idle_0", flag = true },
				{name = "prisluh_2_idle_2", flag = true },
				{name = "prisluh_2_idle_3", flag = true },
				{name = "prisluh_2_idle_4", flag = true }}
	self.poisk[3] = { 	{name = "prisluh_3_idle_0", flag = true },
				{name = "prisluh_3_idle_2", flag = true },
				{name = "prisluh_3_idle_3", flag = true },
				{name = "prisluh_3_idle_4", flag = true }}
	self.poisk[4] = { 	{name = "prisluh_4_idle_0", flag = true },
				{name = "prisluh_4_idle_2", flag = true },
				{name = "prisluh_4_idle_3", flag = true },
				{name = "prisluh_4_idle_4", flag = true }}
	self.hide = {}
	self.poisk[0] = { 	{name = "d_0_idle_0", flag = true },
				{name = "d_0_idle_2", flag = true }}
	self.poisk[1] = { 	{name = "d_1_idle_0", flag = true },
				{name = "d_1_idle_2", flag = true }}
	self.poisk[2] = { 	{name = "d_2_idle_0", flag = true },
				{name = "d_2_idle_2", flag = true }}
	self.poisk[3] = { 	{name = "d_3_idle_0", flag = true },
				{name = "d_3_idle_2", flag = true }}
	self.poisk[4] = { 	{name = "d_4_idle_0", flag = true },
				{name = "d_4_idle_2", flag = true }}
			
end
-- основная функция	
function anims:update(type)
	if type == nil then
		if type ~= self.anim.base_state then
			-- финалим предидущий
			if self.anim.base_state == "idle" then
				self:remove_idle()
			end
			if self.anim.base_state == "prisluh" then
				self:remove_prisluh()
			end
			if self.anim.base_state == "poisk" then
				self:remove_poisk()
			end
			if self.anim.base_state == "hide" then
				self:remove_hide()
			end
		end
	end

	--Определяем, относится ли запрашиваемых тип ко временным
	if type == "hello"
	then
		-- меняем настройки временной анимации
		if self.anim.current_state ~= nil then
			-- финалайзим предидущий каррент стэйт
			self.npc:clear_animations()
		end
		self.anim.current_state = type
	end

	-- определяем, относится ли запрашиваемый тип к базовым
	if type == "idle" or
	   type == "prisluh" or
	   type == "poisk" or
	   type == "hide"
	then
		-- если тип соответствует текущей анимации - играть его, если нет - зафиналить предидущий и засетить новый.
		if type ~= self.anim.base_state then
			-- финалим предидущий
			if self.anim.base_state == "idle" then
				self:remove_idle()
			end
			if self.anim.base_state == "prisluh" then
				self:remove_prisluh()
			end
			if self.anim.base_state == "poisk" then
				self:remove_poisk()
			end
			if self.anim.base_state == "hide" then
				self:remove_hide()
			end

			-- устанавливаем новый
			self.anim.base_state = type
			if self.anim.base_state == "idle" then
				self:set_idle()
			end
			if self.anim.base_state == "prisluh" then
				self:set_prisluh()
			end
			if self.anim.base_state == "poisk" then
				self:set_poisk()
			end
			if self.anim.base_state == "hide" then
				self:set_hide()
			end
		end
	end

	-- Определяем, закончился ли каррент стейт
	if self.anim.current_state ~= nil and
	   self.npc:animation_count() <= 1 
	then
		self.anim.current_state = nil 
	end

	-- если curent_state не нулевой - играем его.
	-- если он нулевой - играем base_state
	if self.anim.current_state ~= nil then
		if self.anim.current_state == "hello" then			
			self:update_hello()
		end
	else
		self:update_base()
	end


end
-- проигрывается ли щас цикленный айдл или нет
function anims:safe_to_break()
	if self.anim.current_state ~= nil then
		return false
	end
	if self.npc:animation_count() <= 1 then
		return true
	end
end
-- апдейт базового класса
function anims:update_base()
	if self.anim.base_state == "idle" then
		self:update_idle()
	end
	if self.anim.base_state == "prisluh" then
		self:update_prisluh()
	end
	if self.anim.base_state == "poisk" then
		self:update_poisk()
	end
	if self.anim.base_state == "hide" then
		self:update_hide()
	end
end
-- возвращает id оружейного слота
function anims:weapon_slot()
	local weapon = self.npc:active_item()
	if weapon == nil then
		return 0
	end

	local id = get_clsid(weapon)
	if id == nil then 
		return 0
	end

	if id == clsid.wpn_pm or
    	   id == clsid.wpn_walther or
	   id == clsid.wpn_hpsa or
	   id == clsid.wpn_fort or
	   id == clsid.wpn_usp45 then
		return 1
	end

	if id == clsid.wpn_vintorez or
	   id == clsid.wpn_val or
	   id == clsid.wpn_groza or
	   id == clsid.wpn_fn2000 or   
	   id == clsid.wpn_ak74 or	
	   id == clsid.wpn_lr300 or
	   id == clsid.wpn_svd or
   	   id == clsid.wpn_svu then
		return 2
	end

	if id == clsid.wpn_shotgun then
		return 3
	end

    	if id == clsid.wpn_rpg7 then
		return 4
	end
	return 0
end
----------------------------------------------------------------------------------------------------------------------
-- Стоячий идл
----------------------------------------------------------------------------------------------------------------------
-- проигрывает идловые анимации
function anims:set_idle()
	-- выбирает нужную анимацию для данного положения тела
	-- если для данного положения тела нет пачки анимаций - ругается
	local animslot = self:weapon_slot()
	self.anim.lastanimslot = animslot

	-- Добавление зацикленного айдла для данного анимслота
	self:cycled_idle(animslot)
end
function anims:cycled_idle(animslot)
	-- Добавление зацикленного айдла для данного анимслота
	if animslot == 0 then
		self.npc:add_animation("idle_0_idle_1", true)
	elseif animslot == 1 then
		self.npc:add_animation("idle_1_idle_1", true)
	elseif animslot == 2 then
		self.npc:add_animation("idle_2_idle_1", true)
	elseif animslot == 3 then
		self.npc:add_animation("idle_3_idle_1", true)
	elseif animslot == 4 then
		self.npc:add_animation("idle_4_idle_1", true)
	end
end
function anims:update_idle()
	-- изменился ли анимслот
	local animslot = self:weapon_slot()

	if animslot ~= self.anim.lastanimslot then
		self.anim.begin = nil
		self.anim.lastanimslot = animslot
		self.npc:clear_animations()
		self:cycled_idle(animslot)
	end

	-- Определяем нужно ли добавлять анимацию или ждать
	if (self.anim.begin == nil or
	   device():time_global() - self.anim.begin > self.anim.idle) and
	   self.npc:animation_count() <= 1
	then
		-- Определение промежутков времени между анимациями
		self.anim.begin = device():time_global()
		self.anim.idle = (math.random(self.anim.maxidle) + self.anim.sumidle) * 1000
		if math.random(100) < self.anim.rnd then
			local r
			if self.anim.lastanim == nil then
				r = math.random(table.getn(self.idle[animslot]))
			else
				r = math.random(table.getn(self.idle[animslot])-1)
				if r >= self.anim.lastanim then
					r = r + 1
				end
			end
			self.anim.lastanim = r
			self.npc:clear_animations()
			self.npc:add_animation (self.idle[animslot][r].name, self.idle[animslot][r].flag)
			-- Добавление зацикленного айдла для данного анимслота
			self:cycled_idle(animslot)
		end
	end	
end                            
function anims:remove_idle()
	self.anim.base_state = nil
	self.anim.lastanim = nil
	self.anim.lastanimslot = nil 
	self.npc:clear_animations()
end
----------------------------------------------------------------------------------------------------------------------
-- Приветствие
----------------------------------------------------------------------------------------------------------------------
function anims:update_hello()
	self.anim.begin = nil
	local animslot = self:weapon_slot()

	self.anim.lastanim = nil
	self.npc:clear_animations()
	self.npc:add_animation (self.hello[animslot].name, self.hello[animslot].flag)

	-- Вызвать апдейт базового класса
	self:update_base()
end                            
----------------------------------------------------------------------------------------------------------------------
-- Прислухи
----------------------------------------------------------------------------------------------------------------------
-- проигрывает идловые анимации
function anims:set_prisluh()
	-- выбирает нужную анимацию для данного положения тела
	-- если для данного положения тела нет пачки анимаций - ругается
	local animslot = self:weapon_slot()
	self.anim.lastanimslot = animslot

	if animslot == 0 then
		self.npc:add_animation("prisluh_0_idle_0", true)
	elseif animslot == 1 then
		self.npc:add_animation("prisluh_1_idle_0", true)
	elseif animslot == 2 then
		self.npc:add_animation("prisluh_2_idle_0", true)
	elseif animslot == 3 then
		self.npc:add_animation("prisluh_3_idle_0", true)
	elseif animslot == 4 then
		self.npc:add_animation("prisluh_4_idle_0", true)
	end
	-- Добавление зацикленного айдла для данного анимслота
	self:cycled_prisluh(animslot)
end
function anims:cycled_prisluh(animslot)
	-- Добавление зацикленного айдла для данного анимслота
	if animslot == 0 then
		self.npc:add_animation("prisluh_0_idle_1", true)
	elseif animslot == 1 then
		self.npc:add_animation("prisluh_1_idle_1", true)
	elseif animslot == 2 then
		self.npc:add_animation("prisluh_2_idle_1", true)
	elseif animslot == 3 then
		self.npc:add_animation("prisluh_3_idle_1", true)
	elseif animslot == 4 then
		self.npc:add_animation("prisluh_4_idle_1", true)
	end
end
function anims:update_prisluh()
	-- изменился ли анимслот
	local animslot = self:weapon_slot()

	if animslot ~= self.anim.lastanimslot then
		self.anim.begin = nil
		self.anim.lastanimslot = animslot
		self.npc:clear_animations()
		self:cycled_prisluh(animslot)
	end

	-- Определяем нужно ли добавлять анимацию или ждать
	if (self.anim.begin == nil or
	   device():time_global() - self.anim.begin > self.anim.idle) and
	   self.npc:animation_count() <= 1
	then
		-- Определение промежутков времени между анимациями
		self.anim.begin = device():time_global()
		self.anim.idle = (math.random(self.anim.maxidle) + self.anim.sumidle) * 1000
		if math.random(100) < self.anim.rnd then
			local r
			if self.anim.lastanim == nil then
				r = math.random(table.getn(self.prisluh[animslot]))
			else
				r = math.random(table.getn(self.prisluh[animslot])-1)
				if r >= self.anim.lastanim then
					r = r + 1
				end
			end
			self.anim.lastanim = r
			self.npc:clear_animations()
			self.npc:add_animation (self.prisluh[animslot][r].name, self.prisluh[animslot][r].flag)
			-- Добавление зацикленного айдла для данного анимслота
			self:cycled_prisluh(animslot)
		end
	end	
end                            
function anims:remove_prisluh()
	local animslot = self:weapon_slot()
	self.anim.base_state = nil
	self.anim.lastanim = nil
	self.anim.lastanimslot = nil
	self.npc:clear_animations()
	if animslot == 0 then
		self.npc:add_animation("prisluh_0_idle_5", true)
	elseif animslot == 1 then
		self.npc:add_animation("prisluh_1_idle_5", true)
	elseif animslot == 2 then
		self.npc:add_animation("prisluh_2_idle_6", true)
	elseif animslot == 3 then
		self.npc:add_animation("prisluh_3_idle_5", true)
	elseif animslot == 4 then
		self.npc:add_animation("prisluh_4_idle_5", true)
	end
end
----------------------------------------------------------------------------------------------------------------------
-- Поиск
----------------------------------------------------------------------------------------------------------------------
-- проигрывает идловые анимации
function anims:set_poisk()
	-- выбирает нужную анимацию для данного положения тела
	-- если для данного положения тела нет пачки анимаций - ругается
	local animslot = self:weapon_slot()
	self.anim.lastanimslot = animslot

	-- Добавление зацикленного айдла для данного анимслота
	self:poisk_idle(animslot)
end
function anims:poisk_idle(animslot)
	-- Добавление зацикленного айдла для данного анимслота
	if animslot == 0 then
		self.npc:add_animation("poisk_0_idle_1", true)
	elseif animslot == 1 then
		self.npc:add_animation("poisk_1_idle_1", true)
	elseif animslot == 2 then
		self.npc:add_animation("poisk_2_idle_1", true)
	elseif animslot == 3 then
		self.npc:add_animation("poisk_3_idle_1", true)
	elseif animslot == 4 then
		self.npc:add_animation("poisk_4_idle_1", true)
	end
end
function anims:update_poisk()
	-- изменился ли анимслот
	local animslot = self:weapon_slot()

	if animslot ~= self.anim.lastanimslot then
		self.anim.begin = nil
		self.anim.lastanimslot = animslot
		self.npc:clear_animations()
		self:poisk_idle(animslot)
	end

	-- Определяем нужно ли добавлять анимацию или ждать
	if (self.anim.begin == nil or
	   device():time_global() - self.anim.begin > self.anim.idle) and
	   self.npc:animation_count() <= 1
	then
		-- Определение промежутков времени между анимациями
		self.anim.begin = device():time_global()
		self.anim.idle = (math.random(self.anim.maxidle) + self.anim.sumidle) * 1000
		if math.random(100) < self.anim.rnd then
			local r
			if self.anim.lastanim == nil then
				r = math.random(table.getn(self.poisk[animslot]))
			else
				r = math.random(table.getn(self.poisk[animslot])-1)
				if r >= self.anim.lastanim then
					r = r + 1
				end
			end
			self.anim.lastanim = r
			self.npc:clear_animations()
			self.npc:add_animation (self.poisk[animslot][r].name, self.poisk[animslot][r].flag)
			-- Добавление зацикленного айдла для данного анимслота
			self:poisk_idle(animslot)
		end
	end	
end                            
function anims:remove_poisk()
	self.anim.base_state = nil
	self.anim.lastanim = nil
	self.anim.lastanimslot = nil 
	self.npc:clear_animations()
end
----------------------------------------------------------------------------------------------------------------------
-- Ожидание на стреме
----------------------------------------------------------------------------------------------------------------------
-- проигрывает идловые анимации
function anims:set_hide()
	-- выбирает нужную анимацию для данного положения тела
	-- если для данного положения тела нет пачки анимаций - ругается
	local animslot = self:weapon_slot()
	self.anim.lastanimslot = animslot

	-- Добавление зацикленного айдла для данного анимслота
	self:hide_idle(animslot)
end
function anims:hide_idle(animslot)
	-- Добавление зацикленного айдла для данного анимслота
	if animslot == 0 then
		self.npc:add_animation("d_0_idle_1", true)
	elseif animslot == 1 then
		self.npc:add_animation("d_1_idle_1", true)
	elseif animslot == 2 then
		self.npc:add_animation("d_2_idle_1", true)
	elseif animslot == 3 then
		self.npc:add_animation("d_3_idle_1", true)
	elseif animslot == 4 then
		self.npc:add_animation("d_4_idle_1", true)
	end
end
function anims:update_hide()
	-- изменился ли анимслот
	local animslot = self:weapon_slot()

	if animslot ~= self.anim.lastanimslot then
		self.anim.begin = nil
		self.anim.lastanimslot = animslot
		self.npc:clear_animations()
		self:hide_idle(animslot)
	end

	-- Определяем нужно ли добавлять анимацию или ждать
	if (self.anim.begin == nil or
	   device():time_global() - self.anim.begin > self.anim.idle) and
	   self.npc:animation_count() <= 1
	then
		-- Определение промежутков времени между анимациями
		self.anim.begin = device():time_global()
		self.anim.idle = (math.random(self.anim.maxidle) + self.anim.sumidle) * 1000
		if math.random(100) < self.anim.rnd then
			local r
			if self.anim.lastanim == nil then
				r = math.random(table.getn(self.hide[animslot]))
			else
				r = math.random(table.getn(self.hide[animslot])-1)
				if r >= self.anim.lastanim then
					r = r + 1
				end
			end
			self.anim.lastanim = r
			self.npc:clear_animations()
			self.npc:add_animation (self.hide[animslot][r].name, self.hide[animslot][r].flag)
			-- Добавление зацикленного айдла для данного анимслота
			self:hide_idle(animslot)
		end
	end	
end                            
function anims:remove_hide()
	self.anim.base_state = nil
	self.anim.lastanim = nil
	self.anim.lastanimslot = nil 
	self.npc:clear_animations()
end




function anim_update(type, npc)
	local st = xr_motivator.storage[npc:id()].state.anim

	if st ~= nil then
		st:update(type)
	end
end
function anim_safe_to_break(npc)
	local st = xr_motivator.storage[npc:id()].state.anim

	if st ~= nil then
		return st:safe_to_break()
	end
	return true
end

