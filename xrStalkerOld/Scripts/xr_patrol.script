----------------------------------------------------------------------------------------------------------------------
--	Схема патруль. Мужики в патруле
--	автор: Тундук Владимир aka Sidorovich
--	TODO: 
----------------------------------------------------------------------------------------------------------------------
--patrol states
local patrol_move   =   0       -- просто движение
local patrol_hide   =   1       -- ракоход
local patrol_sprint =   2       -- очень быстро бежим
local patrol_run    =   3       -- просто несемся, аки лоси в кукурузу
local patrol_stop   =   4       -- стоим

local patrols = {}

local formations = {}
formations["line"] = {
                     { dir = vector ():set (-1, 0, 0), dist = 2 },
                     { dir = vector ():set (-1, 0, 0), dist = 4 },
                     { dir = vector ():set (-1, 0, 0), dist = 6 },
                     { dir = vector ():set (1, 0, 0), dist = 2 },
                     { dir = vector ():set (1, 0, 0), dist = 4 },
                     { dir = vector ():set (1, 0, 0), dist = 6 }
                     }
                     
formations["back"] = {
                     { dir = vector ():set (-1, 0, 0), dist = 2 },
                     { dir = vector ():set (-1, 0, 0), dist = 4 },
                     { dir = vector ():set (-1, 0, 0), dist = 6 },
                     { dir = vector ():set (1, 0, 0), dist = 2 },
                     { dir = vector ():set (1, 0, 0), dist = 4 },
                     { dir = vector ():set (1, 0, 0), dist = 6 }
                     }
formations["around"] = {
                     { dir = vector ():set (-1, 0, 0), dist = 2 },
                     { dir = vector ():set (-1, 0, 0), dist = 4 },
                     { dir = vector ():set (-1, 0, 0), dist = 6 },
                     { dir = vector ():set (1, 0, 0), dist = 2 },
                     { dir = vector ():set (1, 0, 0), dist = 4 },
                     { dir = vector ():set (1, 0, 0), dist = 6 }
                     }
                     

local key = nil
local data = nil

-----------------------
class "PatrolManager"
-----------------------
function PatrolManager:__init (path_name)
    self.path_name = path_name
    self.npc_list = {}
    self.current_state = patrol_stop
    self.commander_id = -1
    self.formation = "line"
    self.commander_lid = -1
    self.commander_dir = vector ():set (0, 0, 1)
    patrols[path_name] = self
end
-----------------------
function PatrolManager:add_npc (npc)
    --validate npc
    if npc == nil or npc:alive () == false or self.npc_list[npc:id ()] ~= nil then 
       return 
    end
    -- if this npc first in command then set him as commander
    self.npc_list[npc:id ()] = {soldier = npc, dir = vector ():set (1, 0, 0), dist = 0}
    if table.getn (self.npc_list) == 1 then
       self.commander_id = npc:id ()
    end    
    self:reset_positions ()
end
-----------------------
function PatrolManager:remove_npc (npc)
    if npc == nil then return end
    self.npc_list[npc:id ()] = nil
    if npc:id () == self.commander_id then
       self.commander_id = -1
       self:reset_positions ()
    end    
end
-----------------------
function PatrolManager:reset_positions ()
    local form_ = formations[self.formation]
    local index = 1
    for key, data in self.npc_list do
        if self.commander_id == -1 and index == 1 then
           self.commander_id = data.soldier:id ()
        end    
        self.npc_list[key].dir = form_[index].dir
        self.npc_list[key].dist = form_[index].dist
        index = index + 1
    end    
end
-----------------------
function PatrolManager:get_capacity ()
    local size = table.getn (npc_list)
    -- if size is not zero then return size
    if size ~= 0 then return size end
    -- else - remove patrol manager
    patrols[self.path_name] = nil
    return 0    
end
-----------------------
function PatrolManager:get_npc_command (npc)    -- get command for NPC
    --проверка непися на присутсвие в списке
    if self.npc_list[npc:id ()] == nil then
       abort ("NPC with name %s can't present in PatrolManager[%s]", npc:name (), self.path_name)
    end
    --проверка, чтобы командир не вздумал задавать глупых вопросов
    if npc:id () == self.commander_id then
       abort ("Patrol commander called function PatrolManager:get_npc_command in PatrolManager[%s]", self.path_name) 
    end       
    --получим данные командира
    local commander = self.npc_list[self.commander_id].soldier
    local dir = commander:direction ()
    local vertex_id = commander:level_vertex_id ()
    --уберем влияние вертикальной составляющей
    dir.y = 0
    -- получим данные салаги
    local dir_s = self.npc_list[npc:id ()].dir
    local dist_s = self.npc_list[npc:id ()].dist
    
    --расчет позиции для салаги
    --сначала получим направление
    dir_s = vector_rotate_y (dir_s, utils.angle_diff (dir, vector ():set (0, 0, 1)))
    --теперь аи ноду относительно командора ордена рыцарей храма
    local vertex = level.vertex_in_direction (level.vertex_in_direction (vertex_id, dir_s, dist_s), dir, 2)
    return vertex, dir, self.current_state
end
-----------------------
function PatrolManager:set_command (npc, command, formation)
    if npc == nil or npc:alive () == false then
       abort ("NPC commander possible dead in PatrolManager[%s]", self.path_name)
    end    
    if npc:id () ~= self.commander_id then
       abort ("NPC %s is not commander in PatrolManager[%s]", npc:name (), self.path_name) 
    end   
    self.current_state = command
    self.formation = formation
    self.commander_lid = npc:level_vertex_id ()
    self.commander_dir = npc:direction ()
end
-----------------------
function PatrolManager:is_commander (npc_id)
    return npc_id == self.commander_id    
end
-----------------------
function PatrolManager:update ()
    
end
-----------------------
-----------------------
-----------------------




---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
class "evaluator_patrol_end" (property_evaluator)
-----------------------
function evaluator_patrol_end:__init (name, storage) super (nil, name)
	self.st = storage
end
-----------------------
function evaluator_patrol_end:evaluate()
	return not xr_logic.is_active (self.object, self.st)
end
-----------------------


-----------------------
class "evaluator_patrol_comm" (property_evaluator)
-----------------------
function evaluator_patrol_comm:__init (name, storage) super (nil, name)
	self.st = storage
end
-----------------------
function evaluator_patrol_comm:evaluate()
    return patrols[self.st.path_name]:is_commander (self.object:id ())
end
----------------------------------------------------------------------------------------------------------------------



----------------------
class "action_commander" (action_base)
----------------------
function action_commander:__init (npc_name, action_name, storage) super(nil, action_name)
	self.st = storage
	self.move_mgr = move_mgr.move_mgr (storage.npc)
	self.was_reset = false
	self.cur_state = 0
end
----------------------
function action_commander:initialize()
	action_base.initialize (self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()
	self.move_mgr:initialize ()
	self:reset_scheme ()
end
----------------------
function action_commander:activate_scheme()
	self.was_reset = false
end
----------------------
function action_commander:reset_scheme()

	if not self.was_reset then
		self.st.signals = {}
		if self.st.path_walk_info == nil then
			self.st.path_walk_info = utils.path_parse_waypoints(self.st.path_walk)
		end
		if self.st.path_look_info == nil then
			self.st.path_look_info = utils.path_parse_waypoints(self.st.path_look)
		end
		self.move_mgr:reset(self.st.path_walk, self.st.path_walk_info, self.st.path_look, self.st.path_look_info,
			self.st.team, self.st.suggested_state, { obj = self, func = self.callback })
	else
		self.move_mgr:continue()
	end
	self.was_reset = true
end
----------------------
function action_commander:execute()
	action_base.execute(self)
	if not self.was_reset then
		self:reset_scheme()
	end
	self.move_mgr:update()
	if xr_logic.try_switch_to_another_section(self.object, self.st, db.actor) then
       return
    end
    if self.cur_state == patrol_move then
          state_mgr.set_state (self.object, "patrol")
    elseif self.cur_state == patrol_hide then
	      state_mgr.set_state (self.object, "sneak")
    elseif self.cur_state == patrol_sprint then
          state_mgr.set_state (self.object, "sprint")
    elseif self.cur_state == patrol_run then
	      state_mgr.set_state (self.object, "run")
    elseif self.cur_state == patrol_stop then
	      state_mgr.set_state (self.object, "idle")
    end   
    
end
----------------------
function action_commander:finalize ()
	self.move_mgr:finalize()
	action_base.finalize(self)
end
----------------------
function action_commander:death_callback()
	patrols[self.st.path_name]:remove_npc (self.object)
end
----------------------
function action_commander:callback (mode, number)
    if number < patrol_move or number > patrol_stop then
       return
    end
    self.cur_state = number
    patrols[self.st.path_walk]:set_command (self.object, self.cur_state, "line")
end



----------------------
class "action_patrol" (action_base)
----------------------
function action_patrol:__init (npc_name, action_name, storage) super (nil, action_name)
	self.st = storage
	self.l_vid = -1
	self.dist = 0
	self.dir = vector ():set (0, 0, 1)
	self.cur_state = patrol_move
	self.on_point = false
end
----------------------
function action_patrol:initialize()
	action_base.initialize              (self)
	self.object:set_node_evaluator      ()
	self.object:set_path_evaluator      ()
	self.object:set_desired_position    ()
	self.object:set_desired_direction   ()
    self.on_point = false
end
----------------------
function action_patrol:execute ()
	action_base.execute (self)

	if db.actor and xr_logic.try_switch_to_another_section (self.object, self.st, db.actor) then
       return
	end	
	
	self.l_vid, self.dir, self.cur_state = patrols[self.st.path_name]:get_npc_command (self.object)
	
    self.l_vid = utils.send_to_nearest_accessible_vertex (self.object, self.l_vid)	
	self.object:set_desired_direction (self.dir)
	self.object:set_path_type (game_object.level_path)
	
	--перемещаемся по пути
	if self.on_point == false then  -- если позиция не была еще достигнута, то подбежим к ней
	   self.on_point = level.vertex_position (self.l_vid):distance_to (level.vertex_position (self.object:level_vertex_id ())) < 2
	   if self.cur_state == patrol_run or self.cur_state == patrol_sprint then
	      state_mgr.set_state(self.object, "sprint")	-- если команда бежать, то бежим еще быстрее
	   else   
	      state_mgr.set_state(self.object, "run")       -- просто подбегаем
	   end   	
	else
	   if self.cur_state == patrol_move then
	      state_mgr.set_state (self.object, "patrol")
	   elseif self.cur_state == patrol_hide then
	      state_mgr.set_state (self.object, "sneak")
	   elseif self.cur_state == patrol_sprint then
	      state_mgr.set_state (self.object, "sprint")
	   elseif self.cur_state == patrol_run then
	      state_mgr.set_state (self.object, "run")
	   elseif self.cur_state == patrol_stop then
	      state_mgr.set_state (self.object, "idle")
	   end   
       self.on_point = level.vertex_position (self.l_vid):distance_to (level.vertex_position (self.object:level_vertex_id ())) < 5
	end       
	printf ("SOLDIER %s - TARGET STATE = %s", self.object:name (), state_mgr.get_state (self.object))
end
----------------------
function action_patrol:finalize ()
	action_base.finalize (self)
end
----------------------
function action_patrol:death_callback()
	patrols[self.st.path_name]:remove_npc (self.object)
end


----------------------------------------------------------------------------------------------------------------------
--Patrol binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder (object, ini, scheme, section, storage)
	local operators		= {}
	local properties	= {}

	local manager = object:motivation_action_manager ()

	properties["event"] 		= xr_evaluators_id.reaction
	properties["patrol_end"]	= xr_evaluators_id.sidor_patrol_base + 0
	properties["patrol_comm"]	= xr_evaluators_id.sidor_patrol_base + 1

	operators["action_patrol"]	    = xr_actions_id.sidor_act_patrol
	operators["action_commander"]	= xr_actions_id.sidor_act_patrol + 1

	-- Evaluators                                                                            
    manager:add_evaluator (properties["patrol_end"], this.evaluator_patrol_end ("patrol_end", storage, "patrol_end"))
    manager:add_evaluator (properties["patrol_comm"], this.evaluator_patrol_comm ("patrol_comm", storage, "patrol_comm"))

	-- Actions
	-- create action for patrol commander
	local action = this.action_commander (object:name(), "action_commander", storage)
	action:add_precondition		(world_property(stalker_ids.property_alive, true))
	action:add_precondition		(world_property(stalker_ids.property_danger,false))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
	xr_motivator.addCommonPrecondition (action)
	action:add_precondition		(world_property(properties["patrol_end"], 	false))
	action:add_precondition		(world_property(properties["patrol_comm"], 	true))
	action:add_effect 		    (world_property(properties["patrol_end"], 	true))
	manager:add_action          (operators["action_commander"], action)
	xr_logic.subscribe_action_for_events (object, storage, action)
	
	action = this.action_patrol (object:name(),"action_patrol", storage)
	action:add_precondition		(world_property(stalker_ids.property_alive,  true))
	action:add_precondition		(world_property(stalker_ids.property_danger, false))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	 false))
	xr_motivator.addCommonPrecondition(action)
	action:add_precondition		(world_property(properties["patrol_end"], 	false))
	action:add_precondition		(world_property(properties["patrol_comm"], 	false))
	action:add_effect 		    (world_property(properties["patrol_end"], 	true))
	manager:add_action          (operators["action_patrol"], action)
	xr_logic.subscribe_action_for_events (object, storage, action)

	action = manager:action     (xr_actions_id.alife)	
	action:add_precondition		(world_property(properties["patrol_end"],		true))

end

-- включение патруля
function set_scheme(npc, ini, scheme, section, gulag_name)
	local st = xr_logic.assign_storage_and_bind (npc, ini, scheme, section)

	st.logic = xr_logic.cfg_get_switch_conditions (ini, section, npc)		
    
	st.path_name = utils.cfg_get_string(ini, section, "path_walk", npc, true,  gulag_name)
	st.path_walk = st.path_name
	st.path_look = utils.cfg_get_string(ini, section, "path_look", npc, false, gulag_name)

	st.suggested_state = {}
	st.suggested_state.standing = utils.cfg_get_string(ini, section, "def_state_standing", npc, false, "")
	st.suggested_state.moving1  = utils.cfg_get_string(ini, section, "def_state_moving1", npc, false, "")
	st.suggested_state.moving2  = utils.cfg_get_string(ini, section, "def_state_moving2", npc, false, "")
	st.suggested_state.moving3  = utils.cfg_get_string(ini, section, "def_state_moving3", npc, false, "")

	st.path_walk_info = nil -- Будут инициализированы в reset(), сейчас пути могут быть еще
	st.path_look_info = nil -- не загружены.
	
    if patrols[st.path_name] == nil then
       patrols[st.path_name] = PatrolManager (st.path_name)
	end
	patrols[st.path_name]:add_npc (npc)
end
