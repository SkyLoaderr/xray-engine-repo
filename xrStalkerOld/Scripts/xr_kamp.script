----------------------------------------------------------------------------------------------------------------------
--	Схема лагерь. Чудак(и) у костра.
--	автор: Диденко Руслан (Stohe)
--	TODO: 
----------------------------------------------------------------------------------------------------------------------

local speeks = {} -- говорит ли кто либо в лагере, чтобы вместе не болтали
kamps = {}
---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
--' Условие завершения скрипта
class "evaluator_kamp_end" (property_evaluator)
function evaluator_kamp_end:__init(name, storage) super (nil, name)
	self.a = storage
end
function evaluator_kamp_end:evaluate()
	return not xr_logic.is_active(self.object, self.a)
end
--' Находимся ли мы на заданной позиции
class "evaluator_on_position" (property_evaluator)
function evaluator_on_position:__init(name, storage) super (nil, name)
	self.a = storage
	--' таблица векторов, содержащих направления на точки рассадки
	self.vectors = {{1,		0,		0},
					{1,		0, 		1},
					{0, 	0,		1},
					{-1, 	0,		1},
					{-1, 	0, 		0},
					{-1, 	0,		-1},
					{0, 	0,		-1},
					{1, 	0,		-1} }
end
function evaluator_on_position:evaluate()
	local tt
	
    --' если позиция еще не выбрана
	if self.a.pos_id == -1 then
		tt = false
	else
		if self.a.action == 1 then 
			tt = true
		else
	   		local pos = self.vectors[self.a.pos_id]
   			local dir = vector():set(pos[1], pos[2], pos[3])
   			local pp = level.vertex_in_direction(patrol(self.a.center_point):level_vertex_id(0), dir, self.a.max_rad)

	   		if pp == self.object:level_vertex_id() then
	   			tt = true
   			else
				tt = false
	   		end
		end
	end
	return tt
end
----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
--' Идет в заданную область
class "action_go_position" (action_base)
function action_go_position:__init (npc_name,action_name,storage) super (nil,action_name)
	self.a = storage
	--' таблица векторов, содержащих направления на точки рассадки
	self.vectors = {{1,		0,		0},
					{1,		0, 		1},
					{0, 	0,		1},
					{-1, 	0,		1},
					{-1, 	0, 		0},
					{-1, 	0,		-1},
					{0, 	0,		-1},
					{1, 	0,		-1} }
end
function action_go_position:initialize()
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()    

	self.begin = false	
end
function action_go_position:activate_scheme()
end
function action_go_position:execute ()
	action_base.execute (self)
	
	if self.begin == false then
		self.begin = true
		
		--' для начала надо составить список занятых позиций
		local used = {}
		local i = 1
		for key,value in db.storage do 
			if value.kamp ~= nil and value.kamp.center_point == self.a.center_point then
				used[i] = value.kamp.pos_id
				i = i + 1
			end
		end

		--' затем исключить их из списка доступных позиций
		local free = {}
		local i = 1
		for key,value in self.vectors do 
			local exist = false
			for k,v in used do
				if key == v then
					exist = true
				end
			end
			if exist == false then
				local pos = value
				local dir = vector():set(pos[1], pos[2], pos[3])
				local pp = level.vertex_in_direction(patrol(self.a.center_point):level_vertex_id(0), dir, self.a.max_rad)

				if pp ~= patrol(self.a.center_point):level_vertex_id(0) then
					free[i] = key
					i = i + 1
				end
			end
		end

		--' затем из доступных позиций выбрать рандомно одну.
		if table.getn(free) > 0 then
			local rr = math.random(table.getn(free))

			self.a.pos_id = free[rr]

			local pos = self.vectors[self.a.pos_id]
			local dir = vector():set(pos[1], pos[2], pos[3])
			local pp = level.vertex_in_direction(patrol(self.a.center_point):level_vertex_id(0), dir, self.a.max_rad)
			
			if self.object:accessible(pp) then
				self.object:set_dest_level_vertex_id(pp)
				self.object:set_path_type(game_object.level_path)
				state_mgr.set_state(self.object, "walk")	
			else
				abort("KAMP NODE IS NOT ACCESIBLE. npc=%s center_point=%s", self.object:name(), self.a.center_point)
			end
		else
			abort("There are no free kamp nodes. npc=%s center_point=%s", self.object:name(), self.a.center_point)
		end
	end
end
function action_go_position:finalize ()
	action_base.finalize (self)
end

--' Просто сидит и втыкает
class "action_wait" (action_base)
function action_wait:__init (npc_name,action_name,storage) super (nil,action_name)
	self.a = storage
	self.timer = { begin = nil,
		       idle = nil,
		       maxidle = 20,
		       sumidle = 10 }
end
function action_wait:initialize()
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()    	
end
function action_wait:execute()
	action_base.execute (self)
	if db.actor then
		if xr_logic.try_switch_to_another_section(self.object, self.a, db.actor) then
			return
		end
	end
	
	if self.a.action == 0 or self.a.action == nil then		
		local actions = {}
		local i = 1
		--' Тут выбор действий
		actions[i] = 5
		local rr = math.random(table.getn(actions))
		self.a.action = actions[rr]
		self.a.last_action = self.a.action
		self.timer.begin = time_global()/1000
		self.timer.idle = math.random(self.timer.maxidle) + self.timer.sumidle		
		--' повернуть его лицом к центру
		local pp = patrol(self.a.center_point):point(0)
		state_mgr.set_state(self.object, "sit", nil, nil, {look_position = pp})		
	end
	if self.a.action == 5 then
	
		--'!!! ПРОСТО СИДИМ И ВТЫКАЕМ	
		if (time_global()/1000 - self.timer.begin) < self.timer.idle then
			xr_sound.set_sound(self.object, "weather, state")
		else
			self.a.action = 0
		end
	end
end
function action_wait:finalize()
	action_base.finalize (self)
end


class "CKampManager"
function CKampManager:__init(patrol)
	self.patrol = patrol
	self.vectors = {{1,		0,		0},
					{1,		0, 		1},
					{0, 	0,		1},
					{-1, 	0,		1},
					{-1, 	0, 		0},
					{-1, 	0,		-1},
					{0, 	0,		-1},
					{1, 	0,		-1} }


end

----------------------------------------------------------------------------------------------------------------------
--Kamp binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(object, ini, scheme, section, storage)
	local operators		= {}
	local properties	= {}

	local manager = object:motivation_action_manager()

	properties["event"] 		= xr_evaluators_id.reaction
	properties["kamp_end"]		= xr_evaluators_id.stohe_kamp_base + 1
	properties["on_position"]	= xr_evaluators_id.stohe_kamp_base + 2
	properties["contact"]		= xr_evaluators_id.stohe_meet_base + 1    
	properties["danger"]		= xr_evaluators_id.danger

	operators["go_position"]	= xr_actions_id.stohe_kamp_base + 1
	operators["go_patrol"]		= xr_actions_id.stohe_kamp_base + 2
	operators["wait"]		= xr_actions_id.stohe_kamp_base + 3

	-- Evaluators                                                                            
	manager:add_evaluator (properties["kamp_end"], 		this.evaluator_kamp_end		("kamp_end", db.storage[object:id()].kamp, "kamp_end"))
	manager:add_evaluator (properties["on_position"],	this.evaluator_on_position	("kamp_on_position", db.storage[object:id()].kamp, "kamp_on_position"))

	-- Actions
	local action = this.action_wait (object:name(),"action_kamp_wait", db.storage[object:id()].kamp)
	action:add_precondition		(world_property(stalker_ids.property_alive, true))
	action:add_precondition		(world_property(properties["danger"],		true))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
	xr_motivator.addCommonPrecondition(action)
	action:add_precondition		(world_property(properties["on_position"], 	true))
	action:add_effect 		(world_property(properties["kamp_end"], 	true))
	action:add_effect		(world_property(stalker_ids.property_danger,false))
	manager:add_action (operators["wait"], action)
	
	action = this.action_go_position (object:name(),"action_go_kamp", db.storage[object:id()].kamp)
	action:add_precondition		(world_property(stalker_ids.property_alive, true))
	action:add_precondition		(world_property(properties["danger"],		true))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
	xr_motivator.addCommonPrecondition(action)
	action:add_precondition 	(world_property(properties["on_position"], 	false))
	action:add_effect 		(world_property(properties["on_position"], 	true))
	action:add_effect		(world_property(stalker_ids.property_danger,false))
	manager:add_action (operators["go_position"], action)
	xr_logic.subscribe_action_for_events(object, storage, action)

	action = manager:action (xr_actions_id.alife)	
	action:add_precondition		(world_property(properties["kamp_end"],		true))

end
-- включение лагеря
function set_scheme(npc, ini, scheme, section, gulag_name)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)

	st.logic     = xr_logic.cfg_get_switch_conditions(ini, section, npc)		
    
	st.max_rad = 2
	st.action = 0
    st.last_action = 0
    st.pos_id = -1
    st.timer = { act1 = {begin = nil, time = 120},
				act4 = {begin = nil, time = 60}}

	st.center_point = utils.cfg_get_string(ini, section, "center_point", npc, true,  gulag_name)
	if kamps[st.center_point] == nil then
		kamps[st.center_point] = CKampManager(st.center_point)
	end
end