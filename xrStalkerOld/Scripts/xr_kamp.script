----------------------------------------------------------------------------------------------------------------------
--	Схема лагерь. Чудак(и) у костра.
--	автор: Диденко Руслан (Stohe)
--	TODO: 
----------------------------------------------------------------------------------------------------------------------

kamps = {}
---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
--' Условие завершения скрипта
class "evaluator_kamp_end" (property_evaluator)
function evaluator_kamp_end:__init(name, storage) super (nil, name)
	self.a = storage
end
function evaluator_kamp_end:evaluate()
	return not xr_logic.is_active(self.object, self.a)
end
--' Находимся ли мы на заданной позиции
class "evaluator_on_position" (property_evaluator)
function evaluator_on_position:__init(name, storage) super (nil, name)
	self.a = storage
end
function evaluator_on_position:evaluate()
    if self.object:level_vertex_id() == self.a.pos_vertex then
		return true
	end
	return false
end
----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
--' Идет в заданную область
class "action_go_position" (action_base)
function action_go_position:__init (npc_name,action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_go_position:initialize()
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()
	
	self.a.pos_vertex = kamps[self.a.center_point]:getDestVertex(self.object:id())
end
function action_go_position:execute ()
	action_base.execute (self)

	if self.a.pos_vertex == nil then
		self.a.pos_vertex = kamps[self.a.center_point]:getDestVertex(self.object:id())
	end
		
	if not self.object:accessible(self.a.pos_vertex) then
		printf("[%s] KAMP NODE NOT ACCESSIBLE. Get accessible nearest", self.object:name())
		local ttp = vector():set(0,0,0)
		self.a.pos_vertex = self.object:accessible_nearest(level.vertex_position(self.a.pos_vertex), ttp)
	end
	
	self.a.pp = patrol(self.a.center_point):level_vertex_id(0)
	self.a.pp = level.vertex_in_direction(self.a.pp, vector():set(math.random(-1,1), 0, math.random(-1,1)), math.random(0,0.5))
	self.object:set_dest_level_vertex_id(self.a.pos_vertex)
	self.object:set_desired_direction(vector():sub(level.vertex_position(self.a.pp),level.vertex_position(self.a.pos_vertex)))
	self.object:set_path_type(game_object.level_path)
	state_mgr.set_state(self.object, "walk")	
end
function action_go_position:finalize ()
	action_base.finalize (self)
end

--' Просто сидит и втыкает
class "action_wait" (action_base)
function action_wait:__init (npc_name,action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_wait:initialize()
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()
	
	xr_sound.set_sound_play(self.object, "talk_hello")
end
function action_wait:activate_scheme()
end
function action_wait:execute()
	action_base.execute (self)
	if db.actor then
		if xr_logic.try_switch_to_another_section(self.object, self.a, db.actor) then
			return
		end
	end
	local state, sound, substate = kamps[self.a.center_point]:updateNpc(self.object)
	
	--' повернуть его лицом к центру	
	state_mgr.set_state(self.object, state, nil, nil, {look_position = level.vertex_position(self.a.pp)}, nil, nil, {subanim = substate})
	xr_sound.set_sound(self.object, sound)
end
function action_wait:finalize()
	action_base.finalize (self)
end
function action_wait:deactivate()
	printf("KAMP DEACTIVATE CALLED")
	kamps[self.a.center_point]:removeNpc(self.object)
end
function action_wait:death_callback()
	printf("KAMP DEACTIVATE CALLED")
	kamps[self.a.center_point]:removeNpc(self.object)
end


class "CKampManager"
function CKampManager:__init(path)
	self.patrol = patrol(path)
	self.center = self.patrol:level_vertex_id(0)
	self.position = {{dir = vector():set(1, 0, 0),	used = nil},
					 {dir = vector():set(1, 0, 1),	used = nil},
					 {dir = vector():set(0, 0, 1),	used = nil},
					 {dir = vector():set(-1, 0, 1),	used = nil},
					 {dir = vector():set(-1, 0, 0),	used = nil},
					 {dir = vector():set(-1, 0, -1),used = nil},
					 {dir = vector():set(0, 0, -1),	used = nil},
					 {dir = vector():set(1, 0, -1),	used = nil}}
	self.npc = {}
	self.kamp_state = "idle"
	
	-- Где то здесь распарсим патрульный путь и проапдейтим вектор позиций.
	-- 0 вершина - центр лагеря.
	-- 1 флаг - сектор занят, в поинте можно сидеть.
	-- 2 флаг - сектор занят, в поинте нельзя сидеть.
	for k = 1, self.patrol:count() - 1 do
		-- если есть 1 или 2 флажок - отметить сектор как занятый
		if self.patrol:flag(k,1) or
		   self.patrol:flag(k,2)
		then
			-- отметить сектор как занятый
			for key,value in self.position do
				dir = vector():sub(level.vertex_position(self.patrol:level_vertex_id(k)), level.vertex_position(self.center))
				if value.dir then
					yaw = yaw_degree(dir, value.dir)
					if yaw <=23 then
						printf("KAMP node[%s], sector[%s,] yaw[%s]", k, key, yaw_degree(dir, value.dir))
						value.used = -1
						break						
					end
				end
			end
			
		end
		
		-- если есть 1 флажок - создать место для сидения в точке пути
		if self.patrol:flag(k,1) then
			-- создать точку для сидения
			table.insert(self.position, {vertex = self.patrol:level_vertex_id(k)})
		end		
	end
	--print_table(self.position)
end
function CKampManager:selectPosition(npc_id)
	-- создаем список доступных позиций
	printf("KAMP. [%s] called select position", npc_id)
	local free = {}
	for k,v in self.position do
		if v.used == nil then
			table.insert(free, k)
		end
	end
	--' затем из доступных позиций выбрать рандомно одну.
	if table.getn(free) > 0 then
		printf("KAMP [%s] free node > 0", npc_id)
		local rr = math.random(table.getn(free))
		self.position[free[rr]].used = npc_id
		self.npc[npc_id].position = free[rr]
	end
	printf("KAMP [%s] npc table", npc_id)
	print_table(self.npc)
	printf("KAMP [%s] position table", npc_id)
	print_table(self.position)
end
function CKampManager:getDestVertex(npc_id)
	--printf("get dest Vertex called [%s]", npc_id)
	if self.npc[npc_id].position == nil then
		abort("get dest Vertex: nil [%s]", npc_id)
		return nil
	end
	
	local position = self.position[self.npc[npc_id].position]
	
	if position.vertex ~= nil then
		--printf("vertex preselected [%s]", npc_id)
		return position.vertex
	end

	-- высчитываем вертех по направлению
   	local pp = level.vertex_in_direction(self.center, self.position[self.npc[npc_id].position].dir, 2)
   	pp = level.vertex_in_direction(pp, vector():set(math.random(-1,1), 0, math.random(-1,1)), math.random(0,0.5))
	--printf("vertex selected [%s]", npc_id)   	
	return pp		
end
function CKampManager:proceedRole(v)
	-- тема требует, чтобы не было звуков, необходимо ждать конца звука
	if v.current and v.current.nosound and v.speak > 0 then
		return
	end

	-- возврать лагеря в состояние "idle"
	if v.current and 
	   (v.current.name == "harmonica_post" or
	    v.current.name == "guitar_post" or
	    v.current.name == "joke_post")
	then
		self.kamp_state = "idle"
	end

	-- Возврат лагеря в состояние "idle" в случае истории
	if v.current and 
	   v.current.name == "story_post"
	then
		-- Здесь нужно все вернуть на story_play
		if self.story_last < self.story_max -1 then
			self.kamp_state = "story"
			for q,w in v.roles do
				if w.name == v.current.ifnotend then
					v.current = w
					v.begin = time_global()
					v.idle = math.random(w.min,w.max)*1000
					v.new = true
					return			
				end
			end
			return
		else
			self.kamp_state = "idle"
		end
	end
	
	-- Если у роли есть next, то выбираем ее.
	if v.current and v.current.next then
		for q,w in v.roles do
			if w.name == v.current.next then
				v.current = w
				v.begin = time_global()
				v.idle = math.random(w.min,w.max)*1000
				v.new = true
				return			
			end
		end
	end

	-- составляем список допустимых состояний, и выбираем из них рандомно одно	
	local allowed = {}
	for q,w in v.roles do
		if w.allowed then
			for qq,ww in w.allowed do
				if self.kamp_state == ww then
					table.insert(allowed, w)
					break
				end
			end
		end
	end
	
	local num_roles = table.getn(allowed)
	if num_roles == 0 then
		return
	end
	
	local role = math.random(1,num_roles)
	v.current = allowed[role]
	v.begin = time_global()
	v.idle = math.random(v.current.min,v.current.max)*1000
	v.new = true
	return







			
			
end
function CKampManager:updateNpc(npc)
	-- каждый НПС оценивает, какую роль он может выполнять и оповещает об этом менеджер лагеря.
	-- затем запрашивает текущее свое действие у лагеря.
	-- Состояния лагеря:
	-- idle, 
	-- pre_harmonica, harmonica, post_harmonica
	-- pre_guitar, guitar, post_guitar
	-- pre_joke, joke, post_joke
	-- pre_story, story, post_story
	-- Роли:
	npc_id = npc:id()
	self.npc[npc_id].roles = {}
	-- сидеть бездельничать
	table.insert(self.npc[npc_id].roles, {name = "stand_wait",	min=30, max=70, allowed = {"idle","pre_harmonica","harmonica","post_harmonica","pre_guitar","guitar","post_guitar","pre_joke","joke","post_joke","pre_story","story","post_story"}})
	table.insert(self.npc[npc_id].roles, {name = "sit",			min=60, max=120, allowed = {"idle","pre_harmonica","harmonica","post_harmonica","pre_guitar","guitar","post_guitar","pre_joke","joke","post_joke","pre_story","story","post_story"}})
	table.insert(self.npc[npc_id].roles, {name = "sit_ass",		min=60, max=120, allowed = {"idle","pre_harmonica","harmonica","post_harmonica","pre_guitar","guitar","post_guitar","pre_joke","joke","post_joke","pre_story","story","post_story"}})
	table.insert(self.npc[npc_id].roles, {name = "sit_knee",	min=60, max=120, allowed = {"idle","pre_harmonica","harmonica","post_harmonica","pre_guitar","guitar","post_guitar","pre_joke","joke","post_joke","pre_story","story","post_story"}})
	-- есть колбасу
	if npc:object("kolbasa_a") then
		table.insert(self.npc[npc_id].roles, {name = "eat_kolbasa",		min=20, max=40, allowed = {"idle","pre_harmonica","harmonica","post_harmonica","pre_guitar","guitar","post_guitar","pre_joke","joke","post_joke","pre_story","story","post_story"}})
	end
	-- пить водку
	if npc:object("vodka_a") then
		table.insert(self.npc[npc_id].roles, {name = "eat_vodka",		min=20, max=40, allowed = {"idle","pre_harmonica","harmonica","post_harmonica","pre_guitar","guitar","post_guitar","pre_joke","joke","post_joke","pre_story","story","post_story"}})
	end
	-- есть хлеб
	if npc:object("bread_a") then
		table.insert(self.npc[npc_id].roles, {name = "eat_bread",		min=20, max=40, allowed = {"idle","pre_harmonica","harmonica","post_harmonica","pre_guitar","guitar","post_guitar","pre_joke","joke","post_joke","pre_story","story","post_story"}})
	end
	-- играть на гармошке
	if npc:object("harmonica_a") then
		table.insert(self.npc[npc_id].roles, {name = "harmonica_wait",	min=10, max=20, allowed = {"idle"}, next = "harmonica_play"})
		table.insert(self.npc[npc_id].roles, {name = "harmonica_play",	min=10, max=20, nosound = true, next = "harmonica_post"})
		table.insert(self.npc[npc_id].roles, {name = "harmonica_post",	min=5, max=6})
	end
	-- играть на гитаре
	if npc:object("guitar_a") then
		table.insert(self.npc[npc_id].roles, {name = "guitar_wait",	min=10, max=20, allowed = {"idle"}, next = "guitar_play"})
		table.insert(self.npc[npc_id].roles, {name = "guitar_play",	min=10, max=20, nosound = true, next = "guitar_post"})
		table.insert(self.npc[npc_id].roles, {name = "guitar_post",	min=5, max=6})
	end	
	-- рассказать анекдот
	table.insert(self.npc[npc_id].roles, {name = "joke_wait",	min=5, max=6, allowed = {"idle"}, next = "joke_play"})
	table.insert(self.npc[npc_id].roles, {name = "joke_play",	min=10, max=11, nosound = true, next = "joke_post"})
	table.insert(self.npc[npc_id].roles, {name = "joke_post",	min=5, max=6})

	-- рассказать историю
	local t = math.mod(npc_id, 6)
	if t == 0 then
		table.insert(self.npc[npc_id].roles, {name = "story_wait",	min=2, max=3, allowed = {"idle"}, next = "story_play", story="story_01"})
		table.insert(self.npc[npc_id].roles, {name = "story_play",	min=5, max=6, nosound = true, next = "story_post"})
		table.insert(self.npc[npc_id].roles, {name = "story_post",	min=1, max=1, reac = "story_01", ifnotend = "story_play"})
	elseif t == 1 then
		table.insert(self.npc[npc_id].roles, {name = "story_wait",	min=2, max=3, allowed = {"idle"}, next = "story_play", story="story_02"})
		table.insert(self.npc[npc_id].roles, {name = "story_play",	min=5, max=6, nosound = true, next = "story_post"})
		table.insert(self.npc[npc_id].roles, {name = "story_post",	min=1, max=1, reac = "story_02", ifnotend = "story_play"})
	elseif t == 2 then
		table.insert(self.npc[npc_id].roles, {name = "story_wait",	min=2, max=3, allowed = {"idle"}, next = "story_play", story="story_03"})
		table.insert(self.npc[npc_id].roles, {name = "story_play",	min=5, max=6, nosound = true, next = "story_post"})
		table.insert(self.npc[npc_id].roles, {name = "story_post",	min=1, max=1, reac = "story_03", ifnotend = "story_play"})
	elseif t == 3 then
		table.insert(self.npc[npc_id].roles, {name = "story_wait",	min=2, max=3, allowed = {"idle"}, next = "story_play", story="story_04"})
		table.insert(self.npc[npc_id].roles, {name = "story_play",	min=5, max=6, nosound = true, next = "story_post"})
		table.insert(self.npc[npc_id].roles, {name = "story_post",	min=1, max=1, reac = "story_04", ifnotend = "story_play"})
	elseif t == 4 then
		table.insert(self.npc[npc_id].roles, {name = "story_wait",	min=2, max=3, allowed = {"idle"}, next = "story_play", story="story_05"})
		table.insert(self.npc[npc_id].roles, {name = "story_play",	min=5, max=6, nosound = true, next = "story_post"})
		table.insert(self.npc[npc_id].roles, {name = "story_post",	min=1, max=1, reac = "story_05", ifnotend = "story_play"})
	elseif t == 5 then
		table.insert(self.npc[npc_id].roles, {name = "story_wait",	min=2, max=3, allowed = {"idle"}, next = "story_play", story="story_06"})
		table.insert(self.npc[npc_id].roles, {name = "story_play",	min=5, max=6, nosound = true, next = "story_post"})
		table.insert(self.npc[npc_id].roles, {name = "story_post",	min=1, max=1, reac = "story_06", ifnotend = "story_play"})
	end

	-- запоминаем проигрываемые персонажем звуки.
	self.npc[npc_id].speak = npc:active_sound_count()
	
	-- производим выбор работ.
	local v = self.npc[npc_id]
	if v.begin == nil or
	   time_global() - v.begin >= v.idle then
		self:proceedRole(v)
	end



	--И какую же роль нам доверили:	
	local role = self.npc[npc_id].current.name
	-- В зависимости от состояния лагеря и выбранной роли выбираем саунд тему.
	local sound = ""
	if self.kamp_state == "idle" then
		sound = "weather, state"
	elseif self.kamp_state == "post_harmonica" then
		if role ~= "harmonica_post" then
			sound = "reac_music"
		end
	elseif self.kamp_state == "post_guitar" then
		if role ~= "guitar_post" then
			sound = "reac_music"
		end
	elseif self.kamp_state == "joke" then
		if role == "joke_play" then
			sound = "joke"
		end
	elseif self.kamp_state == "post_joke" then
		if role ~= "joke_post" then
			sound = "reac_joke, story_reac_laughter"
		end
	elseif self.kamp_state == "post_story" then
		if role ~= "story_post" then
			local dep = sound_theme.theme[npc:id()][self.active_story].depence[self.story_last]
			if dep then
				if dep.type == "all" then
					if self.npc[npc_id].need_reac == true then
						xr_sound.set_sound_play(npc, dep.theme)
						self.npc[npc_id].need_reac = false
					end
				else
					sound = dep.theme
				end
			end
		end
	end
	
	--printf("[%s] role [%s]", npc:name(), tostring(role))
	if role == "stand_wait" then
		return "wait", sound
	end
	if role == "sit" then
		return "sit", sound
	end
	if role == "sit_ass" then
		return "sit_ass", sound
	end
	if role == "sit_knee" then
		return "sit_knee", sound
	end
	if role == "eat_bread" then
		return "eat_bread", sound
	end
	if role == "eat_vodka" then
		return "eat_vodka", sound
	end
	if role == "eat_kolbasa" then
		return "eat_kolbasa", sound
	end
	if role == "harmonica_wait" then
		self.kamp_state = "pre_harmonica"
		if self.npc[npc_id].new == true then
			xr_sound.set_sound_play(npc, "intro_harmonica", math.random(2000,3000))
			self.npc[npc_id].new = false
		end
		return "harmonica", ""
	end
	if role == "harmonica_play" then
		-- тут звук будет прописан в самой анимации
		self.kamp_state = "harmonica"
		return "harmonica", "", 1
	end
	if role == "harmonica_post" then
		self.kamp_state = "post_harmonica"
		return "harmonica", ""
	end
	if role == "guitar_wait" then
		self.kamp_state = "pre_guitar"
		if self.npc[npc_id].new == true then
			xr_sound.set_sound_play(npc, "intro_guitar", math.random(2000,3000))
			self.npc[npc_id].new = false
		end
		return "guitar", ""
	end
	if role == "guitar_play" then
		-- тут звук будет прописан в самой анимации
		self.kamp_state = "guitar"
		return "guitar", "", 1
	end
	if role == "guitar_post" then
		self.kamp_state = "post_guitar"
		return "guitar", ""
	end
	if role == "joke_wait" then
		self.kamp_state = "pre_joke"
		if self.npc[npc_id].new == true then
			xr_sound.set_sound_play(npc, "intro_joke", math.random(2000,3000))
			self.npc[npc_id].new = false
		end
		return self:getState(npc_id), ""
	end
	if role == "joke_play" then
		self.kamp_state = "joke"
		if self.npc[npc_id].new == true then
			xr_sound.set_sound_play(npc, "joke", math.random(2000,3000))
			self.npc[npc_id].new = false
		end
		return self:getState(npc_id), ""
	end
	if role == "joke_post" then
		self.kamp_state = "post_joke"
		return self:getState(npc_id), ""
	end
	-- Сказки	
	if role == "story_wait" then
		self.kamp_state = "pre_story"
		if self.npc[npc_id].new == true then
			self.active_story = self.npc[npc_id].current.story
			xr_sound.set_sound_play(npc, self.active_story)
			self.npc[npc_id].new = false			
		end
		return self:getState(npc_id), ""
	end
	if role == "story_play" then
		self.kamp_state = "story"
		if self.npc[npc_id].new == true then
			xr_sound.set_sound_play(npc, self.active_story)
			self.npc[npc_id].new = false
			self.story_last, self.story_max = xr_sound.get_last_IDS(npc, self.active_story)
		end
		return self:getState(npc_id), ""
	end
	if role == "story_post" then
		self.kamp_state = "post_story"
		if self.npc[npc_id].new == true then
			self.npc[npc_id].new = false
			for k,v in self.npc do
				v.need_reac = true
			end
			local dep = sound_theme.theme[npc:id()][self.active_story].depence[self.story_last]
			if dep and dep.min and dep.max then
				self.npc[npc_id].idle = math.random(dep.min, dep.max)*1000
			end
		end
		return self:getState(npc_id), sound
	end
	
	abort("KAMP No role selected")
end
function CKampManager:getState(npc_id)
	local t = math.mod(npc_id, 3)
	if t == 0 then
		return "sit"
	elseif t == 1 then
		return "sit_ass"
	else
		return "sit_knee"
	end
end
function CKampManager:addNpc(npc)
	printf("KAMP [%s] add npc", npc:name())
	if self.npc[npc:id()] ~= nil then
		printf("NPC is already exist")
		return
	end
	self.npc[npc:id()] = {name = npc:name(), position = nil, roles = {}, current = nil, speak = 0}
	self:selectPosition(npc:id())
end
function CKampManager:removeNpc(npc)
	printf("KAMP [%s] remove npc", npc:name())
	self.position[self.npc[npc:id()].position].used = nil
	self.npc[npc:id()] = nil
end

----------------------------------------------------------------------------------------------------------------------
--Kamp binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(object, ini, scheme, section, storage)
	local operators		= {}
	local properties	= {}

	local manager = object:motivation_action_manager()

	properties["event"] 		= xr_evaluators_id.reaction
	properties["kamp_end"]		= xr_evaluators_id.stohe_kamp_base + 1
	properties["on_position"]	= xr_evaluators_id.stohe_kamp_base + 2
	properties["contact"]		= xr_evaluators_id.stohe_meet_base + 1    
	properties["danger"]		= xr_evaluators_id.danger

	operators["go_position"]	= xr_actions_id.stohe_kamp_base + 1
	operators["go_patrol"]		= xr_actions_id.stohe_kamp_base + 2
	operators["wait"]		= xr_actions_id.stohe_kamp_base + 3

	-- Evaluators                                                                            
	manager:add_evaluator (properties["kamp_end"], 		this.evaluator_kamp_end		("kamp_end", storage, "kamp_end"))
	manager:add_evaluator (properties["on_position"],	this.evaluator_on_position	("kamp_on_position", storage, "kamp_on_position"))

	-- Actions
	local action = this.action_wait (object:name(),"action_kamp_wait", storage)
	action:add_precondition		(world_property(stalker_ids.property_alive, true))
	action:add_precondition		(world_property(properties["danger"],		true))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
	xr_motivator.addCommonPrecondition(action)
	action:add_precondition		(world_property(properties["on_position"], 	true))
	action:add_effect 		(world_property(properties["kamp_end"], 	true))
	action:add_effect		(world_property(stalker_ids.property_danger,false))
	manager:add_action (operators["wait"], action)
	xr_logic.subscribe_action_for_events(object, storage, action)
	
	action = this.action_go_position (object:name(),"action_go_kamp", storage)
	action:add_precondition		(world_property(stalker_ids.property_alive, true))
	action:add_precondition		(world_property(properties["danger"],		true))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
	xr_motivator.addCommonPrecondition(action)
	action:add_precondition 	(world_property(properties["on_position"], 	false))
	action:add_effect 		(world_property(properties["on_position"], 	true))
	action:add_effect		(world_property(stalker_ids.property_danger,false))
	manager:add_action (operators["go_position"], action)

	action = manager:action (xr_actions_id.alife)	
	action:add_precondition		(world_property(properties["kamp_end"],		true))

end
-- включение лагеря
function set_scheme(npc, ini, scheme, section, gulag_name)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)

	st.logic     = xr_logic.cfg_get_switch_conditions(ini, section, npc)		
    
	st.center_point = utils.cfg_get_string(ini, section, "center_point", npc, true,  gulag_name)
	if kamps[st.center_point] == nil then
		kamps[st.center_point] = CKampManager(st.center_point)
	end
	kamps[st.center_point]:addNpc(npc)
	st.pos_vertex = nil
end