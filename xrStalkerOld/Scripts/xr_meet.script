----------------------------------------------------------------------------------------------------------------------
--	Схема встречи двух сталкеров
--	автор: Диденко Руслан (Stohe)
--	TODO:
----------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
--' Возвращает есть ли у нас контакт с другим сталкером
class "evaluator_contact" (property_evaluator)
function evaluator_contact:__init(name, storage) super (nil, name)
	self.a = storage
end
function evaluator_contact:evaluate()
	if self.a.meet_set ~= true then return false end
	
	if db.actor and self.object:see(db.actor) then
		if xr_wounded.is_wounded(self.object) then
			return false
		end
		self.a.meet_manager:update()
		if self.mgr == nil then
			self.mgr = self.object:motivation_action_manager()
		end
		if self.mgr:evaluator(stalker_ids.property_enemy):evaluate() then
			return false
		end
		return self.a.meet_manager.state ~= "nil"
	else
		return false
	end
end

----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
--' Приглашение к тороговле
class "action_meet_wait" (action_base)
function action_meet_wait:__init (npc_name,action_name, storage, char_ini) super (nil, action_name)
	self.char_ini = char_ini
	self.a = storage
end
function action_meet_wait:initialize()
	action_base.initialize(self)
	self.object:set_node_evaluator()
	self.object:set_path_evaluator()
	self.object:set_desired_position()
	self.object:set_desired_direction()
	-- кешируемые данные
	self.sound = "nil"
end
function action_meet_wait:execute ()
	action_base.execute(self)
	meet_manager = self.a.meet_manager
	
	local victim = nil	
	if meet_manager.victim == "actor" then
		victim = db.actor
	elseif meet_manager.victim == "nil" then
		victim = nil
	else
		local sim = alife()
		if sim then
			victim = sim:story_object(victim)
		end
	end
	
	local synsound = nil
	if meet_manager.state == "true" then
		local h = hit()
		h.power = 0
		h.direction = self.object:direction()
		h.bone = "bip01_spine"
		h.draftsman = db.actor
		h.impulse = 0
		h.type = hit.wound
		self.object:hit(h)		
	else
		-- является ли текущий звук синхронным для текущего стейта
		for k,v in self.a.syndata do
			if v.state == meet_manager.state and
			   v.sound == meet_manager.sound
			then
				synsound = meet_manager.sound
			end
		end
		
		if meet_manager.emerg_state == true then
			state_mgr.set_state(self.object, meet_manager.state, nil, nil, {look_object = victim}, {animation = true}, synsound)
		else
			state_mgr.set_state(self.object, meet_manager.state, nil, nil, {look_object = victim}, nil, synsound)
		end
	end

	if synsound == nil then
		-- нужно отыграть фоновый
		if self.sound ~= meet_manager.sound then
			self.sound = meet_manager.sound
			xr_sound.set_sound(self.object, meet_manager.sound)
		end
	else
		-- нужно зарубить фоновый
		if self.sound ~= nil then
			self.sound = "nil"
			xr_sound.set_sound(self.object, nil)
		end
	end

	local tt = db.storage[self.object:id()]
	if tt.active_scheme and not self.object:is_talking() then
		if db.actor then
			if xr_logic.try_switch_to_another_section(self.object, tt[tt.active_scheme], db.actor) then
				return
			end
		end
	end
end
function action_meet_wait:finalize ()
	action_base.finalize(self)
	xr_sound.set_sound(self.object, nil)
end

class "Cmeet_manager"
function Cmeet_manager:__init(npc, storage)
	self.npc = npc
	self.a = storage
	self.emerg_state = false
	self.startdialog = nil
end
function Cmeet_manager:update()
	-- стартовый диалог
	if self.a.meet_dialog ~= nil then			
		local tmp = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.meet_dialog)
		if self.startdialog ~= tmp then
			self.startdialog = tmp
			printf("*DIALOGS %s* SET [%s]", self.npc:name(), utils.to_str(tmp))
			if tmp == nil or tmp == "nil" then
				-- восстановление начального
				self.npc:restore_default_start_dialog()
			else
				-- установка нового
				self.npc:set_start_dialog(tmp)				
			end
		end
	end
		
	self.dist = self.npc:position():distance_to(db.actor:position())
	self:process_use()
	self.victim = self:process_victim()

	self.state_zone,self.sound_zone = self:process_zone()
	if self.state_zone ~= "nil" then
		if self.victim == "nil" then
			self.victim = "actor"
		end
		self.state,self.sound = self.state_zone,self.sound_zone
	else
		self.state,self.sound = self:process_meet()
	end
	
end
function Cmeet_manager:process_zone()
	if self.a.zone == nil then return "nil","nil" end
	key = self:get_key_from_zone(self.a.zone)
	if key ~= nil then
		if self.a.zone[key].state then
			r1 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.zone[key].state)
			self.emerg_state = true
		end
		if self.a.zone[key].sound then
			r2 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.zone[key].sound)
		end
		return tostring(r1), tostring(r2)
	end
	return "nil","nil"
end
function Cmeet_manager:process_meet()
	if isWeapon(db.actor:active_item())	then
		key = self:get_key_from_distance(self.a.meet_state_wpn)
		if key ~= nil then
			if self.a.meet_state_wpn[key].state then
				r1 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.meet_state_wpn[key].state)
				self.emerg_state = true
			end
			if self.a.meet_state_wpn[key].sound then
				r2 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.meet_state_wpn[key].sound)
			end
			return tostring(r1), tostring(r2)
		end	
	else
		key = self:get_key_from_distance(self.a.meet_state)
		if key ~= nil then
			if self.a.meet_state[key].state then
				r1 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.meet_state[key].state)
				self.emerg_state = false
			end
			if self.a.meet_state[key].sound then
				r2 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.meet_state[key].sound)
			end
			return tostring(r1), tostring(r2)
		end	
	end
	return "nil","nil"
end
function Cmeet_manager:process_victim()
	if isWeapon(db.actor:active_item())	then
		key = self:get_key_from_distance(self.a.victim_wpn)
		if key ~= nil then
			return tostring(xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.victim_wpn[key].state))
		end	
	else
		key = self:get_key_from_distance(self.a.victim)
		if key ~= nil then
			return tostring(xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.victim[key].state))
		end	
	end
	return "nil"
end
function Cmeet_manager:get_key_from_distance(t)
	local key
	for k,v in t do
		if v.dist >= self.dist then 
			key = k 
		else
			return key
		end		
	end
	return key
end
function Cmeet_manager:get_key_from_zone(t)
	for k,v in t do
		if utils.npc_in_zone(db.actor, db.zone_by_name[v.zone]) then 
			return k 
		end		
	end
	return nil
end
function Cmeet_manager:process_use()
	local t
	if isWeapon(db.actor:active_item())	then
		t = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.use_wpn)
	else
		t = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.use)
	end	
	if t == "true" then
		self.npc:enable_talk()
	elseif t == "false" then
		self.npc:disable_talk()
		if self.npc:is_talking() then
			self.npc:stop_talk()
		end
	elseif t == "self" then
		if not self.npc:is_talking() then
			db.actor:run_talk_dialog(self.npc)
		end
	end
end

----------------------------------------------------------------------------------------------------------------------
-- binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(object, char_ini)
	local operators		= {}
	local properties	= {}

	local manager = object:motivation_action_manager()

	properties["event"] 		= xr_evaluators_id.reaction
	properties["contact"]		= xr_evaluators_id.stohe_meet_base + 1         
	properties["wounded"]		= xr_evaluators_id.sidor_wounded_base + 0
	properties["danger"]		= xr_evaluators_id.danger
	
	operators["contact"]		= xr_actions_id.stohe_meet_base + 1

	-- Evaluators
	manager:add_evaluator (properties["contact"], 		evaluator_contact("meet_contact", db.storage[object:id()].meet))
	
	-- Actions
	local action = action_meet_wait (object:name(),"action_process_meet", db.storage[object:id()].meet, char_ini)
	action:add_precondition		(world_property(stalker_ids.property_alive, true))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
	action:add_precondition		(world_property(properties["danger"],		true))
	action:add_precondition		(world_property(properties["contact"], 		true))
	action:add_precondition		(world_property(properties["wounded"], 		false))
	action:add_effect (world_property(properties["contact"], 			false))
	action:add_effect (world_property(stalker_ids.property_danger,		false))
	manager:add_action (operators["contact"], action)

	action = manager:action (xr_actions_id.alife)	
	action:add_precondition		(world_property(properties["contact"],		false))
end



------------
-- Вызывается только в начале на чтении логики, создает экшены, эвалуаторы и производит
-- первичную настройку.
function set_meet(npc, ini, scheme, section)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
	st.meet_manager = Cmeet_manager(npc, st)
end
-- Вызывается на переключении на новую секцию. Производит вычитывание настроек из текущей секции.
function reset_meet(npc, scheme, st, section)
	local meet_section
--	printf("[%s]", utils.to_str(st.section_logic))
	if scheme == nil or scheme == "nil" then
		meet_section = utils.cfg_get_string(st.ini, st.section_logic, "meet", npc, false, "")
	else
		meet_section = utils.cfg_get_string(st.ini, section, "meet", npc, false, "")
	end
	init_meet(npc, st.ini, meet_section, st.meet, scheme)
end
-- Функция чтения настроек. В нее передается секция, откуда их нужно читать.
function init_meet(npc, ini, section, st, scheme)
	printf("MEET SECTION [%s][%s]", tostring(section), tostring(scheme))

	if tostring(section) == st.meet_section and
	   tostring(section) ~= "nil" 
	then
		return
	end
	
	st.meet_section = utils.tostring(section)
	
	if tostring(section) == "nil" then
		-- Загружаем дефолты!
		if tostring(scheme) == "nil" then
			st.meet_state		= parse_data(npc, "30|hello@hail|20|wait@state")
			st.meet_state_wpn	= parse_data(npc, "30|backoff@threat_weap")
			st.victim			= parse_data(npc, "30|actor")
			st.victim_wpn		= parse_data(npc, "30|actor")
			st.use				= xr_logic.parse_condlist(npc, section, "use", "true")
			st.use_wpn			= xr_logic.parse_condlist(npc, section, "use_wpn", "false")
			st.syndata			= parse_syn_data(npc, "hello@hail|backoff@threat_weap")
		else
			st.meet_state		= parse_data(npc, "")
			st.meet_state_wpn	= parse_data(npc, "")
			st.victim			= parse_data(npc, "")
			st.victim_wpn		= parse_data(npc, "")
			st.use				= xr_logic.parse_condlist(npc, section, "use", "false")
			st.use_wpn			= xr_logic.parse_condlist(npc, section, "use_wpn", "false")
			st.syndata			= parse_syn_data(npc, "")
		end		
	else
		st.meet_state		= parse_data(npc, utils.cfg_get_string(ini, section, "meet_state", npc, false, ""))
		st.meet_state_wpn	= parse_data(npc, utils.cfg_get_string(ini, section, "meet_state_wpn", npc, false, ""))
		st.victim			= parse_data(npc, utils.cfg_get_string(ini, section, "victim", npc, false, ""))
		st.victim_wpn		= parse_data(npc, utils.cfg_get_string(ini, section, "victim_wpn", npc, false, ""))
		local tmp = utils.cfg_get_string(ini, section, "use", npc, false, "")
		if tmp then
			st.use			= xr_logic.parse_condlist(npc, section, "use", tmp)
		else
			st.use			= xr_logic.parse_condlist(npc, section, "use", "")
		end
		tmp = utils.cfg_get_string(ini, section, "use_wpn", npc, false, "")
		if tmp then
			st.use_wpn		= xr_logic.parse_condlist(npc, section, "use_wpn", tmp)
		else
			st.use_wpn			= xr_logic.parse_condlist(npc, section, "use_wpn", "")
		end
		tmp = utils.cfg_get_string(ini, section, "meet_dialog", npc, false, "")
		if tmp then
			st.meet_dialog	= xr_logic.parse_condlist(npc, section, "meet_dialog", tmp)
		else
			st.meet_dialog	= xr_logic.parse_condlist(npc, section, "meet_dialog", "")
		end
		st.zone				= parse_zone_data(npc, utils.cfg_get_string(ini, section, "zone", npc, false, ""))
		st.syndata			= parse_syn_data(npc, utils.cfg_get_string(ini, section, "synpairs", npc, false, ""))
	end
	--print_table(st)

	-- флажок, что функция хотя бы раз вызывалась
	st.meet_set = true
end

function parse_data(npc,s)
--	printf("parse_data [%s]", utils.to_str(s))
	local t = {}

    if s then
		for name in string.gfind( s, "(%|*%d+%|[^%|]+)%p*" ) do
--			printf("[%s]", utils.to_str(name))
			local dat = {	dist = nil,
							state = nil,
							sound = nil}	
			
			local t_pos = string.find( name, "|", 1, true )
			local s_pos = string.find( name, "@", 1, true )
						
			local dist = string.sub( name, 1, t_pos - 1 )
			local state
			local sound
			
			if s_pos then
				state	= string.sub( name, t_pos + 1, 
											s_pos - 1 )
				sound	= string.sub( name, s_pos + 1)
			else
				state	= string.sub( name, t_pos + 1)
			end
		
--			printf("	[%s]=[%s][%s]", utils.to_str(dist), utils.to_str(state), utils.to_str(sound))
			
			dat.dist = tonumber(dist)
			if state then
				dat.state = xr_logic.parse_condlist(npc, dist, state, state)
			end
			if sound then
				dat.sound = xr_logic.parse_condlist(npc, dist, sound, sound)
			end
			table.insert(t, dat)
		end
	end

    return t
end
function parse_zone_data(npc,s)
--	printf("parse_zone_data [%s]", utils.to_str(s))
	local t = {}

    if s then
		for name in string.gfind( s, "(%|*[^%|]+%|[^%|]+)%p*" ) do
--			printf("[%s]", utils.to_str(name))
			local dat = {	zone = nil,
							state = nil,
							sound = nil}			

			local t_pos = string.find( name, "|", 1, true )
			local s_pos = string.find( name, "@", 1, true )
						
			local zone = string.sub( name, 1, t_pos - 1 )
			local state
			local sound
			
			if s_pos then
				state	= string.sub( name, t_pos + 1, 
											s_pos - 1 )
				sound	= string.sub( name, s_pos + 1)
			else
				state	= string.sub( name, t_pos + 1)
			end
		
--			printf("	[%s]=[%s][%s]", utils.to_str(zone), utils.to_str(state), utils.to_str(sound))
			
			dat.zone = zone
			if state then
				dat.state = xr_logic.parse_condlist(npc, zone, state, state)
			end
			if sound then
				dat.sound = xr_logic.parse_condlist(npc, zone, sound, sound)
			end
			table.insert(t, dat)
		end
	end

    return t
end
function parse_syn_data(npc,s)
--	printf("parse_syn_data [%s]", utils.to_str(s))
	local t = {}
    if s then
		for name in string.gfind( s, "(%|*[^%|]+%|*)%p*" ) do
			local dat = {	zone = nil,
							state = nil,
							sound = nil}			
--			printf("[%s]", utils.to_str(name))

			local t_pos = string.find( name, "@", 1, true )
			local s_pos = string.find( name, "|", 1, true )

			local state = string.sub( name, 1, t_pos - 1 )
			local sound
			if s_pos then
				sound = string.sub( name, t_pos + 1, s_pos -1)
			else
				sound = string.sub( name, t_pos + 1)
			end
			
			dat.state = state
			dat.sound = sound
			table.insert(t, dat)
		end
	end

    return t
end

-- ДИАЛОГИ ПОКА НЕ ТРОГАЕМ!!!
--' Считывание доступных диалогов игрока.
function set_actor_dialogs(npc, ini, name, dialog_section)
--	printf("*ACTOR_DIALOGS*")
	if dialog_section == nil then return end
	printf("*ACTOR_DIALOGS*: set_actor_dialogs: npc_name='%s' section='%s'", npc:name(), dialog_section)
	
	local actor_dialogs_string = utils.cfg_get_string(ini, dialog_section, "id", npc, false, "")
	if actor_dialogs_string ~= nil then
		printf("*ACTOR_DIALOGS*: actor_dialogs=%s", actor_dialogs_string)
		--' Создаем в массиве запись где будут храниться считанные диалоги.
		db.storage[npc:id()].actor_dialogs = parse_names(actor_dialogs_string)
	else
		printf("*ACTOR_DIALOGS*: actor_dialogs=nil")
	end
	
	local actor_disable = utils.cfg_get_string(ini, dialog_section, "disable", npc, false, "")
	if actor_disable ~= nil then
		printf("*ACTOR_DIALOGS*: actor_disable=%s", actor_disable)
		--' Создаем в массиве запись где будут храниться считанные диалоги.
		db.storage[npc:id()].actor_disable = parse_names(actor_disable)
	else
		printf("*ACTOR_DIALOGS*: actor_disable=nil")
	end
end
--' ВНИМАНИЕ: Эта функция вызывается и для сталкеров, и для монстров!
function dialog_manager_reset(npc, stype)
	if stype == modules.stype_mobile then
		printf("*DIALOGS*: dialog_manager_reset: npc:name='%s'", npc:name())
		--' Смена стартового диалога
		local overrides = xr_logic.generic_scheme_overrides(npc)
		if overrides ~= nil then
			if overrides.meet_dialog then
				printf("*DIALOGS_MOB*: Set start dialog %s", overrides.meet_dialog)
				npc:set_start_dialog(overrides.meet_dialog)
			else
				printf("*DIALOGS_MOB*: Restore start dialog")
				npc:restore_default_start_dialog()
			end
		else
			printf("*DIALOGS_MOB*: SCHEME HAS NO OVERRIDES: Restore start dialog")
			npc:restore_default_start_dialog()
		end
	end
end
function disable_scheme(npc, scheme)
	db.storage[npc:id()].actor_dialogs = nil
	db.storage[npc:id()].actor_disable = nil
end

--- Находится ли чувак в данный момент в состоянии мита
function is_meet(npc)
	local manager = npc:motivation_action_manager()
	if manager and manager:initialized() then
		local id = manager:current_action_id()
		if id == xr_actions_id.stohe_meet_base + 1 then
			return true
		end
	end
	return false
end