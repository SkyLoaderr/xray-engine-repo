#include "stdafx.h"
#include "PropSlimTools.h"
#include "object.h"
#include "object_sliding.h"

static Object*					g_pObject						= 0;
static ArbitraryList<MeshPt*>	g_ppTempPts						= 0;
static float					g_fSlidingWindowErrorTolerance	= 0.1f;
static BOOL						g_bOptimiseVertexOrder			= FALSE;
static u32						g_bMaxSlidingWindow				= u32(-1);
static VIPM_Result*				g_pResult						= 0;
/*
struct AVertex
{
	Fvector		p; 
	Fvector2	uv;
};
struct AFace
{
	u16 f[3];
};

AVertex av[53]={
	{-163.935593,-103.075432,19.455566, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-96.200432,9.727783, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-89.325432,19.455566, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-89.325432,0.000000, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-103.075432,0.000000, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-89.325432,38.911133, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-103.075432,38.911133, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-96.200432,29.183350, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-75.575432,19.455566, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-82.450432,9.727783, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-75.575432,0.000000, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-61.825432,19.455566, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-68.700432,29.183350, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-61.825432,38.911133, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-75.575432,38.911133, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-68.700432,9.727783, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-61.825432,0.000000, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-82.450432,29.183350, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-48.075432,19.455566, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-54.950432,9.727783, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-48.075432,0.000000, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-54.950432,29.183350, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-48.075432,38.911133, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-132.522949,-103.075432,9.727783, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-122.052078,-103.075432,0.000000, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-132.522949,-103.075432,0.000000, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-142.993835,-103.075432,0.000000, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-122.052078,-103.075432,9.727783, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-122.052078,-103.075432,19.455566, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-132.522949,-103.075432,29.183350, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-122.052078,-103.075432,38.911133, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-122.052078,-103.075432,29.183350, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-132.522949,-103.075432,19.455566, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-142.993835,-103.075432,19.455566, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-132.522949,-103.075432,38.911133, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-142.993835,-103.075432,38.911133, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-142.993835,-103.075432,29.183350, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-153.464722,-103.075432,29.183350, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-153.464722,-103.075432,9.727783, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-142.993835,-103.075432,9.727783, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-153.464722,-103.075432,0.000000, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-153.464722,-103.075432,19.455566, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-103.075432,9.727783, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-153.464722,-103.075432,38.911133, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-103.075432,29.183350, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-89.325432,9.727783, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-89.325432,29.183350, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-75.575432,9.727783, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-75.575432,29.183350, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-61.825432,29.183350, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-61.825432,9.727783, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-48.075432,9.727783, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
	{-163.935593,-48.075432,29.183350, 158839966806181750000000000000000000000.000000,158839966806181750000000000000000000000.000000},
};

AFace af[160]={
	{0,1,2},
	{0,2,1},
	{3,4,1},
	{3,1,4},
	{5,6,7},
	{0,2,7},
	{0,7,2},
	{5,7,6},
	{8,9,2},
	{3,9,10},
	{3,10,9},
	{8,2,9},
	{8,11,12},
	{8,12,11},
	{13,14,12},
	{13,12,14},
	{8,15,11},
	{16,10,15},
	{8,11,15},
	{16,15,10},
	{8,2,17},
	{5,14,17},
	{5,17,14},
	{8,17,2},
	{18,19,11},
	{16,19,20},
	{18,11,19},
	{16,20,19},
	{18,21,11},
	{18,11,21},
	{13,21,22},
	{13,22,21},
	{23,24,25},
	{23,25,26},
	{23,25,24},
	{23,26,25},
	{23,27,28},
	{23,24,27},
	{23,28,27},
	{23,27,24},
	{29,30,31},
	{29,31,28},
	{29,31,30},
	{29,28,31},
	{29,32,33},
	{29,28,32},
	{29,33,32},
	{29,32,28},
	{23,32,33},
	{23,28,32},
	{23,33,32},
	{23,32,28},
	{29,34,35},
	{29,30,34},
	{29,35,34},
	{29,34,30},
	{29,33,36},
	{29,36,35},
	{29,36,33},
	{29,35,36},
	{37,36,33},
	{37,35,36},
	{37,33,36},
	{37,36,35},
	{38,39,26},
	{38,33,39},
	{23,26,39},
	{23,39,33},
	{23,39,26},
	{23,33,39},
	{38,26,39},
	{38,39,33},
	{38,26,40},
	{38,40,4},
	{38,40,26},
	{38,4,40},
	{38,0,41},
	{38,41,33},
	{38,41,0},
	{38,33,41},
	{37,41,0},
	{37,33,41},
	{37,0,41},
	{37,41,33},
	{1,4,42},
	{1,42,0},
	{1,42,4},
	{1,0,42},
	{38,4,42},
	{38,42,0},
	{38,42,4},
	{38,0,42},
	{37,6,43},
	{37,43,35},
	{37,43,6},
	{37,35,43},
	{37,0,44},
	{37,44,6},
	{37,44,0},
	{37,6,44},
	{7,44,0},
	{7,6,44},
	{7,0,44},
	{7,44,6},
	{1,2,45},
	{1,45,3},
	{9,2,45},
	{9,45,3},
	{9,45,2},
	{9,3,45},
	{1,45,2},
	{1,3,45},
	{7,2,46},
	{7,46,5},
	{7,46,2},
	{7,5,46},
	{17,2,46},
	{17,46,5},
	{17,46,2},
	{17,5,46},
	{9,47,8},
	{9,10,47},
	{9,8,47},
	{9,47,10},
	{15,8,47},
	{15,47,10},
	{15,47,8},
	{15,10,47},
	{12,48,14},
	{12,8,48},
	{12,14,48},
	{12,48,8},
	{17,14,48},
	{17,48,8},
	{17,48,14},
	{17,8,48},
	{12,11,49},
	{12,49,13},
	{12,49,11},
	{12,13,49},
	{21,49,11},
	{21,13,49},
	{21,11,49},
	{21,49,13},
	{19,50,11},
	{19,16,50},
	{19,11,50},
	{19,50,16},
	{15,11,50},
	{15,50,16},
	{15,50,11},
	{15,16,50},
	{19,18,51},
	{19,51,20},
	{19,51,18},
	{19,20,51},
	{21,18,52},
	{21,52,22},
	{21,52,18},
	{21,22,52},
};



void VIPM_Test()
{
	VIPM_Init();

	for (u32 k=0; k<53; k++){
		AVertex& v = av[k];
		VIPM_AppendVertex(v.p, v.uv);
	}
	for (k=0; k<160; k++){
		AFace& f = af[k];
		VIPM_AppendFace(f.f[0],f.f[1],f.f[2]);
	}

	VIPM_Convert(30,1,1);

	VIPM_Destroy();
}
*/

static bool bWrite = false;

ETOOLS_API void			VIPM_Init			()
{
	R_ASSERT2	(0==g_pObject,"VIPM already in use!");
	g_pObject							= xr_new<Object>();
	g_pResult							= xr_new<VIPM_Result>();
	g_pObject->iNumCollapses			= 0;
	g_pObject->iCurSlidingWindowLevel	= 0;
	if (bWrite){
		OutputDebugString("-------------------------");
	}
}

ETOOLS_API void			VIPM_AppendVertex	(const Fvector3& p, const Fvector2& uv)
{
	MeshPt* pt			= xr_new<MeshPt>	(&g_pObject->CurPtRoot);
	g_ppTempPts.push_back(pt);
	pt->mypt.vPos 		= p;
	pt->mypt.fU			= _abs(uv.x)>1000.f?0.f:uv.x;
	pt->mypt.fV			= _abs(uv.y)>1000.f?0.f:uv.y;
	pt->mypt.dwIndex	= g_ppTempPts.size()-1;

	if (bWrite){
		string256			tmp;
		sprintf				(tmp,"{%f,%f,%f, %f,%f},\n",p.x,p.y,p.z, uv.x, uv.y);
		OutputDebugString	(tmp);
	}
}

ETOOLS_API void			VIPM_AppendFace		(u16 v0, u16 v1, u16 v2)
{
	xr_new<MeshTri>(g_ppTempPts[v0],g_ppTempPts[v1],g_ppTempPts[v2], &g_pObject->CurTriRoot, &g_pObject->CurEdgeRoot );
	if (bWrite){
		string256			tmp;
		sprintf				(tmp,"{%d,%d,%d},\n",v0,v1,v2);
		OutputDebugString	(tmp);
	}
}

void CalculateAllCollapses(Object* m_pObject, u32 max_sliding_window=u32(-1), float m_fSlidingWindowErrorTolerance=1.f)
{
	m_pObject->BinEdgeCollapse();
	while (true){
		// Find the best collapse you can.
		// (how expensive is this? Ohhhh yes).
		float		fBestError			= 1.0e10f;
		MeshEdge	*pedgeBestError		= NULL;
		MeshPt		*pptBestError		= NULL;
		// NL = NewLevel - would force a new level.
		float		fBestErrorNL		= 1.0e10f;
		MeshEdge	*pedgeBestErrorNL	= NULL;
		MeshPt		*pptBestErrorNL		= NULL;
		MeshPt		*ppt;
		MeshEdge	*pedge;

		float		fAverage			= 0.0f;
		int			iAvCount			= 0;

		// Flush the cache, just in case.
		m_pObject->FindCollapseError		( NULL, NULL, FALSE );

		for ( ppt = m_pObject->CurPtRoot.ListNext(); ppt != NULL; ppt = ppt->ListNext() ){
			if (0==ppt->FirstEdge())	continue;
			// Disallow any pts that are on an edge - shouldn't be collapsing them.
			BOOL bAllowed = TRUE;
			for ( pedge = ppt->FirstEdge(); pedge != NULL; pedge = ppt->NextEdge() ){
				if ( ( pedge->pTri12 == NULL ) || ( pedge->pTri21 == NULL ) ){
					// This edge does not have two tris on it - disallow it.
					bAllowed = FALSE;
					break;
				}
			}
			if ( !bAllowed ) continue;

			BOOL bRequiresNewLevel = FALSE;
			if ( !m_pObject->CollapseAllowedForLevel ( ppt, m_pObject->iCurSlidingWindowLevel ) ){
				// This collapse would force a new level.
				bRequiresNewLevel = TRUE;
			}

			// collect error
			for ( pedge = ppt->FirstEdge(); pedge != NULL; pedge = ppt->NextEdge() ){
				float fErrorBin = m_pObject->FindCollapseError ( ppt, pedge, TRUE );
				iAvCount++;
				fAverage += fErrorBin;
				if ( bRequiresNewLevel ){
					if ( fBestErrorNL > fErrorBin ){
						fBestErrorNL = fErrorBin;
						pedgeBestErrorNL = pedge;
						pptBestErrorNL = ppt;
					}
				}else{
					if ( fBestError > fErrorBin ){
						fBestError = fErrorBin;
						pedgeBestError = pedge;
						pptBestError = ppt;
					}
				}
			}
		}
		fAverage /= (float)iAvCount;

		// Tweak up the NewLevel errors by a factor.
		if ( fBestError > ( fBestErrorNL + fAverage * m_fSlidingWindowErrorTolerance ) ){
			// Despite the boost, it's still the best,
			// so bite the bullet and do the collapse.
			fBestError = fBestErrorNL;
			pedgeBestError = pedgeBestErrorNL;
			pptBestError = pptBestErrorNL;
		}

		//-----------------------------------------------------------------------------------------------------------
		// Do we need to do any collapses?
		// Collapse auto-found edge.
		if ( ( pedgeBestError != NULL ) && ( pptBestError != NULL ) ){
			MeshPt *pKeptPt = pedgeBestError->OtherPt ( pptBestError ); 
			VERIFY ( pKeptPt != NULL );
			m_pObject->CreateEdgeCollapse ( pptBestError, pKeptPt );
		}else{
			break;
		}

		// max sliding window
		if (m_pObject->iCurSlidingWindowLevel>max_sliding_window) break;
	}
}

ETOOLS_API VIPM_Result*	VIPM_Convert		(u32 max_sliding_window, float error_tolerance, u32 optimize_vertex_order)
{
	if (bWrite){
		string256			tmp;
		sprintf(tmp,"%d %f %d",max_sliding_window, error_tolerance, optimize_vertex_order);
		OutputDebugString(tmp);
	}
	g_pObject->Initialize	();
	CalculateAllCollapses	(g_pObject,max_sliding_window,error_tolerance);
	CalculateSW				(g_pObject,g_pResult,optimize_vertex_order);
	return g_pResult		;
}

ETOOLS_API void			VIPM_Destroy		()
{
	xr_delete			(g_pResult);
	xr_delete			(g_pObject);
	g_ppTempPts.resize	(0);
}
/*
ETOOLS_API BOOL ContractionGenerate		(QSMesh* src_mesh, QSContraction*& dst_conx, u32 min_faces, float max_error)
{

	dst_conx				= xr_new<QSContraction>(src_mesh->verts.size());

	CalculateAllCollapses	(m_pObject);
	OMSlidingWindow* SM		= xr_new<OMSlidingWindow>(m_pObject);
	
	SM->Update				();

	// Find the record.
	int iLoD = 700;
	if ( iLoD < 0 )						iLoD = 0;
	else if ( iLoD > SM->iNumCollapses )iLoD = SM->iNumCollapses;
	SlidingWindowRecord *pswr = SM->swrRecords.item ( iLoD );

	// write SMF
	IWriter* W			= FS.w_open("x:\\import\\original.smf");
	string256 tmp;
	// vertices
	for (u32 v_idx=0; v_idx<SM->vertices.size(); v_idx++){
		ETOOLS::QSVert& v = SM->vertices[v_idx];
		sprintf			(tmp,"v %f %f %f",v.pt.x,v.pt.y,-v.pt.z);
		W->w_string		(tmp);
	}
	// transfer faces
	for (u32 f_idx=0; f_idx<pswr->wNumTris; f_idx++){
		ETOOLS::QSFace& F = SM->indices[f_idx+pswr->dwFirstIndexOffset/3];
		sprintf			(tmp,"f %d %d %d",F.v[2]+1,F.v[1]+1,F.v[0]+1);
		W->w_string		(tmp);
	}
	FS.w_close	(W);

	// -----
	xr_delete				(SM);
	xr_delete				(m_pObject);

	return TRUE;
}
*/